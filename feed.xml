<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://lcy960729.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lcy960729.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2021-03-08T21:52:04+09:00</updated><id>https://lcy960729.github.io/feed.xml</id><title type="html">CY 개발 블로그</title><subtitle></subtitle><author><name>Lee Chan Young</name><email>lcy960729@gmail.com</email></author><entry><title type="html">HTTP 1.1 Reference - Message Syntax and Routing (1) (최종 수정 날짜 : 2021-03-08)</title><link href="https://lcy960729.github.io/http/2021/03/08/HTTP1-1-Message-SyntaxAndRouting.html" rel="alternate" type="text/html" title="HTTP 1.1 Reference - Message Syntax and Routing (1) (최종 수정 날짜 : 2021-03-08)" /><published>2021-03-08T00:00:00+09:00</published><updated>2021-03-08T00:00:00+09:00</updated><id>https://lcy960729.github.io/http/2021/03/08/HTTP1-1-Message-SyntaxAndRouting</id><content type="html" xml:base="https://lcy960729.github.io/http/2021/03/08/HTTP1-1-Message-SyntaxAndRouting.html">&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본&lt;br /&gt;
&lt;a href=&quot;https://roka88.dev/106&quot;&gt;https://roka88.dev/106&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MDN Web Docs&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP&quot;&gt;https://developer.mozilla.org/ko/docs/Web/HTTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외 자료는 내용 중 링크 추가&lt;/p&gt;
&lt;h5 id=&quot;틀린-내용-부족한-내용-꼭-지적-부탁드립니다&quot;&gt;틀린 내용, 부족한 내용 꼭 지적 부탁드립니다!&lt;/h5&gt;

&lt;h1 id=&quot;1-introduction&quot;&gt;1. Introduction&lt;/h1&gt;
&lt;p&gt;HTTP는 정보 시스템을 위한 일반적인 인터페이스 프로토콜이다. HTTP는 제공되는 리소스 유형과 무관한 클라이언트에 균일한 인터페이스를 
제공하여 서비스 구현 방법에 대한 세부 정보를 숨기도록 설계되었다. 마찬가지로, 서버는 각 클라이언트의 목적을 인식할 필요가 없다. 
HTTP 요청은 특정 클라이언트 또는 미리 결정된 어플리케이션 단계 순서와 연결되지 않고 단독으로 고려될 수 있다. 
그 결과 많은 다양한 맥락에서 효과적으로 사용될 수 있고 구현이 시간이 지남에 따라 독립적으로 진화할 수 있는 프로토콜이다.&lt;/p&gt;

&lt;p&gt;HTTP는 비 HTTP 정보 시스템 간에 통신 변환을 위한 중개 프로토콜로써 사용하기 위해 설계되었다. HTTP 프록시 및 게이트웨이는 
다양한 프로토콜을 HTTP 서비스와 동일한 방법으로 클라이언트가 보고 조작할 수 있는 하이퍼텍스트 형식으로 변환하여 대체 정보 
서비스에 대한 접근을 제공할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 유연성의 결과 중 하나는 프로토콜이 인터페이스 뒤에서 발생하는 것으로 정의될 수 없다는 것이다. 
대신, 우리는 수신된 통신, 수신인의 예상된 동작, 통신 구문을 정의하는 것으로 제한된다.
통신이 분리되어 고려되는 경우, 성공적인 행위는 서버가 제공하는 관찰 가능한 인터페이스의 해당 변경사항에 반영되어야 한다.
그러나 여러 클라이언트들가 병렬적으로, 교차 목적으로 작동할 수 있기 때문에, 우리는 단일 응답의 범위를 넘어서는 그러한 
변화를 관찰할 수 있도록 요구할 수 없다.&lt;/p&gt;

&lt;p&gt;이 문서는 HTTP에서 사용되거나 참조되는 아키텍처 요소를 설명하고, HTTP, HTTPS URI 구문을 정의하며, 
전체 네트워크 운영 및 커넥션 관리를 설명하고, HTTP 메시지 프레임 및 전달 요구 사항을 정의한다. 
우리의 목표는 메시지 의미론과 독립적인 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 분석기 및 
메시지 전달 중개자에 대한 전체 요구 사항을 정의하는 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;무슨 내용인지 아직 이해가 잘 안된다… 읽고나서 이해가 되면 설명을 덧붙이겠다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;2-architecture&quot;&gt;2. Architecture&lt;/h1&gt;
&lt;p&gt;HTTP는 World Wide Web (WWW) 이키텍처를 위해 만들어 졌고, 시간이 지남에 따라 월드 와이드 하이퍼 텍스트 시스템의 확장성에 
대한 요구들을 지원하기 위해 발전했다. 아키텍처의 대부분이 용어와 HTTP 정의를 위해 사용되는 구문들에 반영되었다.&lt;/p&gt;

&lt;h2 id=&quot;21-clientserver-messaging&quot;&gt;2.1. Client/Server Messaging&lt;/h2&gt;
&lt;p&gt;HTTP는 신뢰성 있는 전송 계층 또는 세션 계층 “connection”의 메시지 교환에 의해 작동되는 상태 없는 요청/응답 프로토콜이다. 
HTTP 클라이언트는 하나 이상의 HTTP 요청들을 전송하기 위한 목적으로 커넥션을 서버에 설립하는 프로그램이다.&lt;/p&gt;

&lt;p&gt;client와 server라는 용어들은 특정 커넥션에 대한 프로그램 수행의 역할만 의미한다. 동일한 프로그램이 일부 커넥션에서는 클라이언트 
역할을 하고 다른 커넥션에서는 서버 역할을 할 수 있다.&lt;br /&gt;
user agent는 브라우저, 스파이터 (웹 기반 로봇), 커맨드 라인 툴, 
커스텀 응용 프로그램, 그리고 모바일 앱을 포함해서 요청을 시작하는 다양한 클라이언트 프로그램을 말한다.&lt;br /&gt;
origin server는 특정 대상 리소스에 대한 권한 있는 응답을 생성할 수 있는 프로그램이다. 
sender(발신자)와 recipient(수신자)는 주어진 메시지를 전송하고 수신하도록 구현된 모든것들을 의미한다.&lt;/p&gt;

&lt;p&gt;HTTP는 대상 리소스와 리소스들간의 관계를 나타내기 위해서 URI 표준에 의존한다. 인터넷 메일과 Multipurpose Internet Mail Extensions(MIME)에 
의해 사용된 유사한 포멧으로 메시지는 전송된다.&lt;/p&gt;

&lt;p&gt;대부분의 HTTP 통신은 URI로 식별된 일부 리소스의 representation을 위한 GET(검색 요청)로 구성된다. 
가장 간단한 경우로 사용자 에이전트와 오리진 서버 사이의 단일 양방향 커넥션을 통해 이 작업을 수행할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;           request &amp;gt;  
User Agent ==================== Origin Server
                     &amp;lt; response
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;클라이언트 HTTP 요청을 서버에 요청 메시지 형식, method, URI와 프로토콜 버전을 포함한 request-line을 시작으로, 
요청 수정자, 클라이언트 정보, 표현 메타 데이터를 포함하는 헤더 필드와 헤더 영역의 끝을 알리는 빈줄 이후,
마지막으로 페이로드 본문을 포함하는 메시지 본문을 보낸다.&lt;/p&gt;

&lt;p&gt;서버는 클라이언트의 요청에 하나 또는 다수의 HTTP 응답 메시지를 각각의 프로토콜 버전, 성공 또는 에러 코드, 
원문으로 된 상태 코드를 포함한 status-line을 시작으로, 가능하다면 서버 정보, 리소스 메타 데이터와 representation 메타 데이터를 포함하는 
헤더 필드를 헤더 부분의 끝을 나타내는 빈줄과 함께 포함하고, 마지막으로 페이로드 body를 포함한 메시지 본문으로 응답을 한다.&lt;/p&gt;

&lt;p&gt;아래의 예시는 GET 요청을 위한 일반적인 메시지 교환을 나타낸다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-h&quot;&gt;&quot;http://www.example.com/hello.txt&quot;

Client
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.71 zlib/1.2.3 
Host: www.example.com
Accept-Lanuage: en, mi

Server : 
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT 
ETag: &quot;34aa387-d-1568eb00&quot;
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain
Hello World! My payload includes a trailing CRLF.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;22-implementation-diversity-구현-다양성&quot;&gt;2.2. Implementation Diversity (구현 다양성)&lt;/h2&gt;
&lt;p&gt;HTTP 설계를 고려할 때, 모든 사용자 에이전트들이 범용 브라우저들이고 모든 오리진 서버들이 큰 규모의 
공용 웹사이트라는 생각의 함정에 빠지는 것이 쉽다. 이것은 잘못된 생각이다. 보통의 HTTP 사용자 에이전트는 
가정 어플리케이션, 음향기기, 체중계, 스크립트를 갱신하는 firmware, command-line 프로그램, 모바일 앱, 
그리고 다양한 모양과 크기의 통신 기기를 포함한다. 마찬가지로, 보통의 HTTP 오리진 서버는 홈 자동화 장치, 네트워킹을 구성하는 부품, 
사무용 기계, 자율 로봇, 뉴스 피드, 트래픽 카메라, 광고 선택자, 그리고 비디오-배송 플랫폼을 포함한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;User Agent는 요청시 소프트웨어 에이전트와 직접적으로 상호작용하는 사용자가 있음을 의미하지 않는다. 
대부분의 경우, 사용자 에이전트가 설치되거나 구성되어 백그라운드에서 실행되고 나중에 검사할 수 있도록 결과를 저장한다.
(관심있 있거나 문제를 일으키는 결과 중 일부만 저장). 예시로 스파이더는 일반적으로 시작 URI가 주어지고, 웹을 하이퍼텍스트 그래프로 크롤링하는 동안 
특정 행동을 따르도록 구성되었다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;HTTP의 구현 다양성은 모든 사용자 에이전트가 사용자에게 대화형 제안을 하거나 보안 또는 개인정보 보호 문제에 대한 적절한 경고를 제공할 수 없음을 의미한다. 
이 규격에서 사용자에게 오류를 보고해야 하는 몇 가지 경우에는 오류 콘솔이나 로그파일에서만 이러한 보고를 관찰할 수 있다.
마찬가지로 사용자가 계속하기 전에 자동작업을 확인해야 하는 요구 사항은 사전 구성 선택, 런타입 옵션 또는 단순한 안전하지 않은 작업 회피로 충족될 수 있다.
확인은 사용자가 이미 선택한 경우 특정 사용자 인터페이스 또는 정상 처리 중단을 의미하지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;23-intermediaries-중개인&quot;&gt;2.3. Intermediaries (중개인)&lt;/h2&gt;
&lt;p&gt;HTTP를 사용하면 커넥션 체인을 통해 요청을 충족할 수 있다. HTTP 중개자로 세가지 일반적인 형식이 있따. 프록시, 게이트웨이, 터널.
경우에 따라 단일 중개자가 오리진 서버, 프록시, 게이트웨이 또는 터널역할을 하여 각 요청의 특성에 따라 동작을 전환 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &amp;gt;      &amp;gt;      &amp;gt;      &amp;gt; 
UA ==== A ==== B ==== C ==== O
      &amp;lt;      &amp;lt;      &amp;lt;      &amp;lt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 그림은 사용자 에이전트와 오리진 서버 사이에 3개의 중개자 (A, B와 C)를 보여준다. 전체 체인을 이동하는 요청 또는 응답 메시지는 
4개의 분리된 커넥션을 통해 전송된다. 일부 HTTP 통신 옵션들은 가장 가까운 터널이 아닌 인접 네트워크와의 커넥션에만 적용되거나 체인의 끝점에만 
적용되거나 체인을 따라 있는 모든 커넥션에 적용될 수 있다. 다이어그램은 선형이지만, 각 참여자는 여러개의 동시 통신에 참여할 수 있다. 
예를 들어 B는 A외에 여러 클라이언트로부터 요청을 받을 수 있거나 또는 같은 시간에 A의 요청을 다루면서 C이외에 서버로 요청을 전송할 수 있다. 
마찬가지로 나중의 요청들은 로드 밸런싱을 통한 동적인 구성에 기반하여 커넥션의 다른 경로를 통해 전송될 것이다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Upstream과 Downstream은 메시지 흐름의 관계에서 방향 요구사항들을 설명하기 위해 사용된다. 모든 메시지들은 Upstream으로 부터 Downstream으로 흐른다. 
Inbound와 Outbound는 요청 라우트의 관계에서 방향 요구사항들을 설명하기 위해 사용된다. Inbound는 오리진 서버로 향하는 것을 의미하고, Outbound는 
사용자 에이전트로 향하는 것을 의미한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Proxy는 클라이언트가 일반적으로 로컬 구성 규칙들을 통해 선택한 메시지-전송 에이전트로, 일부 유형의 absolute URI에 대한 요청을 수신하고 HTTP 인터페이스를 통한 변환을 통해 
해당 요청을 충족시키려고 시도한다. HTTP URI에 대한 프록시 요청과 같이 일부 번역은 최소 수준이지만 다른 요청은 완전히 
다른 애플리케이션 레벨 프로토콜 간에 변환이 필요할 수 있다. 프록시들은 종종 보안적 이익, 주석 서비스, 또는 공유 캐시를 위한 
공통 중개자로 조직의 HTTP 요청들을 그룹화 하는데 자주 사용된다. 일부 프록시들은 선택된 메시지 또는 페이로드가 전송되는 동안 
변환을 적용하기 위해 설계 되었다.&lt;/p&gt;

&lt;p&gt;추가적인 설명으로 인터넷의 다른 네트워크를 탐색 할 때 프록시 서버와 HTTP 터널은 WWW의 컨텐츠에 대한 엑세스를 용이하게 한다. 
프록시는 사용자의 로컬 컴퓨터에 있거나 사용자의 컴퓨터와 인터넷의 대상 서버 사이에 있을 수 있다.
프록시는 포워드 프록시(터널, 게이트웨이)와 리버스 프록시(로드 밸런싱, 인증, 복호화, 캐싱을 위해 서버에 대한 엑세스를 제어하고 보호하는데 사용)의 두가지 유형이 있다.&lt;/p&gt;

&lt;p&gt;포워드 프록시
정방향 프록시, 게이트웨이 또는 프록시는 클라이언트 또는 클라이언트 그룹에 프록시 서비스를 제공한다. 인터넷에는 수십만 개의 오픈 포워드 프록시가 있다. 
그룹에서 사용하는 대역폭을 줄이고 제어하기 위해 DNS 또는 웹 페이지와 같은 인터넷 서비스를 저장하고 전달한다.
전달 프록시는 익명 프록시 일 수도 있으며 사용자가 웹을 검색하거나 다른 인터넷 서비스를 사용하는 동안 IP 주소를 숨길 수 있다. 
The Onion Router는 익명 성을 위해 여러 프록시를 통해 인터넷 트래픽을 라우팅한다.&lt;/p&gt;

&lt;p&gt;리버스 프록시
이름에서 알 수 있듯이 리버스 프록시는 포워드 프록시가 수행하는 작업과 반대로 수행한다. 포워드 프록시는 클라이언트(또는 요청 호스트)를 대신하여 작동한다. 
포워드 프록시는 클라이언트 ID를 숨길 수 있는 반면 리버스 프록시는 서버의 ID를 숨길 수 있다. 리버스 프록시는 사용 사례는 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;로드 밸런싱 : 로드를 여러 웹 서버에 분산&lt;/li&gt;
  &lt;li&gt;정적 컨텐츠 캐시 : 사진과 같은 정적 컨텐츠를 캐싱하여 웹 서버를 오프로드 한다.&lt;/li&gt;
  &lt;li&gt;압축 : 컨텐츠를 압축하고 최적화하여 로드 시간을 단축한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;Gateway는 (reverse proxy) 아웃바운드 커넥션을 위한 오리진 서버로써 역할을 하지만, 수신된 요청을 다른 서버로 변환하여 
인바운드로 전송하는 중간 서버 역할을 한다. 게이트웨이는 오래된 또는 신뢰 할 수 없는 정보 서비스들을 캡슐화 하는데 사용 되며, 
서버의 성능을 향상 시키기 위해 accelerator 캐싱, 그리고 파티셔닝 또는 여러 시스템 간의 HTTP 서비스의 로드 밸런싱을 할 수 있게 사용된다.&lt;/p&gt;

&lt;p&gt;오리진 서버에 적당한 모든 HTTP 요구사항은 게이트웨이의 아웃바운드 통신에도 적용된다. 게이트웨이는 private extensions(개인적으로 프로토콜을 확장한 것들)을 
이 명세의 범위 밖의 HTTP에 포함하여 원하는 프로토콜을 사용하여 인바운드 서버와 통신한다. 그러나 서드파티 HTTP 서버들과 상호작용하는 HTTP-to-HTTP 게이트 웨이는 
게이트웨이의 인바운드 커넥션에 대한 사용자 에이전트의 요구사항에 준수해야 한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Tunnel은 메시지 변경없이 2개의 커넥션에 숨겨진 중개자로써 역할을 한다. 터널이 활성되면, HTTP 요청에 의해 시작되었을 수 있지만, 
터널은 HTTP 통신의 당사자로 고려되지 않는다. 두 끝점에서 전달하는 커넥션이 종료되면 터널은 더 이상 존재하지 않는다. 
공유 방화벽 프록시를 통해 기밀 통신을 설정하는데 전송층 보안(TLS)이 사용되는 경우와 같이 중계를 통해 가상 커넥션을 확장하는데 터널이 사용된다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;중개자를 위한 범주는 HTTP 통신의 참가자로써 역할만 고려됐다. 또한 네트워크 프로토콜 스택의 하위 계층에서 행동하여 메시지 보낸 사람의 
확인이나 허가 없이 HTTP 트래픽을 필터링하거나 리다이렉트 할 수 있는 중개자도 있다. 네트워크 중개자들은 중간자 공격(프로토콜 단계에서)을 구분할 수 없으며, 
실수로 HTTP 의미론을 위반하여 보안 결함 또는 상호 운용성 문제를 야기하는 경우가 많다.&lt;/p&gt;

&lt;p&gt;예를 들어, interception proxy(transparent proxy로 알려진)는 클라이언트에 의해서 선택되지 않았기 때문에 
HTTP 프록시와 다르다. 대신에, interception proxy는 외부의 TCP 포트 80 패킷 (그리고 가끔 다른 일반적인 포트 트래픽)을 거르거나 또는 리다이렉트 한다. 
interception proxy는 일반적으로 로컬이 아닌 인터넷 서비스 사용을 허용하기 전에 계정 가입을 적용하는 수단으로 공용 네트워크 엑세스 지점에서, 
네트워크 사용정책을 시행하기 위해 회사 방화벽 내에서 발견 된다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;HTTP는 상태 없는 프로토콜로 정의되었고, 각 요청 메시지는 개별적으로 이해될 수 있다는것을 의미한다. 
대부분의 구현은 프록시된 커넥션을 재사용하거나 또는 여러 서버간에 동적으로 로드 밸런스 요청을 하기 위해 HTTP의 상태 없는 설계에 의존한다. 
따라서 서버는 커넥션이 보안되어 있고 해당 에이전트에 특정되어 있지 않는한 동일한 커넥션에 대한 두개의 요청이 동일한 사용자 에이전트에서 온 것으로 가정해서는 안 된다. 
일부 비표준 HTTP 확장들은 이 요구사항을 위반하고, 보안 및 상호작용 문제를 발생시킨다.&lt;/p&gt;

&lt;h2 id=&quot;24-caches&quot;&gt;2.4. Caches&lt;/h2&gt;
&lt;p&gt;Cache는 이전 응답 메시지의 로컬 보관소이고 메시지의 저장, 검색, 삭제를 관리하는 서브 시스템이다. 캐시는 캐시 가능한 응답을 저장하여 
향후 동일한 요청에 대한 응답 시간과 네트워크 대역폭 사용을 줄인다. 캐시는 서버가 터널 역할을 하는 동안에는 사용될 수 없지만, 
어느 클라이언트 또는 서버는 캐시를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;캐시의 효과는 체인의 참여자 중 하나가 해당 요청에 적용할 수 있는 캐시된 응답을 가지고 있는 경우 요청/응답 체인이 단축 되는 것이다. 
다음은 B가 UA 또는 A에 의해 캐시되지 않은 요청에 대한 O(경유 C)의 이전 응답의 캐시된 사본을 가지고 있는 경우의 결과 체인을 보여준다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &amp;gt;      &amp;gt;
UA ==== A ==== B ---- C ---- O
      &amp;lt;      &amp;lt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;캐시가 후속 요청에 응답하기 위해 응답 메시지의 복사본을 저장할 수 있는 경우 응답은 “cacheable”이다. 응답을 캐시할 수 있는 경우에도 캐시된 응답을 
특정 요청에 사용할 수 있는 경우 클라이언트 또는 원서버에 의해 추가 제약이 있을 수 있다.&lt;/p&gt;

&lt;p&gt;월드 와이드 웹과 대규모 조직에 걸쳐 배치된 캐시의 설계와 구성은 매우 다양하다. 대양을 횡단하는 대역폭을 아끼기 위한 프록시 캐시의 국가 계층 구조, 브로드 캐스트 또는 멀티 캐스트 캐시 엔트리를 위한 협업 시스템, 
오프라인 또는 high-latency 환경들에서 사용하기 위한 pre-fetched 캐시 엔트리의 아카이브 등이 포함된다.&lt;/p&gt;

&lt;h2 id=&quot;25-conformance-and-error-handling&quot;&gt;2.5. Conformance and Error Handling&lt;/h2&gt;
&lt;p&gt;이 명세는 HTTP 통신의 참여자의 규칙에 따라 적합성 기준을 대상으로 한다. 따라서 HTTP 요구사항은 어떤 행동이 요구사항에 의해 
제한되고 있는지에 따라서 발신자, 수신자, 클라이언트, 서버, 사용자 에이전트, 중개자, 원서버, 프록시, 게이트웨이, 또는 캐시가 배치되어 있다. 
구현, 리소스 소유자 및 프로토콜 요소 등록이 단일 통신 범위를 벗어나 적용되는 경우 추가 (관행적) 요구 사항이 적용된다.&lt;/p&gt;

&lt;p&gt;동사 Generate는 프로토콜 요소를 생성하는 것과 단지 수신된 요소를 다운스트림에서 전달하는 것 사이에서 요구사항이 구별되는 Send 대신 사용 된다.&lt;/p&gt;

&lt;p&gt;구현은 HTTP에 맞는 규칙들과 관련된 모든 요구사항들을 따른다면, 적합한 것으로 간주 된다.&lt;/p&gt;

&lt;p&gt;적합성은 구문과 프로토콜 요소의 의미론을 둘 다 포함한다. 발신자는 발신자가 거짓이라는 알려진 의미를 전달하는 프로토콜 요소를 생성하면 안 된다. 
발신자는 ABNF 규칙에 대응하는 정의된 문법에 맞지 않는 프로토콜 요소를 생성하면 안 된다. 지정된 메시지 내에서, 발신자는 다른 역할(i.e., 해당 메시지에 발신자에게 없는 역할)의 참가자만 생성할 수 있는 
프로토콜 요소나 구문 대안을 생성하면 안 된다.&lt;/p&gt;

&lt;p&gt;수신된 프로토콜 요소가 분석되었을 때, 수신자는 수신자의 역할에 해당하는 적정한 길이의 값과 분석할 수 있어야 하며 ABNF 규칙들에 
대응하는 정의된 문법에 일치해야 한다. 참고로, 일부 수신된 요소들은 분석 되지 않을 수 있다. 예를 들어 메시지를 전송하는 중개자는 일반 
Field-name과 Field-value 성분들의 header-field를 분석할 수 있고, field-value의 추가적인 분석 없이 헤더 필드를 전송하는 것도 있다.&lt;/p&gt;

&lt;p&gt;HTTP 구현의 문맥 배치와 목적에 따라 적절한 길이가 매우 다양하기 때문에 대부분의 프로토콜 요소에 대해 특정한 길이 제한을 가지고 있지 않는다. 
따라서, 발신자와 수신자 사이의 상호작용은 각 프로토콜 요소를 위한 적정한 길이가 무엇인지에 관한 공유된 예상에 의존한다. 
게다가 일부 프로토콜 요소에 대해 일반적으로 적절한 길이로 이해되는 것은 지난 20년 동안 HTTP 사용과정에서 바뀌었으며 앞으로도 계속 변화할것이다.&lt;/p&gt;

&lt;p&gt;최소한, 수신자는 다른 메시지의 동일한 프로토콜 요소에 대해 생성한 값만큼 프로토콜 요소 길이를 구문 분석하고 처리할 수 있어야 한다. 
예를 들어 자체 리소스에 매우 긴 URI 참조를 게시하는 오리진 서버는 요청 대상으로 수신될 때 동일한 참조를 구문 분석하고 처리할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;수신자는 수신자가 해당 의미론에 의해 암시된 것을 잘못 구현한다고 (경험이나 구성을 통해) 판단하지 않는 한, 
수신자는 이 명세에 정의된 의미론에 따라 수신된 프로토콜 요소를 해석해야 한다. 예를 들어 User-Agent 헤더 필드 검사에서 
특정 콘텐츠 코딩을 수신할 때 실패한 것으로 알려진 특정 구현 버전을 나타내는 경우 오리진 서버는 수신된 Accept-Encoding 헤더 필드의 내용을 무시할 수 있다.&lt;/p&gt;

&lt;p&gt;달리 명시되지 않은 한, 수신자는 잘못된 구조에서 사용 가능한 프로토콜 요소를 복구하려고 시도할 수 있다. 
HTTP는 보안에 직접적인 영향을 미치는 경우를 제외하고 특정 오류 처리 메커니즘을 정의하지 않는데, 
프로토콜의 서로 다른 응용 프로그램에는 다른 오류 처리 전략이 필요하기 때문이다. 예를 들어 웹브라우전느 Location 헤더 필드가 
ABNF에 따라 구문 분석되지 않는 응답에서 투명하게 복구하기를 원하는 반면, 시스템 제어 클라이언트는 어떤 형태의 오류 복구도 
위험하다고 간주할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;26-protocol-versioning&quot;&gt;2.6. Protocol Versioning&lt;/h2&gt;
&lt;p&gt;HTTP는 “&lt;major&gt;.&lt;minor&gt;&quot;를 프로토콜의 버전의 번호를 표시하기 위해 사용한다. 이 규격은 버전 1.1을 정의한다.
프로토콜 버전 전체는 발신자가 해당 버전의 HTTP 사양에 명시된 요건 집합을 준수하고 있음을 나타낸다.&lt;/minor&gt;&lt;/major&gt;&lt;/p&gt;

&lt;p&gt;HTTP 메시지 버전은 메시지의 첫번째 행에 HTTP-version 필드로 표시된다. HTTP-version은 대 소문자를 구분한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP-Version = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
HTTP-name = %x48.54.54.50 ; &quot;HTTP&quot;, case-sensitive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HTTP 버전 번호는 “.”로 구분된 두개의 10진수로 구성된다. 첫번째 숫자 (major)는 HTTP 메시징 구문을 나타내고, 
두번째 숫자(minor)는 발신자에 적합하고 이후 통신을 이해할 수 있는 해당 major버전 내에서 가장 높은 minor 버전을 나타낸다.
minor 버전은 발신자가 역으로 호환되는 프로토콜의 하위 집합만 사용하는 경우에도 발신자의 통신 기능을 알리므로 수신자는 더 많은 
고급 기능을 응답 또는 향후 요청에 사용할 수 있음을 알수 있다.&lt;/p&gt;

&lt;p&gt;HTTP/1.1 메시지가 HTTP/1.0 수신자 또는 버전을 알 수 없는 수신자에게 전송 될때, HTTP/1.1 메시지는 새로운 기능이 모두 무시될 경우 유효한 
HTTP/1.0 메시지로 해석될 수 있도록 구성된다. 이 규격은 수신자가 HTTP/1.1을 지원하는 구성 또는 메시지 수신을 결정할 때까지 호환 가능한 기능만 
사용하도록 일부 새 기능에 대한 recipient-version 요구 사항을 지정합니다.&lt;/p&gt;

&lt;p&gt;헤더 필드의 해석은 동일한 major HTTP 버전과 minor 버전 간에 변경되지 않지만 이러한 필드가 없는 경우 수신자의 기본 동작은 변경될 수 있다. 
별도로 지정하지 않는 한, HTTP/1.1에 정의된 헤더 필드는 모든 버전의 HTTP/1.x에 대해 정의된다. 특히, Host와 Connection 헤더 필드는 
HTTP/1.1 준수 여부에 관계 없이 모든 HTTP/1.x 구현에 의해 구현되어야 한다.&lt;/p&gt;

&lt;p&gt;새로운 헤더 필드는 프로토콜 버전을 변경하지 않고 도입될 수 있다. 새로운 헤더 필드의 정의된 의미론은 그것들을 인식하지 못하는 수신자들에 의해 
새로운 헤더 필드를 안전하게 무시할 수 있게 해 준다.&lt;/p&gt;

&lt;p&gt;HTTP 메시지를 처리하는 중개자(즉, 터널 역할을 하는 중개자를 제외한 모든 중개자)는 전달된 메시지로 자신의 HTTP-version을 전송해야 한다. 
해당 메시지의 프로토콜 버전이 해당 중개자가 메시지 수신 및 전송을 모두 준수하는 버전과 일치하는지 확인하지 않고 
HTTP 메시지의 첫 줄((request-line, response-line)을 맹목적으로 포워딩하는 것이 허용되지 않는다. 
다운스트림 수신인이 메시지 발신인 버전을 사용하여 해당 발신인과의 이후 통신에 사용할 수 있는 기능을 결정할 때 HTTP 버전을 
다시 작성하지 않고 HTTP 메시지를 전달하면 통신 오류가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;클라이언트의 major 버전이 서버가 지원하는 가장 높은 버전보다 높지 않고 클라이언트가 가장 높은 버전을 호환하는 것으로 
알려져 있다면 클라이언트는 가장 높은 버전과 동일한 요청버전을 전송해야 한다. 클라이언트는 적합하지 않은 버전을 보내면 안된다.&lt;/p&gt;

&lt;p&gt;서버가 HTTP 규격을 못 구현한 것으로 알려진 경우, 클라이언트가 적어도 하나의 정상적인 요청을 시도하고 서버가 상위 요청 버전을 못 처리하는 응답 상태 코드 또는 
헤더 필드 (e,g., Server)를 통해 확인한 후에만 클라이언트가 하위 요청 버전을 보낼 수 있다.&lt;/p&gt;

&lt;p&gt;서버는 서버가 구성된 가장 높은 버전과 동일한 응답 버전을 전송해야 하며 major 버전은 요청에 수신된 버전보다 작거나 같아야 한다. 
서버는 호환되지 않는 버전을 보내면 안 된다. 어떤 이유로든 서버는 클라이언트의 주요 프로토콜 버전 서비스를 거부하고자 하는 경우 505(HTTP Version Not Supported)의 응답을 보낼 수 있다.&lt;/p&gt;

&lt;p&gt;클라이언트가 HTTP 사양을 못 구현한 것으로 알려지거나 의심되는 경우 (예 : 클라이언트가 버전 번호를 올바르게 구문 분석하지 못하거나 
중개자가 프로토콜의 minor버전이 주어진 것을 따르지 않을때 HTTP 버전을 맹목적으로 전달하는 것으로 알려진 경우) 서버가 요청에 대해 HTTP/1.0 응답을 보낼 수 있다. 
이러한 프로토콜 다운그레이드는 하나 이상의 요청 헤더 필드(예: User-에이전트)가 오류 발생으로 알려진 클라이언트에서 보낸 값과 고유하게 일치하는 경우와 
같은 특정 클라이언트 특성에 의해 트리거되지 않는 한 수행되지 않아야 한다.&lt;/p&gt;

&lt;p&gt;HTTP의 버전 관리 설계의 목적은 호환되지 않는 메시지 구문이 도입될 때만 큰 숫자가 증가하며, 
프로토콜 변경이 메시지 의미론을 추가하거나 발신자의 추가 기능을 의미할 때만 작은 숫자가 증가한다.&lt;/p&gt;

&lt;p&gt;HTTP 메시지가 수신자가 구현한 major 버전 번호로 수신되지만 수신자가 구현한 버전보다 높은 minor 버전 번호로 수신되면 
수신자는 수신자가 확인할 수 있는 major 버전 내에서 가장 높은 major 버전에 있는 것처럼 메시지를 처리해야 한다.
수신자는 메시지가 해당 상위 버전에 대한 지원을 아직 표시하지 않은 수신자에게 보낼 때 동일한 major 버전의 구현에서 
안전하게 처리할 수 있을 만큼 충분히 역호환 된다고 할 수 있다.&lt;/p&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="http" /><category term="Web" /><category term="HTTP1.1" /><summary type="html">참고 자료 이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본 https://roka88.dev/106 MDN Web Docs https://developer.mozilla.org/ko/docs/Web/HTTP 이외 자료는 내용 중 링크 추가 틀린 내용, 부족한 내용 꼭 지적 부탁드립니다! 1. Introduction HTTP는 정보 시스템을 위한 일반적인 인터페이스 프로토콜이다. HTTP는 제공되는 리소스 유형과 무관한 클라이언트에 균일한 인터페이스를 제공하여 서비스 구현 방법에 대한 세부 정보를 숨기도록 설계되었다. 마찬가지로, 서버는 각 클라이언트의 목적을 인식할 필요가 없다. HTTP 요청은 특정 클라이언트 또는 미리 결정된 어플리케이션 단계 순서와 연결되지 않고 단독으로 고려될 수 있다. 그 결과 많은 다양한 맥락에서 효과적으로 사용될 수 있고 구현이 시간이 지남에 따라 독립적으로 진화할 수 있는 프로토콜이다. HTTP는 비 HTTP 정보 시스템 간에 통신 변환을 위한 중개 프로토콜로써 사용하기 위해 설계되었다. HTTP 프록시 및 게이트웨이는 다양한 프로토콜을 HTTP 서비스와 동일한 방법으로 클라이언트가 보고 조작할 수 있는 하이퍼텍스트 형식으로 변환하여 대체 정보 서비스에 대한 접근을 제공할 수 있다. 이러한 유연성의 결과 중 하나는 프로토콜이 인터페이스 뒤에서 발생하는 것으로 정의될 수 없다는 것이다. 대신, 우리는 수신된 통신, 수신인의 예상된 동작, 통신 구문을 정의하는 것으로 제한된다. 통신이 분리되어 고려되는 경우, 성공적인 행위는 서버가 제공하는 관찰 가능한 인터페이스의 해당 변경사항에 반영되어야 한다. 그러나 여러 클라이언트들가 병렬적으로, 교차 목적으로 작동할 수 있기 때문에, 우리는 단일 응답의 범위를 넘어서는 그러한 변화를 관찰할 수 있도록 요구할 수 없다. 이 문서는 HTTP에서 사용되거나 참조되는 아키텍처 요소를 설명하고, HTTP, HTTPS URI 구문을 정의하며, 전체 네트워크 운영 및 커넥션 관리를 설명하고, HTTP 메시지 프레임 및 전달 요구 사항을 정의한다. 우리의 목표는 메시지 의미론과 독립적인 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 분석기 및 메시지 전달 중개자에 대한 전체 요구 사항을 정의하는 것이다. 무슨 내용인지 아직 이해가 잘 안된다… 읽고나서 이해가 되면 설명을 덧붙이겠다. 2. Architecture HTTP는 World Wide Web (WWW) 이키텍처를 위해 만들어 졌고, 시간이 지남에 따라 월드 와이드 하이퍼 텍스트 시스템의 확장성에 대한 요구들을 지원하기 위해 발전했다. 아키텍처의 대부분이 용어와 HTTP 정의를 위해 사용되는 구문들에 반영되었다. 2.1. Client/Server Messaging HTTP는 신뢰성 있는 전송 계층 또는 세션 계층 “connection”의 메시지 교환에 의해 작동되는 상태 없는 요청/응답 프로토콜이다. HTTP 클라이언트는 하나 이상의 HTTP 요청들을 전송하기 위한 목적으로 커넥션을 서버에 설립하는 프로그램이다. client와 server라는 용어들은 특정 커넥션에 대한 프로그램 수행의 역할만 의미한다. 동일한 프로그램이 일부 커넥션에서는 클라이언트 역할을 하고 다른 커넥션에서는 서버 역할을 할 수 있다. user agent는 브라우저, 스파이터 (웹 기반 로봇), 커맨드 라인 툴, 커스텀 응용 프로그램, 그리고 모바일 앱을 포함해서 요청을 시작하는 다양한 클라이언트 프로그램을 말한다. origin server는 특정 대상 리소스에 대한 권한 있는 응답을 생성할 수 있는 프로그램이다. sender(발신자)와 recipient(수신자)는 주어진 메시지를 전송하고 수신하도록 구현된 모든것들을 의미한다. HTTP는 대상 리소스와 리소스들간의 관계를 나타내기 위해서 URI 표준에 의존한다. 인터넷 메일과 Multipurpose Internet Mail Extensions(MIME)에 의해 사용된 유사한 포멧으로 메시지는 전송된다. 대부분의 HTTP 통신은 URI로 식별된 일부 리소스의 representation을 위한 GET(검색 요청)로 구성된다. 가장 간단한 경우로 사용자 에이전트와 오리진 서버 사이의 단일 양방향 커넥션을 통해 이 작업을 수행할 수 있다. request &amp;gt; User Agent ==================== Origin Server &amp;lt; response 클라이언트 HTTP 요청을 서버에 요청 메시지 형식, method, URI와 프로토콜 버전을 포함한 request-line을 시작으로, 요청 수정자, 클라이언트 정보, 표현 메타 데이터를 포함하는 헤더 필드와 헤더 영역의 끝을 알리는 빈줄 이후, 마지막으로 페이로드 본문을 포함하는 메시지 본문을 보낸다. 서버는 클라이언트의 요청에 하나 또는 다수의 HTTP 응답 메시지를 각각의 프로토콜 버전, 성공 또는 에러 코드, 원문으로 된 상태 코드를 포함한 status-line을 시작으로, 가능하다면 서버 정보, 리소스 메타 데이터와 representation 메타 데이터를 포함하는 헤더 필드를 헤더 부분의 끝을 나타내는 빈줄과 함께 포함하고, 마지막으로 페이로드 body를 포함한 메시지 본문으로 응답을 한다. 아래의 예시는 GET 요청을 위한 일반적인 메시지 교환을 나타낸다. &quot;http://www.example.com/hello.txt&quot; Client GET /hello.txt HTTP/1.1 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.71 zlib/1.2.3 Host: www.example.com Accept-Lanuage: en, mi Server : HTTP/1.1 200 OK Date: Mon, 27 Jul 2009 12:28:53 GMT Server: Apache Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT ETag: &quot;34aa387-d-1568eb00&quot; Accept-Ranges: bytes Content-Length: 51 Vary: Accept-Encoding Content-Type: text/plain Hello World! My payload includes a trailing CRLF. 2.2. Implementation Diversity (구현 다양성) HTTP 설계를 고려할 때, 모든 사용자 에이전트들이 범용 브라우저들이고 모든 오리진 서버들이 큰 규모의 공용 웹사이트라는 생각의 함정에 빠지는 것이 쉽다. 이것은 잘못된 생각이다. 보통의 HTTP 사용자 에이전트는 가정 어플리케이션, 음향기기, 체중계, 스크립트를 갱신하는 firmware, command-line 프로그램, 모바일 앱, 그리고 다양한 모양과 크기의 통신 기기를 포함한다. 마찬가지로, 보통의 HTTP 오리진 서버는 홈 자동화 장치, 네트워킹을 구성하는 부품, 사무용 기계, 자율 로봇, 뉴스 피드, 트래픽 카메라, 광고 선택자, 그리고 비디오-배송 플랫폼을 포함한다. User Agent는 요청시 소프트웨어 에이전트와 직접적으로 상호작용하는 사용자가 있음을 의미하지 않는다. 대부분의 경우, 사용자 에이전트가 설치되거나 구성되어 백그라운드에서 실행되고 나중에 검사할 수 있도록 결과를 저장한다. (관심있 있거나 문제를 일으키는 결과 중 일부만 저장). 예시로 스파이더는 일반적으로 시작 URI가 주어지고, 웹을 하이퍼텍스트 그래프로 크롤링하는 동안 특정 행동을 따르도록 구성되었다. HTTP의 구현 다양성은 모든 사용자 에이전트가 사용자에게 대화형 제안을 하거나 보안 또는 개인정보 보호 문제에 대한 적절한 경고를 제공할 수 없음을 의미한다. 이 규격에서 사용자에게 오류를 보고해야 하는 몇 가지 경우에는 오류 콘솔이나 로그파일에서만 이러한 보고를 관찰할 수 있다. 마찬가지로 사용자가 계속하기 전에 자동작업을 확인해야 하는 요구 사항은 사전 구성 선택, 런타입 옵션 또는 단순한 안전하지 않은 작업 회피로 충족될 수 있다. 확인은 사용자가 이미 선택한 경우 특정 사용자 인터페이스 또는 정상 처리 중단을 의미하지 않는다. 2.3. Intermediaries (중개인) HTTP를 사용하면 커넥션 체인을 통해 요청을 충족할 수 있다. HTTP 중개자로 세가지 일반적인 형식이 있따. 프록시, 게이트웨이, 터널. 경우에 따라 단일 중개자가 오리진 서버, 프록시, 게이트웨이 또는 터널역할을 하여 각 요청의 특성에 따라 동작을 전환 할 수 있다. &amp;gt; &amp;gt; &amp;gt; &amp;gt; UA ==== A ==== B ==== C ==== O &amp;lt; &amp;lt; &amp;lt; &amp;lt; 위 그림은 사용자 에이전트와 오리진 서버 사이에 3개의 중개자 (A, B와 C)를 보여준다. 전체 체인을 이동하는 요청 또는 응답 메시지는 4개의 분리된 커넥션을 통해 전송된다. 일부 HTTP 통신 옵션들은 가장 가까운 터널이 아닌 인접 네트워크와의 커넥션에만 적용되거나 체인의 끝점에만 적용되거나 체인을 따라 있는 모든 커넥션에 적용될 수 있다. 다이어그램은 선형이지만, 각 참여자는 여러개의 동시 통신에 참여할 수 있다. 예를 들어 B는 A외에 여러 클라이언트로부터 요청을 받을 수 있거나 또는 같은 시간에 A의 요청을 다루면서 C이외에 서버로 요청을 전송할 수 있다. 마찬가지로 나중의 요청들은 로드 밸런싱을 통한 동적인 구성에 기반하여 커넥션의 다른 경로를 통해 전송될 것이다. Upstream과 Downstream은 메시지 흐름의 관계에서 방향 요구사항들을 설명하기 위해 사용된다. 모든 메시지들은 Upstream으로 부터 Downstream으로 흐른다. Inbound와 Outbound는 요청 라우트의 관계에서 방향 요구사항들을 설명하기 위해 사용된다. Inbound는 오리진 서버로 향하는 것을 의미하고, Outbound는 사용자 에이전트로 향하는 것을 의미한다. Proxy는 클라이언트가 일반적으로 로컬 구성 규칙들을 통해 선택한 메시지-전송 에이전트로, 일부 유형의 absolute URI에 대한 요청을 수신하고 HTTP 인터페이스를 통한 변환을 통해 해당 요청을 충족시키려고 시도한다. HTTP URI에 대한 프록시 요청과 같이 일부 번역은 최소 수준이지만 다른 요청은 완전히 다른 애플리케이션 레벨 프로토콜 간에 변환이 필요할 수 있다. 프록시들은 종종 보안적 이익, 주석 서비스, 또는 공유 캐시를 위한 공통 중개자로 조직의 HTTP 요청들을 그룹화 하는데 자주 사용된다. 일부 프록시들은 선택된 메시지 또는 페이로드가 전송되는 동안 변환을 적용하기 위해 설계 되었다. 추가적인 설명으로 인터넷의 다른 네트워크를 탐색 할 때 프록시 서버와 HTTP 터널은 WWW의 컨텐츠에 대한 엑세스를 용이하게 한다. 프록시는 사용자의 로컬 컴퓨터에 있거나 사용자의 컴퓨터와 인터넷의 대상 서버 사이에 있을 수 있다. 프록시는 포워드 프록시(터널, 게이트웨이)와 리버스 프록시(로드 밸런싱, 인증, 복호화, 캐싱을 위해 서버에 대한 엑세스를 제어하고 보호하는데 사용)의 두가지 유형이 있다. 포워드 프록시 정방향 프록시, 게이트웨이 또는 프록시는 클라이언트 또는 클라이언트 그룹에 프록시 서비스를 제공한다. 인터넷에는 수십만 개의 오픈 포워드 프록시가 있다. 그룹에서 사용하는 대역폭을 줄이고 제어하기 위해 DNS 또는 웹 페이지와 같은 인터넷 서비스를 저장하고 전달한다. 전달 프록시는 익명 프록시 일 수도 있으며 사용자가 웹을 검색하거나 다른 인터넷 서비스를 사용하는 동안 IP 주소를 숨길 수 있다. The Onion Router는 익명 성을 위해 여러 프록시를 통해 인터넷 트래픽을 라우팅한다. 리버스 프록시 이름에서 알 수 있듯이 리버스 프록시는 포워드 프록시가 수행하는 작업과 반대로 수행한다. 포워드 프록시는 클라이언트(또는 요청 호스트)를 대신하여 작동한다. 포워드 프록시는 클라이언트 ID를 숨길 수 있는 반면 리버스 프록시는 서버의 ID를 숨길 수 있다. 리버스 프록시는 사용 사례는 아래와 같다. 로드 밸런싱 : 로드를 여러 웹 서버에 분산 정적 컨텐츠 캐시 : 사진과 같은 정적 컨텐츠를 캐싱하여 웹 서버를 오프로드 한다. 압축 : 컨텐츠를 압축하고 최적화하여 로드 시간을 단축한다. Gateway는 (reverse proxy) 아웃바운드 커넥션을 위한 오리진 서버로써 역할을 하지만, 수신된 요청을 다른 서버로 변환하여 인바운드로 전송하는 중간 서버 역할을 한다. 게이트웨이는 오래된 또는 신뢰 할 수 없는 정보 서비스들을 캡슐화 하는데 사용 되며, 서버의 성능을 향상 시키기 위해 accelerator 캐싱, 그리고 파티셔닝 또는 여러 시스템 간의 HTTP 서비스의 로드 밸런싱을 할 수 있게 사용된다. 오리진 서버에 적당한 모든 HTTP 요구사항은 게이트웨이의 아웃바운드 통신에도 적용된다. 게이트웨이는 private extensions(개인적으로 프로토콜을 확장한 것들)을 이 명세의 범위 밖의 HTTP에 포함하여 원하는 프로토콜을 사용하여 인바운드 서버와 통신한다. 그러나 서드파티 HTTP 서버들과 상호작용하는 HTTP-to-HTTP 게이트 웨이는 게이트웨이의 인바운드 커넥션에 대한 사용자 에이전트의 요구사항에 준수해야 한다. Tunnel은 메시지 변경없이 2개의 커넥션에 숨겨진 중개자로써 역할을 한다. 터널이 활성되면, HTTP 요청에 의해 시작되었을 수 있지만, 터널은 HTTP 통신의 당사자로 고려되지 않는다. 두 끝점에서 전달하는 커넥션이 종료되면 터널은 더 이상 존재하지 않는다. 공유 방화벽 프록시를 통해 기밀 통신을 설정하는데 전송층 보안(TLS)이 사용되는 경우와 같이 중계를 통해 가상 커넥션을 확장하는데 터널이 사용된다. 중개자를 위한 범주는 HTTP 통신의 참가자로써 역할만 고려됐다. 또한 네트워크 프로토콜 스택의 하위 계층에서 행동하여 메시지 보낸 사람의 확인이나 허가 없이 HTTP 트래픽을 필터링하거나 리다이렉트 할 수 있는 중개자도 있다. 네트워크 중개자들은 중간자 공격(프로토콜 단계에서)을 구분할 수 없으며, 실수로 HTTP 의미론을 위반하여 보안 결함 또는 상호 운용성 문제를 야기하는 경우가 많다. 예를 들어, interception proxy(transparent proxy로 알려진)는 클라이언트에 의해서 선택되지 않았기 때문에 HTTP 프록시와 다르다. 대신에, interception proxy는 외부의 TCP 포트 80 패킷 (그리고 가끔 다른 일반적인 포트 트래픽)을 거르거나 또는 리다이렉트 한다. interception proxy는 일반적으로 로컬이 아닌 인터넷 서비스 사용을 허용하기 전에 계정 가입을 적용하는 수단으로 공용 네트워크 엑세스 지점에서, 네트워크 사용정책을 시행하기 위해 회사 방화벽 내에서 발견 된다. HTTP는 상태 없는 프로토콜로 정의되었고, 각 요청 메시지는 개별적으로 이해될 수 있다는것을 의미한다. 대부분의 구현은 프록시된 커넥션을 재사용하거나 또는 여러 서버간에 동적으로 로드 밸런스 요청을 하기 위해 HTTP의 상태 없는 설계에 의존한다. 따라서 서버는 커넥션이 보안되어 있고 해당 에이전트에 특정되어 있지 않는한 동일한 커넥션에 대한 두개의 요청이 동일한 사용자 에이전트에서 온 것으로 가정해서는 안 된다. 일부 비표준 HTTP 확장들은 이 요구사항을 위반하고, 보안 및 상호작용 문제를 발생시킨다. 2.4. Caches Cache는 이전 응답 메시지의 로컬 보관소이고 메시지의 저장, 검색, 삭제를 관리하는 서브 시스템이다. 캐시는 캐시 가능한 응답을 저장하여 향후 동일한 요청에 대한 응답 시간과 네트워크 대역폭 사용을 줄인다. 캐시는 서버가 터널 역할을 하는 동안에는 사용될 수 없지만, 어느 클라이언트 또는 서버는 캐시를 사용할 수 있다. 캐시의 효과는 체인의 참여자 중 하나가 해당 요청에 적용할 수 있는 캐시된 응답을 가지고 있는 경우 요청/응답 체인이 단축 되는 것이다. 다음은 B가 UA 또는 A에 의해 캐시되지 않은 요청에 대한 O(경유 C)의 이전 응답의 캐시된 사본을 가지고 있는 경우의 결과 체인을 보여준다. &amp;gt; &amp;gt; UA ==== A ==== B ---- C ---- O &amp;lt; &amp;lt; 캐시가 후속 요청에 응답하기 위해 응답 메시지의 복사본을 저장할 수 있는 경우 응답은 “cacheable”이다. 응답을 캐시할 수 있는 경우에도 캐시된 응답을 특정 요청에 사용할 수 있는 경우 클라이언트 또는 원서버에 의해 추가 제약이 있을 수 있다. 월드 와이드 웹과 대규모 조직에 걸쳐 배치된 캐시의 설계와 구성은 매우 다양하다. 대양을 횡단하는 대역폭을 아끼기 위한 프록시 캐시의 국가 계층 구조, 브로드 캐스트 또는 멀티 캐스트 캐시 엔트리를 위한 협업 시스템, 오프라인 또는 high-latency 환경들에서 사용하기 위한 pre-fetched 캐시 엔트리의 아카이브 등이 포함된다. 2.5. Conformance and Error Handling 이 명세는 HTTP 통신의 참여자의 규칙에 따라 적합성 기준을 대상으로 한다. 따라서 HTTP 요구사항은 어떤 행동이 요구사항에 의해 제한되고 있는지에 따라서 발신자, 수신자, 클라이언트, 서버, 사용자 에이전트, 중개자, 원서버, 프록시, 게이트웨이, 또는 캐시가 배치되어 있다. 구현, 리소스 소유자 및 프로토콜 요소 등록이 단일 통신 범위를 벗어나 적용되는 경우 추가 (관행적) 요구 사항이 적용된다. 동사 Generate는 프로토콜 요소를 생성하는 것과 단지 수신된 요소를 다운스트림에서 전달하는 것 사이에서 요구사항이 구별되는 Send 대신 사용 된다. 구현은 HTTP에 맞는 규칙들과 관련된 모든 요구사항들을 따른다면, 적합한 것으로 간주 된다. 적합성은 구문과 프로토콜 요소의 의미론을 둘 다 포함한다. 발신자는 발신자가 거짓이라는 알려진 의미를 전달하는 프로토콜 요소를 생성하면 안 된다. 발신자는 ABNF 규칙에 대응하는 정의된 문법에 맞지 않는 프로토콜 요소를 생성하면 안 된다. 지정된 메시지 내에서, 발신자는 다른 역할(i.e., 해당 메시지에 발신자에게 없는 역할)의 참가자만 생성할 수 있는 프로토콜 요소나 구문 대안을 생성하면 안 된다. 수신된 프로토콜 요소가 분석되었을 때, 수신자는 수신자의 역할에 해당하는 적정한 길이의 값과 분석할 수 있어야 하며 ABNF 규칙들에 대응하는 정의된 문법에 일치해야 한다. 참고로, 일부 수신된 요소들은 분석 되지 않을 수 있다. 예를 들어 메시지를 전송하는 중개자는 일반 Field-name과 Field-value 성분들의 header-field를 분석할 수 있고, field-value의 추가적인 분석 없이 헤더 필드를 전송하는 것도 있다. HTTP 구현의 문맥 배치와 목적에 따라 적절한 길이가 매우 다양하기 때문에 대부분의 프로토콜 요소에 대해 특정한 길이 제한을 가지고 있지 않는다. 따라서, 발신자와 수신자 사이의 상호작용은 각 프로토콜 요소를 위한 적정한 길이가 무엇인지에 관한 공유된 예상에 의존한다. 게다가 일부 프로토콜 요소에 대해 일반적으로 적절한 길이로 이해되는 것은 지난 20년 동안 HTTP 사용과정에서 바뀌었으며 앞으로도 계속 변화할것이다. 최소한, 수신자는 다른 메시지의 동일한 프로토콜 요소에 대해 생성한 값만큼 프로토콜 요소 길이를 구문 분석하고 처리할 수 있어야 한다. 예를 들어 자체 리소스에 매우 긴 URI 참조를 게시하는 오리진 서버는 요청 대상으로 수신될 때 동일한 참조를 구문 분석하고 처리할 수 있어야 한다. 수신자는 수신자가 해당 의미론에 의해 암시된 것을 잘못 구현한다고 (경험이나 구성을 통해) 판단하지 않는 한, 수신자는 이 명세에 정의된 의미론에 따라 수신된 프로토콜 요소를 해석해야 한다. 예를 들어 User-Agent 헤더 필드 검사에서 특정 콘텐츠 코딩을 수신할 때 실패한 것으로 알려진 특정 구현 버전을 나타내는 경우 오리진 서버는 수신된 Accept-Encoding 헤더 필드의 내용을 무시할 수 있다. 달리 명시되지 않은 한, 수신자는 잘못된 구조에서 사용 가능한 프로토콜 요소를 복구하려고 시도할 수 있다. HTTP는 보안에 직접적인 영향을 미치는 경우를 제외하고 특정 오류 처리 메커니즘을 정의하지 않는데, 프로토콜의 서로 다른 응용 프로그램에는 다른 오류 처리 전략이 필요하기 때문이다. 예를 들어 웹브라우전느 Location 헤더 필드가 ABNF에 따라 구문 분석되지 않는 응답에서 투명하게 복구하기를 원하는 반면, 시스템 제어 클라이언트는 어떤 형태의 오류 복구도 위험하다고 간주할 수 있다. 2.6. Protocol Versioning HTTP는 “.&quot;를 프로토콜의 버전의 번호를 표시하기 위해 사용한다. 이 규격은 버전 1.1을 정의한다. 프로토콜 버전 전체는 발신자가 해당 버전의 HTTP 사양에 명시된 요건 집합을 준수하고 있음을 나타낸다. HTTP 메시지 버전은 메시지의 첫번째 행에 HTTP-version 필드로 표시된다. HTTP-version은 대 소문자를 구분한다. HTTP-Version = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT HTTP-name = %x48.54.54.50 ; &quot;HTTP&quot;, case-sensitive HTTP 버전 번호는 “.”로 구분된 두개의 10진수로 구성된다. 첫번째 숫자 (major)는 HTTP 메시징 구문을 나타내고, 두번째 숫자(minor)는 발신자에 적합하고 이후 통신을 이해할 수 있는 해당 major버전 내에서 가장 높은 minor 버전을 나타낸다. minor 버전은 발신자가 역으로 호환되는 프로토콜의 하위 집합만 사용하는 경우에도 발신자의 통신 기능을 알리므로 수신자는 더 많은 고급 기능을 응답 또는 향후 요청에 사용할 수 있음을 알수 있다. HTTP/1.1 메시지가 HTTP/1.0 수신자 또는 버전을 알 수 없는 수신자에게 전송 될때, HTTP/1.1 메시지는 새로운 기능이 모두 무시될 경우 유효한 HTTP/1.0 메시지로 해석될 수 있도록 구성된다. 이 규격은 수신자가 HTTP/1.1을 지원하는 구성 또는 메시지 수신을 결정할 때까지 호환 가능한 기능만 사용하도록 일부 새 기능에 대한 recipient-version 요구 사항을 지정합니다. 헤더 필드의 해석은 동일한 major HTTP 버전과 minor 버전 간에 변경되지 않지만 이러한 필드가 없는 경우 수신자의 기본 동작은 변경될 수 있다. 별도로 지정하지 않는 한, HTTP/1.1에 정의된 헤더 필드는 모든 버전의 HTTP/1.x에 대해 정의된다. 특히, Host와 Connection 헤더 필드는 HTTP/1.1 준수 여부에 관계 없이 모든 HTTP/1.x 구현에 의해 구현되어야 한다. 새로운 헤더 필드는 프로토콜 버전을 변경하지 않고 도입될 수 있다. 새로운 헤더 필드의 정의된 의미론은 그것들을 인식하지 못하는 수신자들에 의해 새로운 헤더 필드를 안전하게 무시할 수 있게 해 준다. HTTP 메시지를 처리하는 중개자(즉, 터널 역할을 하는 중개자를 제외한 모든 중개자)는 전달된 메시지로 자신의 HTTP-version을 전송해야 한다. 해당 메시지의 프로토콜 버전이 해당 중개자가 메시지 수신 및 전송을 모두 준수하는 버전과 일치하는지 확인하지 않고 HTTP 메시지의 첫 줄((request-line, response-line)을 맹목적으로 포워딩하는 것이 허용되지 않는다. 다운스트림 수신인이 메시지 발신인 버전을 사용하여 해당 발신인과의 이후 통신에 사용할 수 있는 기능을 결정할 때 HTTP 버전을 다시 작성하지 않고 HTTP 메시지를 전달하면 통신 오류가 발생할 수 있다. 클라이언트의 major 버전이 서버가 지원하는 가장 높은 버전보다 높지 않고 클라이언트가 가장 높은 버전을 호환하는 것으로 알려져 있다면 클라이언트는 가장 높은 버전과 동일한 요청버전을 전송해야 한다. 클라이언트는 적합하지 않은 버전을 보내면 안된다. 서버가 HTTP 규격을 못 구현한 것으로 알려진 경우, 클라이언트가 적어도 하나의 정상적인 요청을 시도하고 서버가 상위 요청 버전을 못 처리하는 응답 상태 코드 또는 헤더 필드 (e,g., Server)를 통해 확인한 후에만 클라이언트가 하위 요청 버전을 보낼 수 있다. 서버는 서버가 구성된 가장 높은 버전과 동일한 응답 버전을 전송해야 하며 major 버전은 요청에 수신된 버전보다 작거나 같아야 한다. 서버는 호환되지 않는 버전을 보내면 안 된다. 어떤 이유로든 서버는 클라이언트의 주요 프로토콜 버전 서비스를 거부하고자 하는 경우 505(HTTP Version Not Supported)의 응답을 보낼 수 있다. 클라이언트가 HTTP 사양을 못 구현한 것으로 알려지거나 의심되는 경우 (예 : 클라이언트가 버전 번호를 올바르게 구문 분석하지 못하거나 중개자가 프로토콜의 minor버전이 주어진 것을 따르지 않을때 HTTP 버전을 맹목적으로 전달하는 것으로 알려진 경우) 서버가 요청에 대해 HTTP/1.0 응답을 보낼 수 있다. 이러한 프로토콜 다운그레이드는 하나 이상의 요청 헤더 필드(예: User-에이전트)가 오류 발생으로 알려진 클라이언트에서 보낸 값과 고유하게 일치하는 경우와 같은 특정 클라이언트 특성에 의해 트리거되지 않는 한 수행되지 않아야 한다. HTTP의 버전 관리 설계의 목적은 호환되지 않는 메시지 구문이 도입될 때만 큰 숫자가 증가하며, 프로토콜 변경이 메시지 의미론을 추가하거나 발신자의 추가 기능을 의미할 때만 작은 숫자가 증가한다. HTTP 메시지가 수신자가 구현한 major 버전 번호로 수신되지만 수신자가 구현한 버전보다 높은 minor 버전 번호로 수신되면 수신자는 수신자가 확인할 수 있는 major 버전 내에서 가장 높은 major 버전에 있는 것처럼 메시지를 처리해야 한다. 수신자는 메시지가 해당 상위 버전에 대한 지원을 아직 표시하지 않은 수신자에게 보낼 때 동일한 major 버전의 구현에서 안전하게 처리할 수 있을 만큼 충분히 역호환 된다고 할 수 있다.</summary></entry><entry><title type="html">HTTP 1.1 Reference - Semantics and Content (5) (최종 수정 날짜 : 2021-02-25)</title><link href="https://lcy960729.github.io/http/2021/02/24/HTTP1-1-Semantics-And-Content(5).html" rel="alternate" type="text/html" title="HTTP 1.1 Reference - Semantics and Content (5) (최종 수정 날짜 : 2021-02-25)" /><published>2021-02-24T00:00:00+09:00</published><updated>2021-02-24T00:00:00+09:00</updated><id>https://lcy960729.github.io/http/2021/02/24/HTTP1-1-Semantics-And-Content(5)</id><content type="html" xml:base="https://lcy960729.github.io/http/2021/02/24/HTTP1-1-Semantics-And-Content(5).html">&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본&lt;br /&gt;
&lt;a href=&quot;https://roka88.dev/106&quot;&gt;https://roka88.dev/106&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MDN Web Docs&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP&quot;&gt;https://developer.mozilla.org/ko/docs/Web/HTTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외 자료는 내용 중 링크 추가&lt;/p&gt;
&lt;h5 id=&quot;틀린-내용-부족한-내용-꼭-지적-부탁드립니다&quot;&gt;틀린 내용, 부족한 내용 꼭 지적 부탁드립니다!&lt;/h5&gt;

&lt;h1 id=&quot;7-response-header-fields&quot;&gt;7. Response Header Fields&lt;/h1&gt;
&lt;p&gt;응답 헤더 필드는 서버가 status-line에 배치된 정보를 넘어 응답에 대한 추가 정보를 전달할 수 있도록 한다. 
이러한 헤더 필드는 서버에 대한 정보, 대상 리소스에 대한 추가 액세스 또는 관련 리소스에 대한 정보를 제공한다.&lt;/p&gt;

&lt;p&gt;각 응답 헤더 필드에는 정의된 의미가 있지만, 일반적으로 정확한 의미론은 요청 메서드 및/또는 응답 상태 코드의 의미에 의해 더욱 세분화될 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;71-control-data&quot;&gt;7.1. Control Data&lt;/h2&gt;
&lt;p&gt;응답 헤더 필드는 상태 코드를 보충하거나 캐시를 지시하거나 클라이언트에게 다음은 어디로 가야 하는지 지시하는 제어 데이터를 제공할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Age&lt;/li&gt;
  &lt;li&gt;Cache-Control&lt;/li&gt;
  &lt;li&gt;Expires&lt;/li&gt;
  &lt;li&gt;Date&lt;/li&gt;
  &lt;li&gt;Location&lt;/li&gt;
  &lt;li&gt;Retry-After&lt;/li&gt;
  &lt;li&gt;Vary&lt;/li&gt;
  &lt;li&gt;Warning&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;711-origination-date&quot;&gt;7.1.1 Origination Date&lt;/h3&gt;
&lt;h4 id=&quot;7111-datatime-formats&quot;&gt;7.1.1.1. Data/Time Formats&lt;/h4&gt;
&lt;p&gt;1995년 이전에는 서버가 타임스탬프를 통신하기 위해 일반적으로 사용하는 세 가지 다른 형식이 있었다. 
기존 구현과의 호환성을 위해 세 가지 모두 여기에 정의되어 있따. 선호하는 형식은 인터넷 메시지 형식에서 
사용하는 날짜 및 시간 규격의 fixed-length 및 single-zone 부분 집합이다.&lt;/p&gt;

&lt;p&gt;HTTP-date = IMF-fixdate /obs-date
선호하는 형식의 예는&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sun, 06 Nov 1994 08:49:38 GMT; IMF-fixdate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용되지 않는 두형식의 예는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sunday, 06-Nov-94 08:49:38 GMT; obsolete format
Sun Nov 6 08:49:38 1994; ANSI C`s asctime() format
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HTTP 헤더 필드에서 타임스탬프 값을 구문 분석하는 수신자는 세 가지 HTTP-date 형식을 모두 수용해야 한다.
발신자가 HTTP-date로 정의된 하나 이상의 타임스탬프를 포함하는 헤더 필드를 생성할 때, 발신자는 반드시 IMF-fixdate 형식으로 타임스탬프를 생성해야 한다.&lt;/p&gt;

&lt;p&gt;HTTP 날짜 값은 UTC(Coordinated Universal Time)의 인스턴스로서의 시간을 나타낸다. 처음 두 형식은 UTC 이름의 이전 버진인 
“GMT”의 3글자 약어로 UTC를 나타내며, asctime 형식의 값은 UTC로 가장헌다. 로컬 클럭에서 HTTP 날짜 값을 생성하는 발신자는 시계를 
UTC에 동기화하기 위해 NTP 또는 이와 유사한 프로토콜을 사용해야 한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IMF-fixdate = day-name &quot;,&quot; SP date 1 SP time-of-day SP GMT
            ;fixed length/zone/capitalization subset of the format
day-name = %x4D.6F.6E; :&quot;Mon&quot;, case-sensitive
         / %x54.75.65; :&quot;Tue&quot;, case-sensitive
         / %x57.65.64 ; &quot;Wed&quot;, case-sensitive
         / %x54.68.75 ; &quot;Thu&quot;, case-sensitive
         / %x46.72.69 ; &quot;Fri&quot;, case-sensitive
         / %x53.61.74 ; &quot;Sat&quot;, case-sensitive
         / %x53.75.6E ; &quot;Sun&quot;, case-sensitive

date 1 = day SP month SP year
        ;e.g.,02 Jun 1982

day = 2DIGIT
month = %x4A.61.6E ; &quot;Jan&quot;, case-sensitive
      / %x46.65.62 ; &quot;Feb&quot;, case-sensitive 
      / %x4D.61.72 ; &quot;Mar&quot;, case-sensitive 
      / %x41.70.72 ; &quot;Apr&quot;, case-sensitive 
      / %x4D.61.79 ; &quot;May&quot;, case-sensitive 
      / %x4A.75.6E ; &quot;Jun&quot;, case-sensitive 
      / %x4A.75.6C ; &quot;Jul&quot;, case-sensitive
      / %x41.75.67 ; &quot;Aug&quot;, case-sensitive 
      / %x53.65.70 ; &quot;Sep&quot;, case-sensitive 
      / %x4F.63.74 ; &quot;Oct&quot;, case-sensitive 
      / %x4E.6F.76 ; &quot;Nov&quot;, case-sensitive 
      / %x44.65.63 ; &quot;Dec&quot;, case-sensitive

year = 4DIGIT

GMT = %x47.4D.54 ; &quot;GMT&quot;, case-sensitive

time-of-day = hour &quot;:&quot; minute &quot;:&quot; second
              ; 00:00:00 - 23:59:60 (leap second)
hour = 2DIGIT 
minute = 2DIGIT 
second = 2DIGIT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;쇠퇴한 형식(참고만 하자)&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;obs-date = rfc850-date / asctime-date

rfc850-date = day-name-l &quot;,&quot; SP date2 SP time-of-day SP GMT 
date2 = day &quot;-&quot; month &quot;-&quot; 2DIGIT
      ; e.g., 02-Jun-82

day-name-l = %x4D.6F.6E.64.61.79 ; &quot;Monday&quot;, case-sensitive
           / %x54.75.65.73.64.61.79 ; &quot;Tuesday&quot;, case-sensitive
           / %x57.65.64.6E.65.73.64.61.79 ; &quot;Wednesday&quot;, case-sensitive 
           / %x54.68.75.72.73.64.61.79 ; &quot;Thursday&quot;, case-sensitive
           / %x46.72.69.64.61.79 ; &quot;Friday&quot;, case-sensitive
           / %x53.61.74.75.72.64.61.79 ; &quot;Saturday&quot;, case-sensitive
           / %x53.75.6E.64.61.79 ; &quot;Sunday&quot;, case-sensitive
asctime-date = day-name SP date3 SP time-of-day SP year 
date3 = month SP ( 2DIGIT / ( SP 1DIGIT ))
      ; e.g., Jun 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HTTP-date는 대소문자를 구분한다. 발신자는 문법에 SP로 구체적으로 포함된 공간을 초과하여 HTTP-date에 추가 공백을 생성해서는 안 된다.
day-name, day, month, year 및 time-of-day의 의미는 해당 이름과 Internet Message Format 구성에 대해 정의된 것과 동일 하다.&lt;/p&gt;

&lt;p&gt;두 자릿수를 사용하는 rfc850-date 형식의 타임스탬프 값을 받는 사람은 2-digit가 가장 최근 연도를 나타내는 것으로 해석해야 한다.&lt;/p&gt;

&lt;p&gt;타임스탬프 값의 수신자는 필드 정의에 의해 달리 제한되지 않는 한 타임스탬프를 구문 분석할 때 견고한 것을 권장한다. 
예를 들어, Internet Message Format에 의해 정의된 날짜 및 시간 사양을 생성할 수 있는 비 HTTP 소스에서 메시지를 HTTP를 통해 전달하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;참고 : date/time 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내의 사용에만 적용된다. 사용자 프레젠테이션, 요청 기록 등에 이러한 형식을 사용할 필요는 없다.&lt;/p&gt;

&lt;h4 id=&quot;7112-date&quot;&gt;7.1.1.2. Date&lt;/h4&gt;
&lt;p&gt;“Date” 헤더 필드는 Origination Date Field와 동일한 의미를 가지며 메시지가 발생한 날짜와 시간을 나타낸다. 
필드 값은 HTTP-date이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Date = HTTP-date

예를 들어
Date: Tue, 15 Nov 1994 08:12:31 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Date 헤더 필드가 생성될 떄, 발신자는 메시지 생성 날짜와 시간에 대한 가장 근사치로서 필드 값을 생성해야 한다. 
이론적으로, 날짜는 페이로드가 생성되기 바로 전의 순간을 나타내야 한다. 실제로 그 날짜는 메시지 작성 중에 언제라도 생성될 수 있다.&lt;/p&gt;

&lt;p&gt;원서버는 UTC에서 현재 인스턴스의 합당한 근사치를 에제공할 수 있는 시계가 없는 경우 Date 헤더 필드를 보내서는 안 된다. 
응답이 상태 코드의 1xx(Informational) 또는 5xx(Server Error) 등급인 경우 원 서버는 Date 헤더 필드는 보낼 수 있다.
원서버는 다른 모든 경우 Date 헤더 필드를 전송해야 한다.&lt;/p&gt;

&lt;p&gt;Date 헤더 필드 없이 응답 메시지를 수신하는 시계가 있는 수신자는 수신된 시간을 기록하고 해당 Date 헤더 필드가 캐시 되거나 
다운스트림에서 전달되는 경우 메시지의 헤더 부문에 해당 Date 헤더 필드를 추가해야 한다.&lt;/p&gt;

&lt;p&gt;사용자 에이전트는 요청으로 Date 헤더 필드를 보낼 수 있지만, 서버에 유용한 정보를 전달하는 것으로 간주되지 않는 한 일반적으로 그렇게 하지 않는다. 
예를 들어, HTTP의 사용자 정의 어플리케이션은 서버가 사용자 에이전트와 서버 시계 간의 차이를 기반으로 사용자 요청에 대한 해석을 조정할 것으로 기대되는 경우 Date를 전달할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;712-location&quot;&gt;7.1.2. Location&lt;/h3&gt;
&lt;p&gt;“Location” 헤더 필드는 응답과 관련된 특정 리소스를 참조하기 위해 일부 응답에 사용된다. 
관계의 유형은 요청 메서드와 상태 코드 의미론의 조합에 의해 정의 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Location = URI-reference
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;필드 값은 단일 URI-reference로 구성된다. 상대적 참조의 형태를 가지고 있을 때 유효한 요청 URI의 값을 가진다.&lt;/p&gt;

&lt;p&gt;201(Created) 응답의 경우, Location 값은 요청에 의해 생성된 기본 리소스를 말한다. 
3xx (Redirection) 응답의 경우, Location 값은 요청을 자동으로 리디렉션하기 위한 기본 대상 리소스를 가르킨다.&lt;/p&gt;

&lt;p&gt;3xx (Redirection) 응답에 제공된 Location 값에 Fragment(#)가 없는 경우, 사용자 에이전트는 그 값이 요청 대상을 생성하는 데 
사용된 URI 참조의 Fragment(#) (즉, 리디렉션은 원래 참조의 파편을 상속하는 경우)를 상속하는 것처럼 리디렉션을 처리해야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어 URI 참조 “http://www.example.org/~tim”에 대해 생성된 GET 요청은 헤더 필드를 포함하는 303(See Other) 응답을 받을 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Location: /People.html#tim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;사용자 에이전트가 “http://www.example.org/People.html#tim”으로 리디렉션됨을 암시한다.&lt;/p&gt;

&lt;p&gt;마찬가지로, URI 참조 “http://www.example.org/index.html#larry”에 대해 생성된 GET 요청은 
다음과 같은 헤더 필드를 포함하는 301 (Moved Permanently) 응답을 초래할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Location: http://www.example.net/index.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이는 사용자가 에이전트가 Fragment(#)를 보존하면서 “http://www.eample.net/index.html#larry”으로 리디렉션을 제안한다.&lt;/p&gt;

&lt;p&gt;Location 값의 Fragment(#)가 적절하지 않은 상황이 있다. 예를 들어 201(Created) 응답의 Location 헤더 필드는 생성된 리소스와 관련된 URI를 제공하도록 되어 있다. 
참고: 일부 수신자는 유효한 URI 참조가 아닌 Location 필드에서 복구를 시도한다. 이 명세는 그러한 처리를 위임하거나 정의하지 않지만, 견고성을 위해 허용된다.&lt;/p&gt;

&lt;p&gt;참고 : Content-Location 헤더 필드는 Content-Location 이 동봉된 표현에 해당하는 가장 구체적인 리소스를 지칭한다는 점에서 Loaction과 다르다. 
따라서 응답에 Loaction 및 Content-Location 헤더 필드가 모두 포함될 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;713-retry-after&quot;&gt;7.1.3. Retry-After&lt;/h3&gt;
&lt;p&gt;서버는 “Retry-After” 헤더 필드를 보내 사용자 에이전트가 후속 요청을 하기 전에 얼마나 기다려야 하는지 표시한다. 
503 (Service Unavailable) 응답과 함께 전송된 경우 Retry-After에는 클라이언트가 서비스를 사용할 수 없을 것으로 예쌍되는 기간이 표시된다. 
3xx (Redirection) 응답과 함께 전송되는 경우 Retry-After에는 리디렉션 요청을 실행하기 전에 사용자 에이전트가 대기하도록 요청하는 최소 시간이 표시된다.&lt;/p&gt;

&lt;p&gt;이 필드의 값은 HTTP-date 또는 응답 수신 후 지연 시간(초)이 될 수 있다.&lt;/p&gt;

&lt;p&gt;Retry-After = HTTP-date / delay-seconds&lt;/p&gt;

&lt;p&gt;delay-seconds 값은 음이 아닌 소수 정수로 시간(초)을 나타낸다.&lt;/p&gt;

&lt;p&gt;delay-seconds = 1*DIGIT&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Retry-After: Fri, 31 Dec 1999 23:59:59 GMT 
Retry-After: 120 (2분 지연)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예제를 만들어 동작을 시켜보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/http1-1SemanticsAndContent/RetryAfter.png&quot; alt=&quot;Retry-After&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Retry-After값을 5를 줘서 5초 이후에 리디렉션이 되도록 구현하였지만 동작을 하지 않았다. 
이유를 찾아보니 웹브라우저(크롬, 파이어폭스, IE 등)은 무시한다고한다.&lt;/p&gt;

&lt;h3 id=&quot;714-vary&quot;&gt;7.1.4. Vary&lt;/h3&gt;
&lt;p&gt;응답의 “Vary” 헤더 필드는 메서드, Host 헤더 필드 및 요청 대상을 제외하고 
요청 메시지의 어떤 부분이 이 응답을 선택하고 나타내는 원서버의 프로세스에 영향을 미칠 수 있는 지 설명 한다. 
값은 단일 별표(“*”) 또는 헤더 필드 이름 목록(대소문자 구분 없음)으로 구성 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vary = &quot;*&quot; / 1 #field-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“&lt;em&gt;” 필드 값은 요청에 대한 모든 것이 메시지 구문(클라이언트의 네트워크 주소) 외부에 있는 요소를 포함하여 
응답 representation을 선택하는데 역할을 할 수 있음을 나타낸다. 수신자는 요청을 원 서버로 전달하지 않고는 
이 응답이 이후 요청에 적합한지 여부를 결정할 수 없을 것이다.
프록시는 “&lt;/em&gt;” 값을 가진 Vary 필드를 생성해서는 안 된다.&lt;/p&gt;

&lt;p&gt;comma-separated로 구분된 이름 목록으로 구성된 Vary 필드 값은 선택 헤더 필드라고 알려진 
명명된 요청 헤더 필드가 representation을 선택하는 데 역할을 할 수 있음을 표시한다. 잠재적 선택 헤더 필드는 
이 명세에 의해 정의된 필드로 제한되지 않는다.&lt;/p&gt;

&lt;p&gt;예를 들어 Vary가 포함된 응답은&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vary: accept-encoding, accept-language
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원서버가 이 응답에 대한 내용을 선택하면서 요청의 Accept-Encoding 및 
Accept-Language 필드(또는 해당 필드 없음)를 결정 요인으로 사용했을 수 있음을 나타낸다.&lt;/p&gt;

&lt;p&gt;원 서버는 두 가지 목적을 위해 필드 목록과 함께 Vary를 보낼 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;캐시 수신자에게, 이후의 요청이 원래 요청과 동일한 값을 가지지 않는 한, 
이후의 요청을 만족 시키기 위해 이 응답을 사용해서는 안 된다는 것을 통지 한다.
즉, Vary는 저장된 캐시 항목으로 새 요청을 일치시키는 데 필요한 캐시 키를 확장한다.&lt;/li&gt;
  &lt;li&gt;사용자 에이전트 수신자에게 이 응답은 컨텐츠 협상의 대상이며, 
나열된 헤더 필드에 추가 파라미터가 제공될 경우 후속 요청으로 다른 표현이 전송될 수 있음을 통지한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Vary 헤더를 이용하여 브라우저 캐시를 확인하려고했는데; 동작을 하지 않는다. 방법을 한번 찾아봐야할듯.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;72-validator-header-fields&quot;&gt;7.2. Validator Header Fields&lt;/h2&gt;
&lt;p&gt;검증자 헤더 필드는 선택된 representation에 대한 메타 데이터를 전송한다. 
안전한 요청에 대한 응답에서 검증자 필드는 응답을 처리하는 동안 원서버에 의해 선택된 representation을 설명한다. 
상태 코드 의미에 따라 특정 응답에 대해 선택된 representation은 응답 페이로드로 동봉된 
representation과 반드시 동일하지 않는다는 점에 유의한다.&lt;/p&gt;

&lt;p&gt;상태 변경 요청에 대한 성공적인 응답에서 검증자 필드는 요청을 처리한 결과 이전에 선택된 
representation을 대체한 새로운  representation을 설명한다.&lt;/p&gt;

&lt;p&gt;예를 들어 201(Created) 응답의 ETag 헤더 필드는 새로 생성된 리소스의 representation에 대한 
entity-tag를 전달하여, 이후 조건부에 요청에 사용되어 “lost update” 문제를 방지할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ETag&lt;/li&gt;
  &lt;li&gt;Last-Modified&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;73-authentication-challenges&quot;&gt;7.3. Authentication Challenges&lt;/h2&gt;
&lt;p&gt;인증 문제는 클라이언트가 향후 요청 시 인증 자격 증명을 제공할 수 있는 메커니즘을 나타낸다.&lt;/p&gt;

&lt;h2 id=&quot;74-response-context&quot;&gt;7.4. Response Context&lt;/h2&gt;
&lt;p&gt;나머지 응답 헤더 필드는 이후 요청에 사용할 수 있는 대상 리소스에 대한 자세한 정보를 제공 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Accept-Ranges&lt;/li&gt;
  &lt;li&gt;Allow&lt;/li&gt;
  &lt;li&gt;Server&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;741-allow&quot;&gt;7.4.1. Allow&lt;/h3&gt;
&lt;p&gt;“Allow” 헤더 필드에는 대상 리소스가 지원하는 것으로 알려진 메서드 집합이 나열된다. 
이 필드의 목적은 수신자에게 리소스와 관련된 유효한 요청 메서드를 알리는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Allow = #method
Allow : GET, HEAD, PUT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;허용되는 메서드의 실제 집합은 각 요청 시 원서버에 의해 정의된다. 
원서버는 405(Method Not Allow) 응답에서 Allow 필드를 생성해야 하며, 
다른 응답에서도 Allow 필드를 생성할 수 있다. 405 상태 코드에서 빈 Allow 필드 값은 리소스가 메서드를 허용하지 않음을 나타내며 
리소스가 일시적으로 비활성화된 경우를 나타낸다.&lt;/p&gt;

&lt;p&gt;프록시는 Allow 헤더 필드를 수정해서는 안 되며, 일반적인 메시지 처리 규칙에 따라 처리하기 위해 표시된 모든 메서드를 이해할 필요는 없다.&lt;/p&gt;

&lt;h3 id=&quot;742-server&quot;&gt;7.4.2. Server&lt;/h3&gt;
&lt;p&gt;“Server” 헤더 필드에는 요청을 처리하기 위해 원서버가 사용하는 소프트웨어에 대한 정보가 들어 있는데, 
이 소프트웨어는 보고된 상호 운용성 문제의 범위를 식별하는 데 도움을 주고, 
특정 서버 제한을 피하기 위해 작업하거나 요청을 맞춤화하며, 
서버 또는 운영체제 사용과 관련된 분석을 위해 클라이언트가 종종 사용한다. 
원서버는 응답에 Server 필드를 생성할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Server = product *(RWS(product/comment))
Server: CERN/3.0 libwww/2.17
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Server field-value는 하나 이상의 product 식별자로 구성되며, 각각 0개 이상의 주석이 뒤따르며 
원서버 소프트웨어와 그 중요한 하위 제품을 함께 식별한다. product 식별자는 원서버 소프트웨어를 식별하기 위한 중요도의 감소 순서로 나열된다.&lt;/p&gt;

&lt;p&gt;원서버는 불필요한 세부 정보가 포함된 Server 필드를 생성해서는 안 되며, 서드 파티의 하위 제품 추가를 제한해야 한다. 
지나치게 길고 세부적인 Server 필드 값은 응답 대기 시간을 증가시키고 공격자가 알려진 보안 구멍을 더 쉽게 찾고 이용할 수 있는 
내부 구현 세부 정보를 잠재적으로 노출시킬 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;설명되지 않은 헤더들에 대해선 추후 문서를 읽어보면서 알아보도록 하겠다.&lt;br /&gt;
1~7번까지의 설명을 알아보았다. 8번의 내용은 새로운 메서드를 등록하거나 상태 코드를 등록하는 방법에 대해서 설명하는데 현재 내 기준에선 기록하면서 만큼 알아볼 정도는 아니여서 추후에 필요하다면 학습하도록 하자.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="http" /><category term="Web" /><category term="HTTP1.1" /><summary type="html">참고 자료 이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본 https://roka88.dev/106 MDN Web Docs https://developer.mozilla.org/ko/docs/Web/HTTP 이외 자료는 내용 중 링크 추가 틀린 내용, 부족한 내용 꼭 지적 부탁드립니다! 7. Response Header Fields 응답 헤더 필드는 서버가 status-line에 배치된 정보를 넘어 응답에 대한 추가 정보를 전달할 수 있도록 한다. 이러한 헤더 필드는 서버에 대한 정보, 대상 리소스에 대한 추가 액세스 또는 관련 리소스에 대한 정보를 제공한다. 각 응답 헤더 필드에는 정의된 의미가 있지만, 일반적으로 정확한 의미론은 요청 메서드 및/또는 응답 상태 코드의 의미에 의해 더욱 세분화될 수 있다. 7.1. Control Data 응답 헤더 필드는 상태 코드를 보충하거나 캐시를 지시하거나 클라이언트에게 다음은 어디로 가야 하는지 지시하는 제어 데이터를 제공할 수 있다. Age Cache-Control Expires Date Location Retry-After Vary Warning 7.1.1 Origination Date 7.1.1.1. Data/Time Formats 1995년 이전에는 서버가 타임스탬프를 통신하기 위해 일반적으로 사용하는 세 가지 다른 형식이 있었다. 기존 구현과의 호환성을 위해 세 가지 모두 여기에 정의되어 있따. 선호하는 형식은 인터넷 메시지 형식에서 사용하는 날짜 및 시간 규격의 fixed-length 및 single-zone 부분 집합이다. HTTP-date = IMF-fixdate /obs-date 선호하는 형식의 예는 Sun, 06 Nov 1994 08:49:38 GMT; IMF-fixdate 사용되지 않는 두형식의 예는 다음과 같다. Sunday, 06-Nov-94 08:49:38 GMT; obsolete format Sun Nov 6 08:49:38 1994; ANSI C`s asctime() format HTTP 헤더 필드에서 타임스탬프 값을 구문 분석하는 수신자는 세 가지 HTTP-date 형식을 모두 수용해야 한다. 발신자가 HTTP-date로 정의된 하나 이상의 타임스탬프를 포함하는 헤더 필드를 생성할 때, 발신자는 반드시 IMF-fixdate 형식으로 타임스탬프를 생성해야 한다. HTTP 날짜 값은 UTC(Coordinated Universal Time)의 인스턴스로서의 시간을 나타낸다. 처음 두 형식은 UTC 이름의 이전 버진인 “GMT”의 3글자 약어로 UTC를 나타내며, asctime 형식의 값은 UTC로 가장헌다. 로컬 클럭에서 HTTP 날짜 값을 생성하는 발신자는 시계를 UTC에 동기화하기 위해 NTP 또는 이와 유사한 프로토콜을 사용해야 한다. IMF-fixdate = day-name &quot;,&quot; SP date 1 SP time-of-day SP GMT ;fixed length/zone/capitalization subset of the format day-name = %x4D.6F.6E; :&quot;Mon&quot;, case-sensitive / %x54.75.65; :&quot;Tue&quot;, case-sensitive / %x57.65.64 ; &quot;Wed&quot;, case-sensitive / %x54.68.75 ; &quot;Thu&quot;, case-sensitive / %x46.72.69 ; &quot;Fri&quot;, case-sensitive / %x53.61.74 ; &quot;Sat&quot;, case-sensitive / %x53.75.6E ; &quot;Sun&quot;, case-sensitive date 1 = day SP month SP year ;e.g.,02 Jun 1982 day = 2DIGIT month = %x4A.61.6E ; &quot;Jan&quot;, case-sensitive / %x46.65.62 ; &quot;Feb&quot;, case-sensitive / %x4D.61.72 ; &quot;Mar&quot;, case-sensitive / %x41.70.72 ; &quot;Apr&quot;, case-sensitive / %x4D.61.79 ; &quot;May&quot;, case-sensitive / %x4A.75.6E ; &quot;Jun&quot;, case-sensitive / %x4A.75.6C ; &quot;Jul&quot;, case-sensitive / %x41.75.67 ; &quot;Aug&quot;, case-sensitive / %x53.65.70 ; &quot;Sep&quot;, case-sensitive / %x4F.63.74 ; &quot;Oct&quot;, case-sensitive / %x4E.6F.76 ; &quot;Nov&quot;, case-sensitive / %x44.65.63 ; &quot;Dec&quot;, case-sensitive year = 4DIGIT GMT = %x47.4D.54 ; &quot;GMT&quot;, case-sensitive time-of-day = hour &quot;:&quot; minute &quot;:&quot; second ; 00:00:00 - 23:59:60 (leap second) hour = 2DIGIT minute = 2DIGIT second = 2DIGIT 쇠퇴한 형식(참고만 하자) obs-date = rfc850-date / asctime-date rfc850-date = day-name-l &quot;,&quot; SP date2 SP time-of-day SP GMT date2 = day &quot;-&quot; month &quot;-&quot; 2DIGIT ; e.g., 02-Jun-82 day-name-l = %x4D.6F.6E.64.61.79 ; &quot;Monday&quot;, case-sensitive / %x54.75.65.73.64.61.79 ; &quot;Tuesday&quot;, case-sensitive / %x57.65.64.6E.65.73.64.61.79 ; &quot;Wednesday&quot;, case-sensitive / %x54.68.75.72.73.64.61.79 ; &quot;Thursday&quot;, case-sensitive / %x46.72.69.64.61.79 ; &quot;Friday&quot;, case-sensitive / %x53.61.74.75.72.64.61.79 ; &quot;Saturday&quot;, case-sensitive / %x53.75.6E.64.61.79 ; &quot;Sunday&quot;, case-sensitive asctime-date = day-name SP date3 SP time-of-day SP year date3 = month SP ( 2DIGIT / ( SP 1DIGIT )) ; e.g., Jun 2 HTTP-date는 대소문자를 구분한다. 발신자는 문법에 SP로 구체적으로 포함된 공간을 초과하여 HTTP-date에 추가 공백을 생성해서는 안 된다. day-name, day, month, year 및 time-of-day의 의미는 해당 이름과 Internet Message Format 구성에 대해 정의된 것과 동일 하다. 두 자릿수를 사용하는 rfc850-date 형식의 타임스탬프 값을 받는 사람은 2-digit가 가장 최근 연도를 나타내는 것으로 해석해야 한다. 타임스탬프 값의 수신자는 필드 정의에 의해 달리 제한되지 않는 한 타임스탬프를 구문 분석할 때 견고한 것을 권장한다. 예를 들어, Internet Message Format에 의해 정의된 날짜 및 시간 사양을 생성할 수 있는 비 HTTP 소스에서 메시지를 HTTP를 통해 전달하는 경우가 있다. 참고 : date/time 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내의 사용에만 적용된다. 사용자 프레젠테이션, 요청 기록 등에 이러한 형식을 사용할 필요는 없다. 7.1.1.2. Date “Date” 헤더 필드는 Origination Date Field와 동일한 의미를 가지며 메시지가 발생한 날짜와 시간을 나타낸다. 필드 값은 HTTP-date이다. Date = HTTP-date 예를 들어 Date: Tue, 15 Nov 1994 08:12:31 GMT Date 헤더 필드가 생성될 떄, 발신자는 메시지 생성 날짜와 시간에 대한 가장 근사치로서 필드 값을 생성해야 한다. 이론적으로, 날짜는 페이로드가 생성되기 바로 전의 순간을 나타내야 한다. 실제로 그 날짜는 메시지 작성 중에 언제라도 생성될 수 있다. 원서버는 UTC에서 현재 인스턴스의 합당한 근사치를 에제공할 수 있는 시계가 없는 경우 Date 헤더 필드를 보내서는 안 된다. 응답이 상태 코드의 1xx(Informational) 또는 5xx(Server Error) 등급인 경우 원 서버는 Date 헤더 필드는 보낼 수 있다. 원서버는 다른 모든 경우 Date 헤더 필드를 전송해야 한다. Date 헤더 필드 없이 응답 메시지를 수신하는 시계가 있는 수신자는 수신된 시간을 기록하고 해당 Date 헤더 필드가 캐시 되거나 다운스트림에서 전달되는 경우 메시지의 헤더 부문에 해당 Date 헤더 필드를 추가해야 한다. 사용자 에이전트는 요청으로 Date 헤더 필드를 보낼 수 있지만, 서버에 유용한 정보를 전달하는 것으로 간주되지 않는 한 일반적으로 그렇게 하지 않는다. 예를 들어, HTTP의 사용자 정의 어플리케이션은 서버가 사용자 에이전트와 서버 시계 간의 차이를 기반으로 사용자 요청에 대한 해석을 조정할 것으로 기대되는 경우 Date를 전달할 수 있다. 7.1.2. Location “Location” 헤더 필드는 응답과 관련된 특정 리소스를 참조하기 위해 일부 응답에 사용된다. 관계의 유형은 요청 메서드와 상태 코드 의미론의 조합에 의해 정의 된다. Location = URI-reference 필드 값은 단일 URI-reference로 구성된다. 상대적 참조의 형태를 가지고 있을 때 유효한 요청 URI의 값을 가진다. 201(Created) 응답의 경우, Location 값은 요청에 의해 생성된 기본 리소스를 말한다. 3xx (Redirection) 응답의 경우, Location 값은 요청을 자동으로 리디렉션하기 위한 기본 대상 리소스를 가르킨다. 3xx (Redirection) 응답에 제공된 Location 값에 Fragment(#)가 없는 경우, 사용자 에이전트는 그 값이 요청 대상을 생성하는 데 사용된 URI 참조의 Fragment(#) (즉, 리디렉션은 원래 참조의 파편을 상속하는 경우)를 상속하는 것처럼 리디렉션을 처리해야 한다. 예를 들어 URI 참조 “http://www.example.org/~tim”에 대해 생성된 GET 요청은 헤더 필드를 포함하는 303(See Other) 응답을 받을 수 있다. Location: /People.html#tim 사용자 에이전트가 “http://www.example.org/People.html#tim”으로 리디렉션됨을 암시한다. 마찬가지로, URI 참조 “http://www.example.org/index.html#larry”에 대해 생성된 GET 요청은 다음과 같은 헤더 필드를 포함하는 301 (Moved Permanently) 응답을 초래할 수 있다. Location: http://www.example.net/index.html 이는 사용자가 에이전트가 Fragment(#)를 보존하면서 “http://www.eample.net/index.html#larry”으로 리디렉션을 제안한다. Location 값의 Fragment(#)가 적절하지 않은 상황이 있다. 예를 들어 201(Created) 응답의 Location 헤더 필드는 생성된 리소스와 관련된 URI를 제공하도록 되어 있다. 참고: 일부 수신자는 유효한 URI 참조가 아닌 Location 필드에서 복구를 시도한다. 이 명세는 그러한 처리를 위임하거나 정의하지 않지만, 견고성을 위해 허용된다. 참고 : Content-Location 헤더 필드는 Content-Location 이 동봉된 표현에 해당하는 가장 구체적인 리소스를 지칭한다는 점에서 Loaction과 다르다. 따라서 응답에 Loaction 및 Content-Location 헤더 필드가 모두 포함될 수 있다. 7.1.3. Retry-After 서버는 “Retry-After” 헤더 필드를 보내 사용자 에이전트가 후속 요청을 하기 전에 얼마나 기다려야 하는지 표시한다. 503 (Service Unavailable) 응답과 함께 전송된 경우 Retry-After에는 클라이언트가 서비스를 사용할 수 없을 것으로 예쌍되는 기간이 표시된다. 3xx (Redirection) 응답과 함께 전송되는 경우 Retry-After에는 리디렉션 요청을 실행하기 전에 사용자 에이전트가 대기하도록 요청하는 최소 시간이 표시된다. 이 필드의 값은 HTTP-date 또는 응답 수신 후 지연 시간(초)이 될 수 있다. Retry-After = HTTP-date / delay-seconds delay-seconds 값은 음이 아닌 소수 정수로 시간(초)을 나타낸다. delay-seconds = 1*DIGIT Retry-After: Fri, 31 Dec 1999 23:59:59 GMT Retry-After: 120 (2분 지연) 예제를 만들어 동작을 시켜보았다. Retry-After값을 5를 줘서 5초 이후에 리디렉션이 되도록 구현하였지만 동작을 하지 않았다. 이유를 찾아보니 웹브라우저(크롬, 파이어폭스, IE 등)은 무시한다고한다. 7.1.4. Vary 응답의 “Vary” 헤더 필드는 메서드, Host 헤더 필드 및 요청 대상을 제외하고 요청 메시지의 어떤 부분이 이 응답을 선택하고 나타내는 원서버의 프로세스에 영향을 미칠 수 있는 지 설명 한다. 값은 단일 별표(“*”) 또는 헤더 필드 이름 목록(대소문자 구분 없음)으로 구성 된다. Vary = &quot;*&quot; / 1 #field-name “” 필드 값은 요청에 대한 모든 것이 메시지 구문(클라이언트의 네트워크 주소) 외부에 있는 요소를 포함하여 응답 representation을 선택하는데 역할을 할 수 있음을 나타낸다. 수신자는 요청을 원 서버로 전달하지 않고는 이 응답이 이후 요청에 적합한지 여부를 결정할 수 없을 것이다. 프록시는 “” 값을 가진 Vary 필드를 생성해서는 안 된다. comma-separated로 구분된 이름 목록으로 구성된 Vary 필드 값은 선택 헤더 필드라고 알려진 명명된 요청 헤더 필드가 representation을 선택하는 데 역할을 할 수 있음을 표시한다. 잠재적 선택 헤더 필드는 이 명세에 의해 정의된 필드로 제한되지 않는다. 예를 들어 Vary가 포함된 응답은 Vary: accept-encoding, accept-language 원서버가 이 응답에 대한 내용을 선택하면서 요청의 Accept-Encoding 및 Accept-Language 필드(또는 해당 필드 없음)를 결정 요인으로 사용했을 수 있음을 나타낸다. 원 서버는 두 가지 목적을 위해 필드 목록과 함께 Vary를 보낼 수 있다. 캐시 수신자에게, 이후의 요청이 원래 요청과 동일한 값을 가지지 않는 한, 이후의 요청을 만족 시키기 위해 이 응답을 사용해서는 안 된다는 것을 통지 한다. 즉, Vary는 저장된 캐시 항목으로 새 요청을 일치시키는 데 필요한 캐시 키를 확장한다. 사용자 에이전트 수신자에게 이 응답은 컨텐츠 협상의 대상이며, 나열된 헤더 필드에 추가 파라미터가 제공될 경우 후속 요청으로 다른 표현이 전송될 수 있음을 통지한다. Vary 헤더를 이용하여 브라우저 캐시를 확인하려고했는데; 동작을 하지 않는다. 방법을 한번 찾아봐야할듯. 7.2. Validator Header Fields 검증자 헤더 필드는 선택된 representation에 대한 메타 데이터를 전송한다. 안전한 요청에 대한 응답에서 검증자 필드는 응답을 처리하는 동안 원서버에 의해 선택된 representation을 설명한다. 상태 코드 의미에 따라 특정 응답에 대해 선택된 representation은 응답 페이로드로 동봉된 representation과 반드시 동일하지 않는다는 점에 유의한다. 상태 변경 요청에 대한 성공적인 응답에서 검증자 필드는 요청을 처리한 결과 이전에 선택된 representation을 대체한 새로운 representation을 설명한다. 예를 들어 201(Created) 응답의 ETag 헤더 필드는 새로 생성된 리소스의 representation에 대한 entity-tag를 전달하여, 이후 조건부에 요청에 사용되어 “lost update” 문제를 방지할 수 있다. ETag Last-Modified 7.3. Authentication Challenges 인증 문제는 클라이언트가 향후 요청 시 인증 자격 증명을 제공할 수 있는 메커니즘을 나타낸다. 7.4. Response Context 나머지 응답 헤더 필드는 이후 요청에 사용할 수 있는 대상 리소스에 대한 자세한 정보를 제공 한다. Accept-Ranges Allow Server 7.4.1. Allow “Allow” 헤더 필드에는 대상 리소스가 지원하는 것으로 알려진 메서드 집합이 나열된다. 이 필드의 목적은 수신자에게 리소스와 관련된 유효한 요청 메서드를 알리는 것이다. Allow = #method Allow : GET, HEAD, PUT 허용되는 메서드의 실제 집합은 각 요청 시 원서버에 의해 정의된다. 원서버는 405(Method Not Allow) 응답에서 Allow 필드를 생성해야 하며, 다른 응답에서도 Allow 필드를 생성할 수 있다. 405 상태 코드에서 빈 Allow 필드 값은 리소스가 메서드를 허용하지 않음을 나타내며 리소스가 일시적으로 비활성화된 경우를 나타낸다. 프록시는 Allow 헤더 필드를 수정해서는 안 되며, 일반적인 메시지 처리 규칙에 따라 처리하기 위해 표시된 모든 메서드를 이해할 필요는 없다. 7.4.2. Server “Server” 헤더 필드에는 요청을 처리하기 위해 원서버가 사용하는 소프트웨어에 대한 정보가 들어 있는데, 이 소프트웨어는 보고된 상호 운용성 문제의 범위를 식별하는 데 도움을 주고, 특정 서버 제한을 피하기 위해 작업하거나 요청을 맞춤화하며, 서버 또는 운영체제 사용과 관련된 분석을 위해 클라이언트가 종종 사용한다. 원서버는 응답에 Server 필드를 생성할 수 있다. Server = product *(RWS(product/comment)) Server: CERN/3.0 libwww/2.17 Server field-value는 하나 이상의 product 식별자로 구성되며, 각각 0개 이상의 주석이 뒤따르며 원서버 소프트웨어와 그 중요한 하위 제품을 함께 식별한다. product 식별자는 원서버 소프트웨어를 식별하기 위한 중요도의 감소 순서로 나열된다. 원서버는 불필요한 세부 정보가 포함된 Server 필드를 생성해서는 안 되며, 서드 파티의 하위 제품 추가를 제한해야 한다. 지나치게 길고 세부적인 Server 필드 값은 응답 대기 시간을 증가시키고 공격자가 알려진 보안 구멍을 더 쉽게 찾고 이용할 수 있는 내부 구현 세부 정보를 잠재적으로 노출시킬 수 있다. 설명되지 않은 헤더들에 대해선 추후 문서를 읽어보면서 알아보도록 하겠다. 1~7번까지의 설명을 알아보았다. 8번의 내용은 새로운 메서드를 등록하거나 상태 코드를 등록하는 방법에 대해서 설명하는데 현재 내 기준에선 기록하면서 만큼 알아볼 정도는 아니여서 추후에 필요하다면 학습하도록 하자.</summary></entry><entry><title type="html">HTTP 1.1 Reference - Semantics and Content (4) (최종 수정 날짜 : 2021-02-23)</title><link href="https://lcy960729.github.io/http/2021/02/23/HTTP1-1-Semantics-And-Content(4).html" rel="alternate" type="text/html" title="HTTP 1.1 Reference - Semantics and Content (4) (최종 수정 날짜 : 2021-02-23)" /><published>2021-02-23T00:00:00+09:00</published><updated>2021-02-23T00:00:00+09:00</updated><id>https://lcy960729.github.io/http/2021/02/23/HTTP1-1-Semantics-And-Content(4)</id><content type="html" xml:base="https://lcy960729.github.io/http/2021/02/23/HTTP1-1-Semantics-And-Content(4).html">&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본&lt;br /&gt;
&lt;a href=&quot;https://roka88.dev/106&quot;&gt;https://roka88.dev/106&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MDN Web Docs&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP&quot;&gt;https://developer.mozilla.org/ko/docs/Web/HTTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외 자료는 내용 중 링크 추가&lt;/p&gt;
&lt;h5 id=&quot;틀린-내용-부족한-내용-꼭-지적-부탁드립니다&quot;&gt;틀린 내용, 부족한 내용 꼭 지적 부탁드립니다!&lt;/h5&gt;

&lt;h1 id=&quot;6-response-status-codes&quot;&gt;6. Response Status Codes&lt;/h1&gt;
&lt;p&gt;status-code 요소는 요청을 이해하고 충족시키려는 시도의 결과를 제공하는 세 자리 정수 코드다.&lt;/p&gt;

&lt;p&gt;HTTP 상태 코드는 확장 가능하다. HTTP 클라이언트는 등록된 모든 상태 코드의 의미를 이해 할 필요는 없지만, 
그러한 이해는 분명히 바람직하다. 그러나 클라이언트는 첫 번째 숫자로 표시된 상태 코드의 클래스를 이해하고 
인식되지 않는 상태 코드를 해당 클래스의 x00 상태 코드에 해당하는 것으로 취급해야 하며, 
단, 수신자는 인식되지 않는 상태 코드로 응답을 캐시하면 안 된다는 점을 제외한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 인식되지 않는 상태 코드 471이 클라이언트에 의해 수신된 경우, 클라이언트는 자신의 요청에 이상이 있다고 가정하고, 
응답은 400(Bad Request) 상태 코드를 받은 것처럼 취급할 수 있다. 응답 메시지에는 일반적으로 상태를 설명하는 representation이 포함될 것이다.&lt;/p&gt;

&lt;p&gt;상태 코드의 첫 번째 자릿수는 응답 클래스를 정의한다. 마지막 두 자리에는 분류 역할이 없다(마지막 두 자리가 어떠한 의미로 분류되지 않음). 첫번째 자리에는 다섯 개의 값이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1xx(Informational)  : 요청이 수신되어 프로세스가 계속 진행됨&lt;/li&gt;
  &lt;li&gt;2xx(Successful)     : 요청이 성공적으로 수신, 이해 및 수락됨&lt;/li&gt;
  &lt;li&gt;3xx(Redirection)    : 요청을 완료하려면 추가 조치를 취해야함&lt;/li&gt;
  &lt;li&gt;4xx(Client Error)   : 요청에 잘못된 구문이 포함되어 있거나 충족할 수 없음 (요청 자체가 잘못됐을때)&lt;/li&gt;
  &lt;li&gt;5xx(Server Error)   : 서버가 유효한 요청을 수행하지 못함(요청은 올바른데 서버에서 처리를 못할때)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;61-overview-of-status-codes&quot;&gt;6.1. Overview of Status Codes&lt;/h2&gt;
&lt;p&gt;아래에 나열된 상태 코드의 Reason-Phrase는 권장 사항일 뿐이며 프로토콜에 영향을 주지 않고 로컬 등가물(이게 뭔말이지)로 대체 될 수 있다.&lt;/p&gt;

&lt;p&gt;기본적으로 캐시 가능한 상태 코드(이 명세는 200, 203, 206, 300, 301, 404, 405, 410, 414, 501)가 있는 응답은 
메서드 정의나 명시적 캐시 제어[RFC7234 5.2 참고]로 달리 명시되지 않는 한 경험적 접근 만료를 가진 캐시에서 재사용할 수 있으며, 다른 모든 상태 코드는 
기본적으로 캐시 가능하지 않다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Code&lt;/th&gt;
      &lt;th&gt;Reason-Phrase&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;Continue&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;101&lt;/td&gt;
      &lt;td&gt;Switching Protocols&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;200&lt;/td&gt;
      &lt;td&gt;OK&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;201&lt;/td&gt;
      &lt;td&gt;Created&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;202&lt;/td&gt;
      &lt;td&gt;Accepted&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;203&lt;/td&gt;
      &lt;td&gt;Non-Authoritative Information&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;204&lt;/td&gt;
      &lt;td&gt;No Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;205&lt;/td&gt;
      &lt;td&gt;Reset Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;206&lt;/td&gt;
      &lt;td&gt;Partial Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;300&lt;/td&gt;
      &lt;td&gt;Multiple Choices&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;301&lt;/td&gt;
      &lt;td&gt;Moved Permanently&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;302&lt;/td&gt;
      &lt;td&gt;Found&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;303&lt;/td&gt;
      &lt;td&gt;See Other&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;304&lt;/td&gt;
      &lt;td&gt;Not Modified&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;305&lt;/td&gt;
      &lt;td&gt;Use Proxy&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;307&lt;/td&gt;
      &lt;td&gt;Temporary Redirect&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;400&lt;/td&gt;
      &lt;td&gt;Bad Request&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;401&lt;/td&gt;
      &lt;td&gt;Unauthorized&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;402&lt;/td&gt;
      &lt;td&gt;Payment Required&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;403&lt;/td&gt;
      &lt;td&gt;Forbidden&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;404&lt;/td&gt;
      &lt;td&gt;Not Found&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;405&lt;/td&gt;
      &lt;td&gt;Method Not Allowed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;406&lt;/td&gt;
      &lt;td&gt;Not Acceptable&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;407&lt;/td&gt;
      &lt;td&gt;Proxy Authentication Required&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;408&lt;/td&gt;
      &lt;td&gt;Request Timeout&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;409&lt;/td&gt;
      &lt;td&gt;Conlict&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;410&lt;/td&gt;
      &lt;td&gt;Gone&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;411&lt;/td&gt;
      &lt;td&gt;Length Required&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;412&lt;/td&gt;
      &lt;td&gt;Precondition Failed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;413&lt;/td&gt;
      &lt;td&gt;Payload Too Large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;414&lt;/td&gt;
      &lt;td&gt;URI Too Long&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;415&lt;/td&gt;
      &lt;td&gt;Unsupported Media Type&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;416&lt;/td&gt;
      &lt;td&gt;Range Not Satisfiable&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;417&lt;/td&gt;
      &lt;td&gt;Expectation Failed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;426&lt;/td&gt;
      &lt;td&gt;Upgrade Required&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;500&lt;/td&gt;
      &lt;td&gt;Internal Server Error&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;501&lt;/td&gt;
      &lt;td&gt;Not Implemented&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;502&lt;/td&gt;
      &lt;td&gt;Bad GateWay&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;503&lt;/td&gt;
      &lt;td&gt;Service Unavailable&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;504&lt;/td&gt;
      &lt;td&gt;Gateway Timeout&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;505&lt;/td&gt;
      &lt;td&gt;HTTP Version Not Supported&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 목록은 모든 상태코드를 나타내는것은 아니며, 다른 사양에 정의된 확장 상태 코드를 포함하지 않고 있다. 
상태 코드의 전체 목록은 IANA에 의해 유지 된다.&lt;/p&gt;

&lt;h3 id=&quot;62-informational-1xx&quot;&gt;6.2. Informational 1xx&lt;/h3&gt;
&lt;p&gt;1xx (Informational) 등급의 상태 코드는 요청된 조치를 완료하고 최종 응답을 보내기 전에 커넥션 상태 
또는 요청 진행 상황을 전달하기 위한 중간 응답을 나타낸다. 1xx 응답은 status-line(헤더 부문의 끝을 알리는 빈 라인) 
후 첫 번째 빈 라인에 의해 종료 된다. HTTP/1.0은 1xx 상태 코드를 정의하지 않았으므로 서버는 1xx 응답을 
HTTP/1.0 클라이언트에 전송해서는 안 된다.&lt;/p&gt;

&lt;p&gt;클라이언트는 최종 응답 전에 받은 1xx 응답 중 하나 이상을 구문 분석할 수 있어야 한다. 
사용자 에이전트는 예기치 않은 1xx 응답을 무시할 수 있다.&lt;/p&gt;

&lt;p&gt;프록시 자체가 1xx 응답 생성을 요청하지 않는 한 프록시는 1xx 응답을 전달해야 한다. 
예를 들어, 요청을 전달할 때 프록시가 “Expect:100-continue” 필드를 추가하는 경우, 
해당 100(Continue) 응답을 전송할 필요가 없다.&lt;/p&gt;

&lt;h3 id=&quot;621-100-continue&quot;&gt;6.2.1. 100 Continue&lt;/h3&gt;
&lt;p&gt;100 (Continue) 상태 코드는 요청의 초기 부분이 수신되어 아직 서버에서 거부되지 않았음을 나타낸다. 
서버는 요청이 완전히 접수되고 조치된 후 최종 응답을 보내려고 한다.&lt;/p&gt;

&lt;p&gt;요청이 100-continue를 포함하는 Expect 헤더 필드를 포함할 경우, 100 응답은 서버가 요청 페이로드 본문을 수신하기를 원함을 나타낸다. 
클라이언트는 요청을 계속 보내고 100 응답을 폐기해야 한다.&lt;/p&gt;

&lt;p&gt;요청이 100-continue를 포함하는 Expect 헤더 필드를 포함하지 않은 경우, 
클라이언트는 이 중간 응답을 간단히 폐기할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;622-101-switching-protocols&quot;&gt;6.2.2. 101 Switching Protocols&lt;/h3&gt;
&lt;p&gt;101 (Switching Protocols) 상태 코드는 서버가 이 커넥션에 사용되는 어플리케이션 프로콜의 변경에 대해 Upgrage 헤더 필드를
통해 클라이언트의 요청을 이해하고 이를 준수할 의사가 있음을 나타낸다. 서버는 101 응답과 전환할 프로토콜을 나타내는 Upgrage 헤더 필드를 생성해야 한다.&lt;/p&gt;

&lt;p&gt;서버가 프로토콜 전환에 유리한 경우에만 동의할 것으로 가정한다. 예를 들어, 이전 버전보다 새로운 버전의 HTTP로 전환하는 것이 유리할 수 있으며, 
이러한 기능을 사용하는 리소스를 제공할 때 실시간 동기식 프로토콜로 전환하는 것이 유리할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;63-successful-2xx&quot;&gt;6.3. Successful 2xx&lt;/h2&gt;
&lt;p&gt;2xx (Successful) 등급의 상태 코드는 클라이언트의 요청이 성공적으로 수신, 이해 및 수용되었음을 나타낸다.&lt;/p&gt;

&lt;h3 id=&quot;631-200-ok&quot;&gt;6.3.1. 200 OK&lt;/h3&gt;
&lt;p&gt;200 (OK) 상태 코드는 요청이 성공했음을 나타낸다. 200개의 응답으로 전송되는 페이로드는 요청 메소드에 따라 달라진다. 
이 명세에 의해 정의된 메서드에 대해, 페이로드의 의도된 의미는 다음과 같이 요약할 수 있다.&lt;/p&gt;

&lt;p&gt;GET : 대상 리소스의 representation
HEAD : GET와 동일한 representation이지만 representation 데이터가 없는 경우.
POST : 원하는 동작에 대한 조치 상태 또는 결과 표시
PUT, DELETE : 조치 상태 표시
OPTIONS : 통신 옵션의 표시
TRACE : 엔드서버에서 수신한 요청 메시지의 representation&lt;/p&gt;

&lt;p&gt;CONNECT에 대한 응답 외에도 , 200의 응답은 항상 페이로드를 가지고 있지만, 원 서버는 0의 길이의 페이로드 본문을 생성할 수 있다. 
페이로드가 필요 없는 경우, 원서버는 대신 204 (No content)를 전송해야 한다. CONNECT의 경우, 성공적인 결과가 200 응답 헤더 부문 직후에 시작되는 
터널이기 때문에 페이로드가 허용되지 않는다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 200 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;632-201-created&quot;&gt;6.3.2. 201 Created&lt;/h3&gt;
&lt;p&gt;201 (Created) 상태 코드는 요청이 이행되어 하나 이상의 새로운 리소스가 생성되었음을 나타낸다. 
요청에 의해 생성된 기본 리소스는 응답의 Location 헤더 필드를 통해 식별하며, 수신된 Location 필드가 없는 경우 유효한 요청 URI를 통해 식별된다.&lt;/p&gt;

&lt;p&gt;201 응답 페이로드에는 일반적으로 생성된 리소스가 설명되고 링크된다.&lt;/p&gt;

&lt;h3 id=&quot;633-202-accepted&quot;&gt;6.3.3. 202 Accepted&lt;/h3&gt;
&lt;p&gt;202 (Accepted) 상태 코드는 요청이 접수되었으나 처리가 완료되지 않았음을 표시한다. 
(요청을 받았지만 아직 수행되지 않은 상태. 요청을 일괄적으로 받고 나중에 처리할 때 이 상태코드 반환하면 될듯)
요청은 실제로 처리될 때 허용되지 않을 수 있기 때문에 결국 실행될 수도 있고 실행되지 않을 수도 있다. 
HTTP에는 비동기 작업에서 상태 코드를 재전송할 수 있는 기능이 없다.&lt;/p&gt;

&lt;p&gt;202 응답은 의도적으로 모호하다. 그 목적은 프로세스가 완료될 때까지 사용자 에이전트의 서버 연결이 지속되지 않아도 되며 
서버가 다른 프로세스(아마도 하루에 한번만 실행되는 배치 지향 프로세스)에 대한 요청을 수락하도록 허용하는 것입니다.
이 응답과 함께 전송되는 representation은 요청의 현재 상태를 기술해야 하며, 
사용자에게 요청 이행 시기에 대한 추정치를 제공할 수 있는 상태 감시를 나타내거나 포함해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;634-203-non-authoritative-information&quot;&gt;6.3.4. 203 Non-Authoritative Information&lt;/h3&gt;
&lt;p&gt;203 (Non-Authoritative Inforamtion) 상태 코드는 요청이 성공적이었으나, 
변환 프록시에 의해 원서버의 200(OK) 응답으로 부터 포함된 페이로드가 수정되었음을 나타낸다. 
이 상태 코드는 변환이 적용되면 해당 정보가 컨텐츠에 대한 이후 결정에 영향을 미칠 수 있으므로 프록시가 수신자에게 통지할 수 있다. 
예를 들어 컨텐츠에 대한 향후 캐시 유효성 검사 요청은 동일한 요청 경로(동일한 프록시를 통해)를 통해서만 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;203 응답은 어떤 상태 코드로든 응답에 적용할 수 있다는 장점이 있는 214 Transformation Apply의 Warning 코드와 유사하다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 203 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;635-204-no-content&quot;&gt;6.3.5. 204 No Content&lt;/h3&gt;
&lt;p&gt;204 (No Content) 상태 코드는 서버가 요청을 성공적으로 이행 했으며 응답 페이로드 본문으로 보낼 추가 컨텐츠가 없음을 나타낸다. 
응답 헤더 필드의 메타 데이터는 요청된 작업이 적용된 후 대상 리소스와 선택된 representation을 가리킨다.&lt;/p&gt;

&lt;p&gt;예를 들어, PUT 요청에 대한 응답으로 204 상태 코드가 수신되고 응답에 Etag 헤더 필드가 포함된 경우 PUT은 성공했으며 
ETage field-value는 대상 리소스의 새로운 representation을 위한 entitiy-tage가 포함되어 있다.&lt;/p&gt;

&lt;p&gt;204 응답은 서버가 대상 리소스에 작업이 성공적으로 적용되었음을 나타내는 동시에 사용자가 에이전트가 현재 “document view”(있는 경우)에서 벗어날 필요가 없음을 암시한다. 
서버는 사용자 에이전트가 자신의 인터페이스와 일치하여 그 사용자에게 성공에 대한 어떤 표시를 제공할 것으로 가정하고, 
그 활성 representation에 대한 응답으로 새로운 메타 데이터나 업데이트된 메타 데이터를 적용한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 204 상태 코드는 일반적으로 “save” 작업에 해당하는 문서 편집 인터페이스와 함께 사용되어, 저장 중인 문서가 사용자가 편집할 수 있도록 유지 된다. 
또한 분산 버전 제어 시스템 내에서 처럼 자동화된 데이터 전송이 보편화될 것으로 예상하는 인터페이스에서도 자주 사용된다.&lt;/p&gt;

&lt;p&gt;204 응답은 메시지 본문을 포함할 수 없기 때문에 헤더 필드 뒤에 있는 첫번 째 빈 줄에 의해 종료 된다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 204 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;636-205-reset-content&quot;&gt;6.3.6. 205 Reset Content&lt;/h3&gt;
&lt;p&gt;205 (Reset Content) 상태 코드는 서버가 요청을 이행했음을 나타내며, 
사용자 에이전트가 요청을 보낸 “document view”를 리셋하라고 알린다.&lt;/p&gt;

&lt;p&gt;이 응답은 사용자가 데이터 엔트리(폼, 노트패드, 캔버스 등)를 지원하는 콘텐츠를 수신하고, 그 공간에서 데이터를 입력하거나 조작하고, 
입력된 데이터를 요청으로 제출하게 한 후, 다음 입력에 대해 데이터 입력 메니즘을 재설정하여 사용자가 다른 입력 작업을 쉽게 시작할 수 있도록 하는 
공통 데이터 입력 사용 사례를 지원하기 위한 것이다.&lt;/p&gt;

&lt;p&gt;205 상태 코드는 추가 콘텐츠가 제공되지 않음을 의미하므로 서버는 205 응답에서 페이로드를 생성해서는 안 된다.
즉, 서버는 205 응답에 대해 다음 중 하나를 수행해야 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;값이 0인 Content-Length 헤더 필드를 포함하여 응답의 길이가 0인 본문을 나타내라&lt;/li&gt;
  &lt;li&gt;청크 값을 가진 Transfer-Encoding 헤더 필드와 0 길이의 단일 청크로 구성된 메시지 본문을 포함하여 응답에 대한 
0 길이의 페이로드로 나타내라 (청크란 한 덩어리로 데이터를 보내지 않고 나눠서 보내는 것)&lt;/li&gt;
  &lt;li&gt;헤더 부분을 종료하는 빈줄을 보낸 후 즉시 커넥션을 닫아라.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;64-redirection-3xx&quot;&gt;6.4. Redirection 3xx&lt;/h3&gt;
&lt;p&gt;상태 코드 3xx(Redirection) 등급은 요청을 이행하기 위해 사용자 에이전트의 추가 조치가 필요하다는 것을 나타낸다.
Location 헤더 필드가 제공되는 경우, 사용자 에이전트는 특정 상태 코드를 이해하지 못하더라도 Location 필드 값이 참조하는 URI로 요청을 자동으로 
리다이렉트 할 수 있다. 사용자가 안전하지 않은 요청을 리다이렉트 하기를 원하지 않을 수 있으므로, 안전하지 않은 메소드를 주의하여 자동 리다이렉트를 수행 해야 한다.&lt;/p&gt;

&lt;p&gt;리다이렉트의 유형&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;상태 코드 301(Moved Permanently), 302 (Found), 307(Temporary Redirect)과 같이 Location 필드에서 제공하는 대로 다른 URI에서 리소스를 사요할 수 있음을 나타내는 리다이렉트.&lt;/li&gt;
  &lt;li&gt;300 (Multiple Choices) 상태 코드에서와 같이 각각 원래의 요청 대상을 나타낼 수 있는 매칭 리소스의 선택을 제공하는 리다이렉트.&lt;/li&gt;
  &lt;li&gt;303 (See Other) 상태 코드에서와 같이 요청에 대한 간접적인 응답을 나타낼 수 있는 위치 필드로 실벽된 다른 리소스로의 리다이렉트&lt;/li&gt;
  &lt;li&gt;304 (Not Modified) 상태코드에서와 같이 이전에 캐시된 결과로 리다이렉트&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;참고 : HTTP/1.0에서는 첫 번째 리디렉션 유형에 대한 상태 코드 301, 302가 정의 되었다. 초기 사용자 에이전트는 리다이렉트 대상에 
적용된 메서드가 원래 요청과 같을 것인지 아니면 GET로 다시 작성될 것인지에 대해 분할 했다. HTTP 는 원래 301과 302에 대한 이전의 의미론을 정의하고 
303을 후자 의미론과 일치하도록 정의 했지만, 지배적인 관행은 301과 302에 대해서도 점차적으로 후자의 의미론에 융합되었다. 
HTTP/1.1의 첫 번째 개정은 307을 추가하여 다양한 관행에 영향을 받지 않고 이전의 의미론을 표시 하였다. 
10년이 지난 후에도 대부분의 사용자 에이전트는 여전히 301과 302에 대해 메서드 재작성을 한다. 
따라서 이 규격은 원래 요청이 POST 일 때 그러한 행동을 준수하도록 한다.
(301과 302는 요청 메서드와 달리 GET으로 다시 리다이렉트 하도록 의미를 가지고 307은 요청 메서드와 같은 메서드로 리다이렉트 하도록 의미를 가진다.)&lt;/p&gt;

&lt;p&gt;클라이언트는 주기적 리디렉션(리디렉션 루프)을 감지하고 개입해야 한다.&lt;/p&gt;

&lt;p&gt;참고 : 이 명세의 이전 버전에서는 최대 5개의 리디렉션을 권장했다. 컨텐츠 개발자들은 일부 클라이언트가 그러한 고정된 제한을 구현할 수 있다는것을 알아야 한다.&lt;/p&gt;

&lt;h3 id=&quot;641-300-multiple-choices&quot;&gt;6.4.1. 300 Multiple Choices&lt;/h3&gt;
&lt;p&gt;300 (Multiple Choices) 상태 코드는 대상 리소스가 각각 더 구체적인 식별자를 가진 둘 이상의 representation을 가지고 있음을 나타내며, 
사용자(또는 사용자 에이전트)가 해당 식별자 중 하나 이상으로 요청을 리디렉션하여 선호하는 representation을 선택할 수 있도록 대안에 대한 ㅈ어보가 제공되고 있다.
즉, 서버는 사용자 에이전트가 자신의 요구에 가장 적합한 표현을 선택하기 위해 reactive negotiation에 임하기를 바란다.&lt;/p&gt;

&lt;p&gt;서버에 기본 선택사항이 있는 경우, 서버는 기본 선택사항의 URI참조가 포함된 Location 헤더필드를 생성해야 한다. 
사용자 에이전트는 자동 리디렉션에 Location 필드 값을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 300 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;p&gt;참고 : 300 상태 코드에 대한 원래 제안에서는 URI 헤더 필드를 200, 300 및 406 응답에 사용할 수 있고 
HEAD 메서드에 대한 응답으로 이전할 수 있는 대체 표현 목록을 제공하는 것으로 정의 했다. 
그러나 배치 부족과 구문에 대한 의견 불일치로 인해 URI와 Alternates(이 후의 제안)가 이 명세에서 모두 삭제 되었다.
닭과 달걀의 문제지만 각 “대안”의 관계를 가진 Link 헤더필드 집합을 사용하여 목록을 전달할 수 있다.
(이 구문은 무슨 의미인지 잘 모르겠네요)&lt;/p&gt;

&lt;h3 id=&quot;642-301-moved-permanently&quot;&gt;6.4.2. 301 Moved Permanently&lt;/h3&gt;
&lt;p&gt;301 (Moven Permanently) 상태 코드는 대상 리소스에 새 영구 URI가 할당 되었으며 이 리소스에 대한 향후 참조는 
동봉된 URI 중 하나를 사용해야 함을 나타낸다. 링크 편집 기능을 가진 클라이언트는 가능한 경우, 
서버가 보낸 하나 이상의 새로운 참조에 유효한 요청 URI에 대한 참조로 자동으로 다시 연결 해야 한다.&lt;/p&gt;

&lt;p&gt;서버는 응답을 Location 헤더 필드에 새 영구 URI에 대한 기본 URI 참조를 포함하여 생성해야 한다. 
사용자 에이전트는 자동 리디렉션에 Location 필드 값을 사용할 수 있다.
서버의 응답 페이로드에는 일반적으로 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 노트가 포함되어 있다.&lt;/p&gt;

&lt;p&gt;참고 : 역사적 이유로, 사용자 에이전트는 후속 요청에 대한 요청 메서드를 POST에서 GET로 변경할 수 있다. 
이 동작이 원치 않으면 307 상태 코드를 대신 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 301 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;643-302-found&quot;&gt;6.4.3. 302 Found&lt;/h3&gt;
&lt;p&gt;302 (Found) 상태 코드는 대상 리소스가 일시적으로 다른 URI 아래에 있음을 나타낸다. 
리디렉션은 때때로 변경될 수 있으므로 클라이언트는 향후 요청에 대해 유효한 요청 URI를 계속 사용해야 한다.&lt;/p&gt;

&lt;p&gt;서버는 다른 URI에 대한 URI 참조가 포함된 응답에 Location 헤더 필드를 생성해야 한다. 
서버의 응답 페이로드에는 일반적으로 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 노트가 포함되어 있다.&lt;/p&gt;

&lt;p&gt;참고 : 역사적 이유로, 사용자 에이전트는 후속 요청에 대한 요청 메서드를 POST에서 GET로 변경할 수 있다. 
이 동작이 원치 않으면 307 상태 코드를 대신 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;644-303-see-other&quot;&gt;6.4.4. 303 See Other&lt;/h3&gt;
&lt;p&gt;303 (See Other) 상태 코드는 원래 요청에 대한 간접적인 응답을 제공하기 위해 서버가 사용자 에이전트를 
Location 헤더 필드의 URI가 표시한 다른 리소스로 리다이렉트 하고 있음을 나타낸다.
(클라이언트가 요청한 리소스를 다른 URI에서 GET 요청을 통해 얻어야 할 때, 서버가 클라이언트로 리디렉션 하라고 보내는 응답)
사용자 에이전트는 또한 리다이렉트 될 수 있는 URI(HTTP를 사용하는 경우 GET 또는 HEAD)를 대상으로 검색 요청을 수행하여 
최종 결과를 원래 요청에 대한 응답으로 제시할 수 있다. Location 헤더필드의 새 URI는 유효한 요청 URI와 동등한 것으로 간주 되지 않는다.&lt;/p&gt;

&lt;p&gt;이 상태 코드는 모든 HTTP 메서드에 적용된다. POST 동작의 출력이 사용자 에이전트를 선택한 리소스로 리디렉션하는 데 주로 사용됩니다. 
POST 응답에 해당하는 정보를 원래 요청과는 독립적으로 별도의 식별, 북마크 및 캐시할 수 있는 형식으로 제공하기 때문이다.&lt;/p&gt;

&lt;p&gt;GET 요청에 대한 303 응답은 원서버가 HTTP를 통해 서버에 의해 전송될 수 있는 대상 리소스의 representation을 가지고 있지 않음을 나타낸다. 
그러나 Location 필드 값은 다른 리소스에 대한 검색 요청을 하면 원래 대상 리소스를 나타내지 않고 수신자에게 유요
용한 representation이 될 수 있으므로 대상 리소스를 설명하는 리소스를 말한다. 
(예를 들면 업로드 동작 후 확인창, 로딩창으로 리디렉션, (업로드 중이니 리소스에 대한 응답을 못함) 내가 리소스를 가지고 있지 않고 리소스에 대한 설명을 하는곳으로 리디렉션)
나타낼 수 있는것, 적절한 표현, 유용한 설명의 질문에 대한 답변은 HTTP의 범위를 벗어난다는 것을 참고한다.&lt;/p&gt;

&lt;p&gt;HEAD 요청에 대한 응답을 제외하고, 303 응답의 표현에는 Location 헤더 필드에 제공된 동일한 URI 참조에 대한 하이퍼링크가 있는 짧은 
하이퍼텍스트 노트가 포함되어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;645-not-modified&quot;&gt;6.4.5 Not Modified&lt;/h3&gt;
&lt;p&gt;캐시를 목적으로 사용된다. 클라이언트에게 응답이 수정되지 않음을 알려주며, 클라이언트는 계속해서 응답의 캐시된 버전을 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;646-305-use-proxy&quot;&gt;6.4.6. 305 Use Proxy&lt;/h3&gt;
&lt;p&gt;305 (Use Proxy) 상태 코드는 이 명세의 이전 버전에서 정의되었으며 현재 더 이상 사용되지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;647-306-unused&quot;&gt;6.4.7. 306 Unused&lt;/h3&gt;
&lt;p&gt;306 (Unused) 상태 코드는 이 명세의 이전 버전에서 정의되었으며 현재 더 이상 사용되지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;648-307-temporary-redirect&quot;&gt;6.4.8. 307 Temporary Redirect&lt;/h3&gt;
&lt;p&gt;307(Temporary Redirect) 상태 코드는 대상 리소스가 일시적으로 다른 URI에 상주하고 있다는 것을 나타내며, 
사용자 에이전트는 해당 URI로 자동 리디렉션을 수행할 경우 요청 메서드를 변경 하면 안 된다. 리디렉션은 시간이 지남에 따라 
변경될 수 있으므로 클라이언트는 향후에 원래의 유효한 요청 URI를 게속 사용해야 한다.&lt;/p&gt;

&lt;p&gt;서버는 다른 URI에 대한 URI 참조가 포함된 응답에 Location 헤더 필드를 생성해야 한다. 
사용자 에이전트는 자동 리디렉션에 Location 필드 값을 사용할 수 있다. 서버의 응답 페이로드에는 일반적으로 다른 URI에 대한 
하이퍼링크가 포함된 짧은 하이퍼 텍스트 노트가 포함되어 있다.&lt;/p&gt;

&lt;p&gt;참고 : 이 상태 코드는 요청 메서드를 POST에서 GET으로 변경할 수 없다는 점을 제외하고 302(Found)와 유사하다.
이 명세는 301(Moved Permanent)과는 동등하지 않다 (이 목적을 위한 상태 코드 308 (Permanent Redirect))&lt;/p&gt;

&lt;h3 id=&quot;649-308-permanent-redirect&quot;&gt;6.4.9. 308 Permanent Redirect&lt;/h3&gt;
&lt;p&gt;308 (Permanent Redirect) 상태 코드는 301과 동등하며 요청 메소드와 리디렉션 메소드가 동일 해야한다.&lt;/p&gt;

&lt;h2 id=&quot;65-client-error-4xx&quot;&gt;6.5. Client Error 4xx&lt;/h2&gt;
&lt;p&gt;상태 코드의 4xx(Client Error) 등급은 클라이언트가 오류가 발생한 것으로 보인다는 것을 나타낸다. HEAD 요청에 응답하는 경우를 제외 하고, 
서버는 오류 상황 및 일시적 또는 영구적 조건의 설명이 포함된 표현을 보내야 한다. 이 상태 코드는 모든 요청 메서드에 적용할 수 있다.
사용자 에이전트는 사용자에게 포함된 표현을 표시해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;651-400-bad-request&quot;&gt;6.5.1. 400 Bad Request&lt;/h3&gt;
&lt;p&gt;400 (Bad Request) 상태 코드는 클라이언트의 오류로 인신되는 것(e.g 잘못된 요청 구문, 잘못된 요청 메시지 프레임, 또는 기만적인 요청 라우팅(기만적인게 뭐지?))로 
인해 서버가 요청을 처리할 수 없거나 처리할 수 없음을 나타낸다.&lt;/p&gt;

&lt;h3 id=&quot;652-401-unauthorized&quot;&gt;6.5.2. 401 Unauthorized&lt;/h3&gt;
&lt;p&gt;HTTP 표준에서는 “미승인”을 명확히 하고 있지만, 의미상 이 응답은 “비인증”을 의미한다. 클라이언트는 요청한 응답을 받기 위해서 자신을 인증해야 한다.
(미승인은 서버가 승인하지 않은것이고 비인증은 클라이언트가 인증을 거치지 않은 의미라고 생각하면 되나?)
WWW-Authenticate 헤더와 함께 정송되며, 이 헤더는 올바르게 인증하는 방법에 대한 정보를 포함하고 있다.&lt;/p&gt;

&lt;h3 id=&quot;653-402-payment-required&quot;&gt;6.5.3. 402 Payment Required&lt;/h3&gt;
&lt;p&gt;402 상태 코드는 향후 사용을 위해 예약되어있다. 아직은 사용되지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;654-403-forbidden&quot;&gt;6.5.4. 403 Forbidden&lt;/h3&gt;
&lt;p&gt;403 (Forbidden) 상태 코드는 서버가 요청을 이해했지만 승인을 거부함을 나타낸다. 요청이 금지된 이유를 공개하고자 하는 서버는, 
응답 페이로드에서 그 이유를 설명할 수 있다.&lt;/p&gt;

&lt;p&gt;요청에 인증 자격 증명이 제공된 경우, 서버는 인증 자격 증명이 엑세스 권한을 부여하기에 불충분하다고 간주한다. 
클라이언트는 동일한 자격증명으로 요청을 자동으로 반복해서는 안 된다. 클라이언트는 새 자격 증명 또는 다른 자격 증명으로 요청을 반복할 수 있다. 
그러나 인증 정보와 무관한 이유로 요청이 금지될 수 있다.
(403은 서버는 클라이언트를 승인하지 않는 거절을 표현하는 응답이다. 401과 다른점은 서버가 클라이언트가 누구인지 알고 있다.)&lt;/p&gt;

&lt;p&gt;금지된 대상 리소스의 현재 존재를 “hide” 원하는 원 서버는 대신 상태 코드 404 (Not Found)로 응답할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;655-404-not-found&quot;&gt;6.5.5. 404 Not Found&lt;/h3&gt;
&lt;p&gt;404 (Not Found) 상태 코드는 원서버가 대상 리소스에 대한 현재 representation을 찾지 못했거나 존재하는 것을 공개하지 않으려는 것을 나타낸다.
404 상태 코드는 이러한 representation 부족이 일시적인지 영구적인지를 나타내지 않는다. 
410(Gone) 상태코드는 원서버가 어떤 구성 가능한 수단을 통해 조건이 영구적일 가능성이 있다는 것을 알고 있는 경우 404보다 선호 된다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 404 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;656-405-method-not-allowed&quot;&gt;6.5.6. 405 Method Not Allowed&lt;/h3&gt;
&lt;p&gt;405(Method Not Allowed) 상태 코드는 request-line에 수신된 메서드가 원서버에 의해 알려져 있지만 대상 리소스에는 지원 되지 않음을 나타낸다. 
원서버는 대상 리소스의 현재 지원되는 메서드 목록을 포함하는 405 응답에 Allow 헤더 필드를 생성해야 한다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 405 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;657-406-not-acceptable&quot;&gt;6.5.7. 406 Not Acceptable&lt;/h3&gt;
&lt;p&gt;406 (Not Acceptable) 상태 코드는 요청에 수신된 proactive negotiation 헤더 필드에 따라 대상 리소스가 사용자 에이전트가 
수용할 수 있는 현재 representation을 가지고 있지 않으며, 서버가 기본 representation을 제공하지 않음을 나타낸다.&lt;/p&gt;

&lt;p&gt;서버는 사용자 또는 사용자 에이전트가 가장 적합한 것을 선택할 수 있는 사용 가능한 representation 특성 및 해당 리소스 식별자 목록을 
포함하는 페이로드를 생성해야 한다. 사용자 에이전트는 해당 목록에서 가장 적절한 선택을 자동으로 선택할 수 있다. 
그러나 이 명세는 그러한 자동 선택에 대한 표준을 정의하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;658-407-proxy-authentication-required&quot;&gt;6.5.8 407 Proxy Authentication Required&lt;/h3&gt;
&lt;p&gt;이것은 401과 비슷하지만 프록시에 의해 완료된 인증이 필요하다.
HTTP 407 Proxy Authentication Required 클라이언트 오류 상태 응답 코드는 요청 된 리소스에 
액세스 할 수있는 서버와 브라우저 사이에 있는 프록시 서버에 대한 유효한 인증 자격 증명이 없기 때문에 
요청이 적용되지 않았음을 나타낸다&lt;/p&gt;

&lt;p&gt;이 상태는 Proxy-Authenticate올바른 인증 방법에 대한 정보가 포함 된 헤더 와 함께 전송 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;659-408-request-timeout&quot;&gt;6.5.9. 408 Request Timeout&lt;/h3&gt;
&lt;p&gt;408 (Request Timeout) 상태 코드는 서버가 대기할 준비가 된 시간 내에 완전한 요청 메시지를 수신하지 않았음을 나타낸다. 
408은 서버가 계속 대기하기 보다는 커넥션을 종료하기로 결정하였음을 의미하므로, 서버는 응답으로 “close” 커넥션 옵션을 보내야 한다. 
클라이언트가 미결 요청을 가지고 있는 경우, 클라이언ㄴ트는 새로운 커넥션에서 해당 요청을 반복할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;6510-409-conflict&quot;&gt;6.5.10. 409 Conflict&lt;/h3&gt;
&lt;p&gt;409 (Conflict) 상태 코드는 대상 리소스의 현재 상태와 충돌하여 요청을 완료할 수 없음을 나타낸다. 
이 코드는 사용자가 충돌을 해결하고 요청을 다시 제출할 수 있는 상황에서 사용된다. 
서버는 사용자가 충돌의 원인을 인식하기에 충분한 정보를 포함하는 페이로드를 생성해야 한다.&lt;/p&gt;

&lt;p&gt;PUT 요청에 대응하여 충돌이 발생할 가능성이 가장 높다. 예를 들어 버전 지정이 사용 중이고 PUT에 있는 representation에 이전(서드 파티) 요청에 의해 
수행된 리소스와 충돌하는 리소스의 변경 사항이 포함된 경우, 원서버는 요청을 완료할 수 없음을 나타내기 위해 409 응답을 사용할 수 있다.
이 경우, 응답 representation에는 개정 이력에 기초한 차이를 병합하는데 유용한 정보가 포함될 수 있다.
(구버전에서 PUT으로 수정할 수 있는 리소스(ex, {‘name, age’})와 최신버전에서 PUT으로 수정할 수 있는 리소스(ex, {‘name’})이 다를때, 
구버전의 리소스로 최신버전 리소스의 PUT을 동작하면 (‘age’에 대한 내용으로 인해 충돌) 409를 반환하는 상황인듯.)&lt;/p&gt;

&lt;h3 id=&quot;6511-410-gone&quot;&gt;6.5.11. 410 Gone&lt;/h3&gt;
&lt;p&gt;410 (Gone) 상태 코드는 대상 리소스에 대한 엑세스를 원 서버에서 더 이상 사용할 수 없으며 
이 조건이 영구적일 가능성이 있음을 나타낸다. 원본 서버가 조건이 영구적인지 여부를 알 수 없거나 확인할 수 있는 기능이 없는 경우, 
대신에 상태 코드 404 (Not Found)를 사용해야 한다.&lt;/p&gt;

&lt;p&gt;410 응답은 주로 수신자에게 리소스를 의도적으로 사용할 수 없으며 서버 소유자가 해당 리소스에 대한 원격 링크를 제거하기를 원한다는 것을 통지함으로써 
웹 유지보수의 작업을 지원하기 위한 것이다. 이러한 이벤트는 제한된 시간의 홍보 서비스 및 원서버의 사이트와 더 이상 연관되지 않는 개인에 속하는 리소스에 대해 일반 적이다. 
영구적으로 사용할 수 없는 모든 리소스를 “gone”로 표시하거나 일정 시간 동안 표시를 유지할 필요는 없다.
이것은 서버 소유자의 재량이다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 410 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;6512-411-length-required&quot;&gt;6.5.12. 411 Length Required&lt;/h3&gt;
&lt;p&gt;411 (Length Required) 상태 코드는 Content-Length 포함되지 않은 요청을 거부함을 나타낸다. 
클라이언트 요청 메시지에 메시지 본문의 길이가 포함된 유효한 Content-Length 헤더 필드를 추가하는 경우 요청을 반복할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;6513-412-precondition-failed&quot;&gt;6.5.13. 412 Precondition Failed&lt;/h3&gt;
&lt;p&gt;클라이언트의 헤더에 있는 전제조건은 서버의 전제조건에 적절하지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;6513-413-payload-too-large&quot;&gt;6.5.13. 413 Payload Too Large&lt;/h3&gt;
&lt;p&gt;413 (Payload Too Large) 상태 코드는 요청 페이로드가 서버가 처리할 의향 또는 처리할 수 있는 능력보다 크기 때문에, 
서버가 요청을 거부함을 나타낸다. 서버는 클라이언트가 요청을 계속하지 못하도록 커넥션을 닫는다.&lt;/p&gt;

&lt;p&gt;일시적 조건인 경우 서버는 일시적임을 나타내기 위해 Retry-After 헤더 필드를 생성하여 클라이언트가 다시 시도할 수 있는 시간 이후를 표시 해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;6514-414-uri-too-long&quot;&gt;6.5.14. 414 URI Too Long&lt;/h3&gt;
&lt;p&gt;414 (URI Too Long) 상태 코드는 request-target이 서버가 해석하려는 것보다 길기 때문에 서버가 요청을 거부함을 나타낸다. 
이 조건은 클라이언트가 긴 쿼리 정보가 있는 GET 요청으로 POST 요청을 부적절하게 변환 했을 때, 
클라이언트가 “black hole” 리디렉션(예를 들어 자체 접미사를 가리키는 리다이렉트 URI 접두사)로 내려갔을 때, 
또는 서버가 잠재적인 보안 구멍을 이용하려고 시도하는 클라이언트의 공격을 받을 때에만 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 414 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;6515-415-unsupported-media-type&quot;&gt;6.5.15. 415 Unsupported Media Type&lt;/h3&gt;
&lt;p&gt;415 (Unsupported Media Type) 상태 코드는 대상 리소스에 대해 이 메서드로 지원하지 않는 형식의 페이로드가 있기 때문에, 
원서버가 요청을 거부함을 나타낸다. 형식 문제는 요청에 표현된 Content-Type 또는 Content-Encoding 또는 데이터를 직접 검사한 결과일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;6516-417-expectation-failed&quot;&gt;6.5.16. 417 Expectation Failed&lt;/h3&gt;
&lt;p&gt;417 (Expectation Failed) 상태 코드는 요청의 Expect 헤더 필드에 주어진 기대치를 인바운드 서버 중 하나 이상이 
충족할 수 없음을 나타낸다.&lt;/p&gt;

&lt;h3 id=&quot;6517-426-upgrade-required&quot;&gt;6.5.17. 426 Upgrade Required&lt;/h3&gt;
&lt;p&gt;426(Upgrade Required) 상태 코드는 서버가 현재 프로토콜을 사용하여 요청을 수행하기를 거부하지만 클라이언트가 다른 프로토콜로 
업그레이드한 후 요청을 수행할 의사가 있음을 나타낸다. 서버는 반드시 필요한 프로토콜을 나타내기 위해 426 응답으로 Upgrage 헤더 필드를 전송 해야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어 이 서비스는 HTTP/3.0 프로토콜 사용을 필요로 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-HTTP&quot;&gt;HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade 
Content-Length: 53 
Content-Type: text/plain
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;66-server-error-5xx&quot;&gt;6.6. Server Error 5xx&lt;/h2&gt;
&lt;p&gt;상태 코드의 5xx (Server Error) 등급은 서버가 요청된 메서드를 잘못했거나, 수행할 수 없음을 나타낸다.
HEAD 요청에 응답하는 경우를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 조건인지 영구적인 조건인지를 포함하는 
representation을 보내야 한다. 사용자 에이전트는 사용자에게 포함된 모든 representation을 표시해야 한다. 
이 응답 코드는 모든 요청 메서드에 적용 된다.&lt;/p&gt;

&lt;h3 id=&quot;661-500-internal-server-error&quot;&gt;6.6.1. 500 Internal Server Error&lt;/h3&gt;
&lt;p&gt;500 (Internal Server Error) 상태 코드는 서버가 요청을 이행하지 못하게 하는 예기치 않은 조건을 만났음을 나타낸다.&lt;/p&gt;

&lt;h3 id=&quot;662-501-not-implemented&quot;&gt;6.6.2. 501 Not Implemented&lt;/h3&gt;
&lt;p&gt;501 (Not Implemented) 상태 코드는 서버가 요청을 이행하는데 필요한 기능을 지원하지 않음을 나타낸다. 
이것은 서버가 요청 메서드를 인식하지 못하고 어떤 리소스에도 그것을 지원할 수 없을 때 적절한 대응이다.&lt;/p&gt;

&lt;p&gt;메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 501 응답은 캐시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;663-502-bad-gateway&quot;&gt;6.6.3. 502 Bad Gateway&lt;/h3&gt;
&lt;p&gt;502 (Bad Gateway) 상태 코드는 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 이행하는 중 
엑세스한 인바운드 서버로 부터 잘못된 응답을 수신했음을 나타낸다.&lt;/p&gt;

&lt;h3 id=&quot;664-503-service-unavailable&quot;&gt;6.6.4. 503 Service Unavailable&lt;/h3&gt;
&lt;p&gt;503 (Service Unavailable) 상태 코드는 서버가 현재 일시적인 과부하 또는 예정된 유지보수로 인해 요청을 처리할 수 없음을 나타내며, 
어느 정도 지연된 후에 완화될 가능성이 높다. 서버는 Retry-After 헤더필드를 보내 클라이언트가 요청을 재시도하기 전에 대기할 시간을 제안할 수 있다.&lt;/p&gt;

&lt;p&gt;참고: 503 상태 코드가 존재한다고 해서 서버가 과부하가 걸렸을 때 이를 사용해야 하는 것은 아니다. 일부 서버는 단순히 커넥션을 거부할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;665-504-gateway-timeout&quot;&gt;6.6.5. 504 Gateway Timeout&lt;/h3&gt;
&lt;p&gt;504 (Gateway Timeout) 상태 코드는 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 완료하기 위해 엑세스해야 하는 업스트림 서버로 부터 
적시에 응답을 받지 못했음(지정한 시간 제한을 초과함)을 나타낸다.
&lt;a href=&quot;https://blog.lael.be/post/9251&quot;&gt;추가 설명&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;666-505-http-version-not-supported&quot;&gt;6.6.6. 505 HTTP Version Not Supported&lt;/h3&gt;
&lt;p&gt;505 (HTTP Version Not Supported) 상태 코드는 서버가 요청 메시지에 사용된 HTTP의 주요 버전을 지원하지 않거나 지원을 거부함을 나타낸다. 
서버는 오류 메시지를 제외하고 클라이언트와 동일한 주요 버전을 사용하여 요청을 완료할 수 없거나 요청을 완료할 의사가 없음을 나타내고 있다. 
서버는 해당 버전이 지원되지 않는 이유와 해당 서버에서 지원하는 다른 프로토콜을 설명하는 505 응답에 대한 표현을 생성해야 한다.&lt;/p&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="http" /><category term="Web" /><category term="HTTP1.1" /><summary type="html">참고 자료 이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본 https://roka88.dev/106 MDN Web Docs https://developer.mozilla.org/ko/docs/Web/HTTP 이외 자료는 내용 중 링크 추가 틀린 내용, 부족한 내용 꼭 지적 부탁드립니다! 6. Response Status Codes status-code 요소는 요청을 이해하고 충족시키려는 시도의 결과를 제공하는 세 자리 정수 코드다. HTTP 상태 코드는 확장 가능하다. HTTP 클라이언트는 등록된 모든 상태 코드의 의미를 이해 할 필요는 없지만, 그러한 이해는 분명히 바람직하다. 그러나 클라이언트는 첫 번째 숫자로 표시된 상태 코드의 클래스를 이해하고 인식되지 않는 상태 코드를 해당 클래스의 x00 상태 코드에 해당하는 것으로 취급해야 하며, 단, 수신자는 인식되지 않는 상태 코드로 응답을 캐시하면 안 된다는 점을 제외한다. 예를 들어, 인식되지 않는 상태 코드 471이 클라이언트에 의해 수신된 경우, 클라이언트는 자신의 요청에 이상이 있다고 가정하고, 응답은 400(Bad Request) 상태 코드를 받은 것처럼 취급할 수 있다. 응답 메시지에는 일반적으로 상태를 설명하는 representation이 포함될 것이다. 상태 코드의 첫 번째 자릿수는 응답 클래스를 정의한다. 마지막 두 자리에는 분류 역할이 없다(마지막 두 자리가 어떠한 의미로 분류되지 않음). 첫번째 자리에는 다섯 개의 값이 있다. 1xx(Informational) : 요청이 수신되어 프로세스가 계속 진행됨 2xx(Successful) : 요청이 성공적으로 수신, 이해 및 수락됨 3xx(Redirection) : 요청을 완료하려면 추가 조치를 취해야함 4xx(Client Error) : 요청에 잘못된 구문이 포함되어 있거나 충족할 수 없음 (요청 자체가 잘못됐을때) 5xx(Server Error) : 서버가 유효한 요청을 수행하지 못함(요청은 올바른데 서버에서 처리를 못할때) 6.1. Overview of Status Codes 아래에 나열된 상태 코드의 Reason-Phrase는 권장 사항일 뿐이며 프로토콜에 영향을 주지 않고 로컬 등가물(이게 뭔말이지)로 대체 될 수 있다. 기본적으로 캐시 가능한 상태 코드(이 명세는 200, 203, 206, 300, 301, 404, 405, 410, 414, 501)가 있는 응답은 메서드 정의나 명시적 캐시 제어[RFC7234 5.2 참고]로 달리 명시되지 않는 한 경험적 접근 만료를 가진 캐시에서 재사용할 수 있으며, 다른 모든 상태 코드는 기본적으로 캐시 가능하지 않다. Code Reason-Phrase 100 Continue 101 Switching Protocols 200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 305 Use Proxy 307 Temporary Redirect 400 Bad Request 401 Unauthorized 402 Payment Required 403 Forbidden 404 Not Found 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conlict 410 Gone 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 417 Expectation Failed 426 Upgrade Required 500 Internal Server Error 501 Not Implemented 502 Bad GateWay 503 Service Unavailable 504 Gateway Timeout 505 HTTP Version Not Supported 이 목록은 모든 상태코드를 나타내는것은 아니며, 다른 사양에 정의된 확장 상태 코드를 포함하지 않고 있다. 상태 코드의 전체 목록은 IANA에 의해 유지 된다. 6.2. Informational 1xx 1xx (Informational) 등급의 상태 코드는 요청된 조치를 완료하고 최종 응답을 보내기 전에 커넥션 상태 또는 요청 진행 상황을 전달하기 위한 중간 응답을 나타낸다. 1xx 응답은 status-line(헤더 부문의 끝을 알리는 빈 라인) 후 첫 번째 빈 라인에 의해 종료 된다. HTTP/1.0은 1xx 상태 코드를 정의하지 않았으므로 서버는 1xx 응답을 HTTP/1.0 클라이언트에 전송해서는 안 된다. 클라이언트는 최종 응답 전에 받은 1xx 응답 중 하나 이상을 구문 분석할 수 있어야 한다. 사용자 에이전트는 예기치 않은 1xx 응답을 무시할 수 있다. 프록시 자체가 1xx 응답 생성을 요청하지 않는 한 프록시는 1xx 응답을 전달해야 한다. 예를 들어, 요청을 전달할 때 프록시가 “Expect:100-continue” 필드를 추가하는 경우, 해당 100(Continue) 응답을 전송할 필요가 없다. 6.2.1. 100 Continue 100 (Continue) 상태 코드는 요청의 초기 부분이 수신되어 아직 서버에서 거부되지 않았음을 나타낸다. 서버는 요청이 완전히 접수되고 조치된 후 최종 응답을 보내려고 한다. 요청이 100-continue를 포함하는 Expect 헤더 필드를 포함할 경우, 100 응답은 서버가 요청 페이로드 본문을 수신하기를 원함을 나타낸다. 클라이언트는 요청을 계속 보내고 100 응답을 폐기해야 한다. 요청이 100-continue를 포함하는 Expect 헤더 필드를 포함하지 않은 경우, 클라이언트는 이 중간 응답을 간단히 폐기할 수 있다. 6.2.2. 101 Switching Protocols 101 (Switching Protocols) 상태 코드는 서버가 이 커넥션에 사용되는 어플리케이션 프로콜의 변경에 대해 Upgrage 헤더 필드를 통해 클라이언트의 요청을 이해하고 이를 준수할 의사가 있음을 나타낸다. 서버는 101 응답과 전환할 프로토콜을 나타내는 Upgrage 헤더 필드를 생성해야 한다. 서버가 프로토콜 전환에 유리한 경우에만 동의할 것으로 가정한다. 예를 들어, 이전 버전보다 새로운 버전의 HTTP로 전환하는 것이 유리할 수 있으며, 이러한 기능을 사용하는 리소스를 제공할 때 실시간 동기식 프로토콜로 전환하는 것이 유리할 수 있다. 6.3. Successful 2xx 2xx (Successful) 등급의 상태 코드는 클라이언트의 요청이 성공적으로 수신, 이해 및 수용되었음을 나타낸다. 6.3.1. 200 OK 200 (OK) 상태 코드는 요청이 성공했음을 나타낸다. 200개의 응답으로 전송되는 페이로드는 요청 메소드에 따라 달라진다. 이 명세에 의해 정의된 메서드에 대해, 페이로드의 의도된 의미는 다음과 같이 요약할 수 있다. GET : 대상 리소스의 representation HEAD : GET와 동일한 representation이지만 representation 데이터가 없는 경우. POST : 원하는 동작에 대한 조치 상태 또는 결과 표시 PUT, DELETE : 조치 상태 표시 OPTIONS : 통신 옵션의 표시 TRACE : 엔드서버에서 수신한 요청 메시지의 representation CONNECT에 대한 응답 외에도 , 200의 응답은 항상 페이로드를 가지고 있지만, 원 서버는 0의 길이의 페이로드 본문을 생성할 수 있다. 페이로드가 필요 없는 경우, 원서버는 대신 204 (No content)를 전송해야 한다. CONNECT의 경우, 성공적인 결과가 200 응답 헤더 부문 직후에 시작되는 터널이기 때문에 페이로드가 허용되지 않는다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 200 응답은 캐시할 수 있다. 6.3.2. 201 Created 201 (Created) 상태 코드는 요청이 이행되어 하나 이상의 새로운 리소스가 생성되었음을 나타낸다. 요청에 의해 생성된 기본 리소스는 응답의 Location 헤더 필드를 통해 식별하며, 수신된 Location 필드가 없는 경우 유효한 요청 URI를 통해 식별된다. 201 응답 페이로드에는 일반적으로 생성된 리소스가 설명되고 링크된다. 6.3.3. 202 Accepted 202 (Accepted) 상태 코드는 요청이 접수되었으나 처리가 완료되지 않았음을 표시한다. (요청을 받았지만 아직 수행되지 않은 상태. 요청을 일괄적으로 받고 나중에 처리할 때 이 상태코드 반환하면 될듯) 요청은 실제로 처리될 때 허용되지 않을 수 있기 때문에 결국 실행될 수도 있고 실행되지 않을 수도 있다. HTTP에는 비동기 작업에서 상태 코드를 재전송할 수 있는 기능이 없다. 202 응답은 의도적으로 모호하다. 그 목적은 프로세스가 완료될 때까지 사용자 에이전트의 서버 연결이 지속되지 않아도 되며 서버가 다른 프로세스(아마도 하루에 한번만 실행되는 배치 지향 프로세스)에 대한 요청을 수락하도록 허용하는 것입니다. 이 응답과 함께 전송되는 representation은 요청의 현재 상태를 기술해야 하며, 사용자에게 요청 이행 시기에 대한 추정치를 제공할 수 있는 상태 감시를 나타내거나 포함해야 한다. 6.3.4. 203 Non-Authoritative Information 203 (Non-Authoritative Inforamtion) 상태 코드는 요청이 성공적이었으나, 변환 프록시에 의해 원서버의 200(OK) 응답으로 부터 포함된 페이로드가 수정되었음을 나타낸다. 이 상태 코드는 변환이 적용되면 해당 정보가 컨텐츠에 대한 이후 결정에 영향을 미칠 수 있으므로 프록시가 수신자에게 통지할 수 있다. 예를 들어 컨텐츠에 대한 향후 캐시 유효성 검사 요청은 동일한 요청 경로(동일한 프록시를 통해)를 통해서만 적용할 수 있다. 203 응답은 어떤 상태 코드로든 응답에 적용할 수 있다는 장점이 있는 214 Transformation Apply의 Warning 코드와 유사하다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 203 응답은 캐시할 수 있다. 6.3.5. 204 No Content 204 (No Content) 상태 코드는 서버가 요청을 성공적으로 이행 했으며 응답 페이로드 본문으로 보낼 추가 컨텐츠가 없음을 나타낸다. 응답 헤더 필드의 메타 데이터는 요청된 작업이 적용된 후 대상 리소스와 선택된 representation을 가리킨다. 예를 들어, PUT 요청에 대한 응답으로 204 상태 코드가 수신되고 응답에 Etag 헤더 필드가 포함된 경우 PUT은 성공했으며 ETage field-value는 대상 리소스의 새로운 representation을 위한 entitiy-tage가 포함되어 있다. 204 응답은 서버가 대상 리소스에 작업이 성공적으로 적용되었음을 나타내는 동시에 사용자가 에이전트가 현재 “document view”(있는 경우)에서 벗어날 필요가 없음을 암시한다. 서버는 사용자 에이전트가 자신의 인터페이스와 일치하여 그 사용자에게 성공에 대한 어떤 표시를 제공할 것으로 가정하고, 그 활성 representation에 대한 응답으로 새로운 메타 데이터나 업데이트된 메타 데이터를 적용한다. 예를 들어, 204 상태 코드는 일반적으로 “save” 작업에 해당하는 문서 편집 인터페이스와 함께 사용되어, 저장 중인 문서가 사용자가 편집할 수 있도록 유지 된다. 또한 분산 버전 제어 시스템 내에서 처럼 자동화된 데이터 전송이 보편화될 것으로 예상하는 인터페이스에서도 자주 사용된다. 204 응답은 메시지 본문을 포함할 수 없기 때문에 헤더 필드 뒤에 있는 첫번 째 빈 줄에 의해 종료 된다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 204 응답은 캐시할 수 있다. 6.3.6. 205 Reset Content 205 (Reset Content) 상태 코드는 서버가 요청을 이행했음을 나타내며, 사용자 에이전트가 요청을 보낸 “document view”를 리셋하라고 알린다. 이 응답은 사용자가 데이터 엔트리(폼, 노트패드, 캔버스 등)를 지원하는 콘텐츠를 수신하고, 그 공간에서 데이터를 입력하거나 조작하고, 입력된 데이터를 요청으로 제출하게 한 후, 다음 입력에 대해 데이터 입력 메니즘을 재설정하여 사용자가 다른 입력 작업을 쉽게 시작할 수 있도록 하는 공통 데이터 입력 사용 사례를 지원하기 위한 것이다. 205 상태 코드는 추가 콘텐츠가 제공되지 않음을 의미하므로 서버는 205 응답에서 페이로드를 생성해서는 안 된다. 즉, 서버는 205 응답에 대해 다음 중 하나를 수행해야 한다. 값이 0인 Content-Length 헤더 필드를 포함하여 응답의 길이가 0인 본문을 나타내라 청크 값을 가진 Transfer-Encoding 헤더 필드와 0 길이의 단일 청크로 구성된 메시지 본문을 포함하여 응답에 대한 0 길이의 페이로드로 나타내라 (청크란 한 덩어리로 데이터를 보내지 않고 나눠서 보내는 것) 헤더 부분을 종료하는 빈줄을 보낸 후 즉시 커넥션을 닫아라. 6.4. Redirection 3xx 상태 코드 3xx(Redirection) 등급은 요청을 이행하기 위해 사용자 에이전트의 추가 조치가 필요하다는 것을 나타낸다. Location 헤더 필드가 제공되는 경우, 사용자 에이전트는 특정 상태 코드를 이해하지 못하더라도 Location 필드 값이 참조하는 URI로 요청을 자동으로 리다이렉트 할 수 있다. 사용자가 안전하지 않은 요청을 리다이렉트 하기를 원하지 않을 수 있으므로, 안전하지 않은 메소드를 주의하여 자동 리다이렉트를 수행 해야 한다. 리다이렉트의 유형 상태 코드 301(Moved Permanently), 302 (Found), 307(Temporary Redirect)과 같이 Location 필드에서 제공하는 대로 다른 URI에서 리소스를 사요할 수 있음을 나타내는 리다이렉트. 300 (Multiple Choices) 상태 코드에서와 같이 각각 원래의 요청 대상을 나타낼 수 있는 매칭 리소스의 선택을 제공하는 리다이렉트. 303 (See Other) 상태 코드에서와 같이 요청에 대한 간접적인 응답을 나타낼 수 있는 위치 필드로 실벽된 다른 리소스로의 리다이렉트 304 (Not Modified) 상태코드에서와 같이 이전에 캐시된 결과로 리다이렉트 참고 : HTTP/1.0에서는 첫 번째 리디렉션 유형에 대한 상태 코드 301, 302가 정의 되었다. 초기 사용자 에이전트는 리다이렉트 대상에 적용된 메서드가 원래 요청과 같을 것인지 아니면 GET로 다시 작성될 것인지에 대해 분할 했다. HTTP 는 원래 301과 302에 대한 이전의 의미론을 정의하고 303을 후자 의미론과 일치하도록 정의 했지만, 지배적인 관행은 301과 302에 대해서도 점차적으로 후자의 의미론에 융합되었다. HTTP/1.1의 첫 번째 개정은 307을 추가하여 다양한 관행에 영향을 받지 않고 이전의 의미론을 표시 하였다. 10년이 지난 후에도 대부분의 사용자 에이전트는 여전히 301과 302에 대해 메서드 재작성을 한다. 따라서 이 규격은 원래 요청이 POST 일 때 그러한 행동을 준수하도록 한다. (301과 302는 요청 메서드와 달리 GET으로 다시 리다이렉트 하도록 의미를 가지고 307은 요청 메서드와 같은 메서드로 리다이렉트 하도록 의미를 가진다.) 클라이언트는 주기적 리디렉션(리디렉션 루프)을 감지하고 개입해야 한다. 참고 : 이 명세의 이전 버전에서는 최대 5개의 리디렉션을 권장했다. 컨텐츠 개발자들은 일부 클라이언트가 그러한 고정된 제한을 구현할 수 있다는것을 알아야 한다. 6.4.1. 300 Multiple Choices 300 (Multiple Choices) 상태 코드는 대상 리소스가 각각 더 구체적인 식별자를 가진 둘 이상의 representation을 가지고 있음을 나타내며, 사용자(또는 사용자 에이전트)가 해당 식별자 중 하나 이상으로 요청을 리디렉션하여 선호하는 representation을 선택할 수 있도록 대안에 대한 ㅈ어보가 제공되고 있다. 즉, 서버는 사용자 에이전트가 자신의 요구에 가장 적합한 표현을 선택하기 위해 reactive negotiation에 임하기를 바란다. 서버에 기본 선택사항이 있는 경우, 서버는 기본 선택사항의 URI참조가 포함된 Location 헤더필드를 생성해야 한다. 사용자 에이전트는 자동 리디렉션에 Location 필드 값을 사용할 수 있다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 300 응답은 캐시할 수 있다. 참고 : 300 상태 코드에 대한 원래 제안에서는 URI 헤더 필드를 200, 300 및 406 응답에 사용할 수 있고 HEAD 메서드에 대한 응답으로 이전할 수 있는 대체 표현 목록을 제공하는 것으로 정의 했다. 그러나 배치 부족과 구문에 대한 의견 불일치로 인해 URI와 Alternates(이 후의 제안)가 이 명세에서 모두 삭제 되었다. 닭과 달걀의 문제지만 각 “대안”의 관계를 가진 Link 헤더필드 집합을 사용하여 목록을 전달할 수 있다. (이 구문은 무슨 의미인지 잘 모르겠네요) 6.4.2. 301 Moved Permanently 301 (Moven Permanently) 상태 코드는 대상 리소스에 새 영구 URI가 할당 되었으며 이 리소스에 대한 향후 참조는 동봉된 URI 중 하나를 사용해야 함을 나타낸다. 링크 편집 기능을 가진 클라이언트는 가능한 경우, 서버가 보낸 하나 이상의 새로운 참조에 유효한 요청 URI에 대한 참조로 자동으로 다시 연결 해야 한다. 서버는 응답을 Location 헤더 필드에 새 영구 URI에 대한 기본 URI 참조를 포함하여 생성해야 한다. 사용자 에이전트는 자동 리디렉션에 Location 필드 값을 사용할 수 있다. 서버의 응답 페이로드에는 일반적으로 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 노트가 포함되어 있다. 참고 : 역사적 이유로, 사용자 에이전트는 후속 요청에 대한 요청 메서드를 POST에서 GET로 변경할 수 있다. 이 동작이 원치 않으면 307 상태 코드를 대신 사용할 수 있다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 301 응답은 캐시할 수 있다. 6.4.3. 302 Found 302 (Found) 상태 코드는 대상 리소스가 일시적으로 다른 URI 아래에 있음을 나타낸다. 리디렉션은 때때로 변경될 수 있으므로 클라이언트는 향후 요청에 대해 유효한 요청 URI를 계속 사용해야 한다. 서버는 다른 URI에 대한 URI 참조가 포함된 응답에 Location 헤더 필드를 생성해야 한다. 서버의 응답 페이로드에는 일반적으로 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 노트가 포함되어 있다. 참고 : 역사적 이유로, 사용자 에이전트는 후속 요청에 대한 요청 메서드를 POST에서 GET로 변경할 수 있다. 이 동작이 원치 않으면 307 상태 코드를 대신 사용할 수 있다. 6.4.4. 303 See Other 303 (See Other) 상태 코드는 원래 요청에 대한 간접적인 응답을 제공하기 위해 서버가 사용자 에이전트를 Location 헤더 필드의 URI가 표시한 다른 리소스로 리다이렉트 하고 있음을 나타낸다. (클라이언트가 요청한 리소스를 다른 URI에서 GET 요청을 통해 얻어야 할 때, 서버가 클라이언트로 리디렉션 하라고 보내는 응답) 사용자 에이전트는 또한 리다이렉트 될 수 있는 URI(HTTP를 사용하는 경우 GET 또는 HEAD)를 대상으로 검색 요청을 수행하여 최종 결과를 원래 요청에 대한 응답으로 제시할 수 있다. Location 헤더필드의 새 URI는 유효한 요청 URI와 동등한 것으로 간주 되지 않는다. 이 상태 코드는 모든 HTTP 메서드에 적용된다. POST 동작의 출력이 사용자 에이전트를 선택한 리소스로 리디렉션하는 데 주로 사용됩니다. POST 응답에 해당하는 정보를 원래 요청과는 독립적으로 별도의 식별, 북마크 및 캐시할 수 있는 형식으로 제공하기 때문이다. GET 요청에 대한 303 응답은 원서버가 HTTP를 통해 서버에 의해 전송될 수 있는 대상 리소스의 representation을 가지고 있지 않음을 나타낸다. 그러나 Location 필드 값은 다른 리소스에 대한 검색 요청을 하면 원래 대상 리소스를 나타내지 않고 수신자에게 유요 용한 representation이 될 수 있으므로 대상 리소스를 설명하는 리소스를 말한다. (예를 들면 업로드 동작 후 확인창, 로딩창으로 리디렉션, (업로드 중이니 리소스에 대한 응답을 못함) 내가 리소스를 가지고 있지 않고 리소스에 대한 설명을 하는곳으로 리디렉션) 나타낼 수 있는것, 적절한 표현, 유용한 설명의 질문에 대한 답변은 HTTP의 범위를 벗어난다는 것을 참고한다. HEAD 요청에 대한 응답을 제외하고, 303 응답의 표현에는 Location 헤더 필드에 제공된 동일한 URI 참조에 대한 하이퍼링크가 있는 짧은 하이퍼텍스트 노트가 포함되어야 한다. 6.4.5 Not Modified 캐시를 목적으로 사용된다. 클라이언트에게 응답이 수정되지 않음을 알려주며, 클라이언트는 계속해서 응답의 캐시된 버전을 사용할 수 있다. 6.4.6. 305 Use Proxy 305 (Use Proxy) 상태 코드는 이 명세의 이전 버전에서 정의되었으며 현재 더 이상 사용되지 않는다. 6.4.7. 306 Unused 306 (Unused) 상태 코드는 이 명세의 이전 버전에서 정의되었으며 현재 더 이상 사용되지 않는다. 6.4.8. 307 Temporary Redirect 307(Temporary Redirect) 상태 코드는 대상 리소스가 일시적으로 다른 URI에 상주하고 있다는 것을 나타내며, 사용자 에이전트는 해당 URI로 자동 리디렉션을 수행할 경우 요청 메서드를 변경 하면 안 된다. 리디렉션은 시간이 지남에 따라 변경될 수 있으므로 클라이언트는 향후에 원래의 유효한 요청 URI를 게속 사용해야 한다. 서버는 다른 URI에 대한 URI 참조가 포함된 응답에 Location 헤더 필드를 생성해야 한다. 사용자 에이전트는 자동 리디렉션에 Location 필드 값을 사용할 수 있다. 서버의 응답 페이로드에는 일반적으로 다른 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼 텍스트 노트가 포함되어 있다. 참고 : 이 상태 코드는 요청 메서드를 POST에서 GET으로 변경할 수 없다는 점을 제외하고 302(Found)와 유사하다. 이 명세는 301(Moved Permanent)과는 동등하지 않다 (이 목적을 위한 상태 코드 308 (Permanent Redirect)) 6.4.9. 308 Permanent Redirect 308 (Permanent Redirect) 상태 코드는 301과 동등하며 요청 메소드와 리디렉션 메소드가 동일 해야한다. 6.5. Client Error 4xx 상태 코드의 4xx(Client Error) 등급은 클라이언트가 오류가 발생한 것으로 보인다는 것을 나타낸다. HEAD 요청에 응답하는 경우를 제외 하고, 서버는 오류 상황 및 일시적 또는 영구적 조건의 설명이 포함된 표현을 보내야 한다. 이 상태 코드는 모든 요청 메서드에 적용할 수 있다. 사용자 에이전트는 사용자에게 포함된 표현을 표시해야 한다. 6.5.1. 400 Bad Request 400 (Bad Request) 상태 코드는 클라이언트의 오류로 인신되는 것(e.g 잘못된 요청 구문, 잘못된 요청 메시지 프레임, 또는 기만적인 요청 라우팅(기만적인게 뭐지?))로 인해 서버가 요청을 처리할 수 없거나 처리할 수 없음을 나타낸다. 6.5.2. 401 Unauthorized HTTP 표준에서는 “미승인”을 명확히 하고 있지만, 의미상 이 응답은 “비인증”을 의미한다. 클라이언트는 요청한 응답을 받기 위해서 자신을 인증해야 한다. (미승인은 서버가 승인하지 않은것이고 비인증은 클라이언트가 인증을 거치지 않은 의미라고 생각하면 되나?) WWW-Authenticate 헤더와 함께 정송되며, 이 헤더는 올바르게 인증하는 방법에 대한 정보를 포함하고 있다. 6.5.3. 402 Payment Required 402 상태 코드는 향후 사용을 위해 예약되어있다. 아직은 사용되지 않는다. 6.5.4. 403 Forbidden 403 (Forbidden) 상태 코드는 서버가 요청을 이해했지만 승인을 거부함을 나타낸다. 요청이 금지된 이유를 공개하고자 하는 서버는, 응답 페이로드에서 그 이유를 설명할 수 있다. 요청에 인증 자격 증명이 제공된 경우, 서버는 인증 자격 증명이 엑세스 권한을 부여하기에 불충분하다고 간주한다. 클라이언트는 동일한 자격증명으로 요청을 자동으로 반복해서는 안 된다. 클라이언트는 새 자격 증명 또는 다른 자격 증명으로 요청을 반복할 수 있다. 그러나 인증 정보와 무관한 이유로 요청이 금지될 수 있다. (403은 서버는 클라이언트를 승인하지 않는 거절을 표현하는 응답이다. 401과 다른점은 서버가 클라이언트가 누구인지 알고 있다.) 금지된 대상 리소스의 현재 존재를 “hide” 원하는 원 서버는 대신 상태 코드 404 (Not Found)로 응답할 수 있다. 6.5.5. 404 Not Found 404 (Not Found) 상태 코드는 원서버가 대상 리소스에 대한 현재 representation을 찾지 못했거나 존재하는 것을 공개하지 않으려는 것을 나타낸다. 404 상태 코드는 이러한 representation 부족이 일시적인지 영구적인지를 나타내지 않는다. 410(Gone) 상태코드는 원서버가 어떤 구성 가능한 수단을 통해 조건이 영구적일 가능성이 있다는 것을 알고 있는 경우 404보다 선호 된다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 404 응답은 캐시할 수 있다. 6.5.6. 405 Method Not Allowed 405(Method Not Allowed) 상태 코드는 request-line에 수신된 메서드가 원서버에 의해 알려져 있지만 대상 리소스에는 지원 되지 않음을 나타낸다. 원서버는 대상 리소스의 현재 지원되는 메서드 목록을 포함하는 405 응답에 Allow 헤더 필드를 생성해야 한다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 405 응답은 캐시할 수 있다. 6.5.7. 406 Not Acceptable 406 (Not Acceptable) 상태 코드는 요청에 수신된 proactive negotiation 헤더 필드에 따라 대상 리소스가 사용자 에이전트가 수용할 수 있는 현재 representation을 가지고 있지 않으며, 서버가 기본 representation을 제공하지 않음을 나타낸다. 서버는 사용자 또는 사용자 에이전트가 가장 적합한 것을 선택할 수 있는 사용 가능한 representation 특성 및 해당 리소스 식별자 목록을 포함하는 페이로드를 생성해야 한다. 사용자 에이전트는 해당 목록에서 가장 적절한 선택을 자동으로 선택할 수 있다. 그러나 이 명세는 그러한 자동 선택에 대한 표준을 정의하지 않는다. 6.5.8 407 Proxy Authentication Required 이것은 401과 비슷하지만 프록시에 의해 완료된 인증이 필요하다. HTTP 407 Proxy Authentication Required 클라이언트 오류 상태 응답 코드는 요청 된 리소스에 액세스 할 수있는 서버와 브라우저 사이에 있는 프록시 서버에 대한 유효한 인증 자격 증명이 없기 때문에 요청이 적용되지 않았음을 나타낸다 이 상태는 Proxy-Authenticate올바른 인증 방법에 대한 정보가 포함 된 헤더 와 함께 전송 됩니다. 6.5.9. 408 Request Timeout 408 (Request Timeout) 상태 코드는 서버가 대기할 준비가 된 시간 내에 완전한 요청 메시지를 수신하지 않았음을 나타낸다. 408은 서버가 계속 대기하기 보다는 커넥션을 종료하기로 결정하였음을 의미하므로, 서버는 응답으로 “close” 커넥션 옵션을 보내야 한다. 클라이언트가 미결 요청을 가지고 있는 경우, 클라이언ㄴ트는 새로운 커넥션에서 해당 요청을 반복할 수 있다. 6.5.10. 409 Conflict 409 (Conflict) 상태 코드는 대상 리소스의 현재 상태와 충돌하여 요청을 완료할 수 없음을 나타낸다. 이 코드는 사용자가 충돌을 해결하고 요청을 다시 제출할 수 있는 상황에서 사용된다. 서버는 사용자가 충돌의 원인을 인식하기에 충분한 정보를 포함하는 페이로드를 생성해야 한다. PUT 요청에 대응하여 충돌이 발생할 가능성이 가장 높다. 예를 들어 버전 지정이 사용 중이고 PUT에 있는 representation에 이전(서드 파티) 요청에 의해 수행된 리소스와 충돌하는 리소스의 변경 사항이 포함된 경우, 원서버는 요청을 완료할 수 없음을 나타내기 위해 409 응답을 사용할 수 있다. 이 경우, 응답 representation에는 개정 이력에 기초한 차이를 병합하는데 유용한 정보가 포함될 수 있다. (구버전에서 PUT으로 수정할 수 있는 리소스(ex, {‘name, age’})와 최신버전에서 PUT으로 수정할 수 있는 리소스(ex, {‘name’})이 다를때, 구버전의 리소스로 최신버전 리소스의 PUT을 동작하면 (‘age’에 대한 내용으로 인해 충돌) 409를 반환하는 상황인듯.) 6.5.11. 410 Gone 410 (Gone) 상태 코드는 대상 리소스에 대한 엑세스를 원 서버에서 더 이상 사용할 수 없으며 이 조건이 영구적일 가능성이 있음을 나타낸다. 원본 서버가 조건이 영구적인지 여부를 알 수 없거나 확인할 수 있는 기능이 없는 경우, 대신에 상태 코드 404 (Not Found)를 사용해야 한다. 410 응답은 주로 수신자에게 리소스를 의도적으로 사용할 수 없으며 서버 소유자가 해당 리소스에 대한 원격 링크를 제거하기를 원한다는 것을 통지함으로써 웹 유지보수의 작업을 지원하기 위한 것이다. 이러한 이벤트는 제한된 시간의 홍보 서비스 및 원서버의 사이트와 더 이상 연관되지 않는 개인에 속하는 리소스에 대해 일반 적이다. 영구적으로 사용할 수 없는 모든 리소스를 “gone”로 표시하거나 일정 시간 동안 표시를 유지할 필요는 없다. 이것은 서버 소유자의 재량이다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 410 응답은 캐시할 수 있다. 6.5.12. 411 Length Required 411 (Length Required) 상태 코드는 Content-Length 포함되지 않은 요청을 거부함을 나타낸다. 클라이언트 요청 메시지에 메시지 본문의 길이가 포함된 유효한 Content-Length 헤더 필드를 추가하는 경우 요청을 반복할 수 있다. 6.5.13. 412 Precondition Failed 클라이언트의 헤더에 있는 전제조건은 서버의 전제조건에 적절하지 않습니다. 6.5.13. 413 Payload Too Large 413 (Payload Too Large) 상태 코드는 요청 페이로드가 서버가 처리할 의향 또는 처리할 수 있는 능력보다 크기 때문에, 서버가 요청을 거부함을 나타낸다. 서버는 클라이언트가 요청을 계속하지 못하도록 커넥션을 닫는다. 일시적 조건인 경우 서버는 일시적임을 나타내기 위해 Retry-After 헤더 필드를 생성하여 클라이언트가 다시 시도할 수 있는 시간 이후를 표시 해야 한다. 6.5.14. 414 URI Too Long 414 (URI Too Long) 상태 코드는 request-target이 서버가 해석하려는 것보다 길기 때문에 서버가 요청을 거부함을 나타낸다. 이 조건은 클라이언트가 긴 쿼리 정보가 있는 GET 요청으로 POST 요청을 부적절하게 변환 했을 때, 클라이언트가 “black hole” 리디렉션(예를 들어 자체 접미사를 가리키는 리다이렉트 URI 접두사)로 내려갔을 때, 또는 서버가 잠재적인 보안 구멍을 이용하려고 시도하는 클라이언트의 공격을 받을 때에만 발생할 수 있다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 414 응답은 캐시할 수 있다. 6.5.15. 415 Unsupported Media Type 415 (Unsupported Media Type) 상태 코드는 대상 리소스에 대해 이 메서드로 지원하지 않는 형식의 페이로드가 있기 때문에, 원서버가 요청을 거부함을 나타낸다. 형식 문제는 요청에 표현된 Content-Type 또는 Content-Encoding 또는 데이터를 직접 검사한 결과일 수 있다. 6.5.16. 417 Expectation Failed 417 (Expectation Failed) 상태 코드는 요청의 Expect 헤더 필드에 주어진 기대치를 인바운드 서버 중 하나 이상이 충족할 수 없음을 나타낸다. 6.5.17. 426 Upgrade Required 426(Upgrade Required) 상태 코드는 서버가 현재 프로토콜을 사용하여 요청을 수행하기를 거부하지만 클라이언트가 다른 프로토콜로 업그레이드한 후 요청을 수행할 의사가 있음을 나타낸다. 서버는 반드시 필요한 프로토콜을 나타내기 위해 426 응답으로 Upgrage 헤더 필드를 전송 해야 한다. 예를 들어 이 서비스는 HTTP/3.0 프로토콜 사용을 필요로 한다. HTTP/1.1 426 Upgrade Required Upgrade: HTTP/3.0 Connection: Upgrade Content-Length: 53 Content-Type: text/plain 6.6. Server Error 5xx 상태 코드의 5xx (Server Error) 등급은 서버가 요청된 메서드를 잘못했거나, 수행할 수 없음을 나타낸다. HEAD 요청에 응답하는 경우를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 조건인지 영구적인 조건인지를 포함하는 representation을 보내야 한다. 사용자 에이전트는 사용자에게 포함된 모든 representation을 표시해야 한다. 이 응답 코드는 모든 요청 메서드에 적용 된다. 6.6.1. 500 Internal Server Error 500 (Internal Server Error) 상태 코드는 서버가 요청을 이행하지 못하게 하는 예기치 않은 조건을 만났음을 나타낸다. 6.6.2. 501 Not Implemented 501 (Not Implemented) 상태 코드는 서버가 요청을 이행하는데 필요한 기능을 지원하지 않음을 나타낸다. 이것은 서버가 요청 메서드를 인식하지 못하고 어떤 리소스에도 그것을 지원할 수 없을 때 적절한 대응이다. 메서드 정의나 명시적 캐시 제어에 의해 달리 명시되지 않는 한 기본적으로 501 응답은 캐시할 수 있다. 6.6.3. 502 Bad Gateway 502 (Bad Gateway) 상태 코드는 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 이행하는 중 엑세스한 인바운드 서버로 부터 잘못된 응답을 수신했음을 나타낸다. 6.6.4. 503 Service Unavailable 503 (Service Unavailable) 상태 코드는 서버가 현재 일시적인 과부하 또는 예정된 유지보수로 인해 요청을 처리할 수 없음을 나타내며, 어느 정도 지연된 후에 완화될 가능성이 높다. 서버는 Retry-After 헤더필드를 보내 클라이언트가 요청을 재시도하기 전에 대기할 시간을 제안할 수 있다. 참고: 503 상태 코드가 존재한다고 해서 서버가 과부하가 걸렸을 때 이를 사용해야 하는 것은 아니다. 일부 서버는 단순히 커넥션을 거부할 수 있다. 6.6.5. 504 Gateway Timeout 504 (Gateway Timeout) 상태 코드는 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 완료하기 위해 엑세스해야 하는 업스트림 서버로 부터 적시에 응답을 받지 못했음(지정한 시간 제한을 초과함)을 나타낸다. 추가 설명 6.6.6. 505 HTTP Version Not Supported 505 (HTTP Version Not Supported) 상태 코드는 서버가 요청 메시지에 사용된 HTTP의 주요 버전을 지원하지 않거나 지원을 거부함을 나타낸다. 서버는 오류 메시지를 제외하고 클라이언트와 동일한 주요 버전을 사용하여 요청을 완료할 수 없거나 요청을 완료할 의사가 없음을 나타내고 있다. 서버는 해당 버전이 지원되지 않는 이유와 해당 서버에서 지원하는 다른 프로토콜을 설명하는 505 응답에 대한 표현을 생성해야 한다.</summary></entry><entry><title type="html">HTTP 1.1 Reference - Semantics and Content (2) (최종 수정 날짜 : 2021-02-22)</title><link href="https://lcy960729.github.io/http/2021/02/22/HTTP1-1-Semantics-And-Content(2).html" rel="alternate" type="text/html" title="HTTP 1.1 Reference - Semantics and Content (2) (최종 수정 날짜 : 2021-02-22)" /><published>2021-02-22T00:00:00+09:00</published><updated>2021-02-22T00:00:00+09:00</updated><id>https://lcy960729.github.io/http/2021/02/22/HTTP1-1-Semantics-And-Content(2)</id><content type="html" xml:base="https://lcy960729.github.io/http/2021/02/22/HTTP1-1-Semantics-And-Content(2).html">&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본&lt;br /&gt;
&lt;a href=&quot;https://roka88.dev/106&quot;&gt;https://roka88.dev/106&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MDN Web Docs&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP&quot;&gt;https://developer.mozilla.org/ko/docs/Web/HTTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외 자료는 내용 중 링크 추가&lt;/p&gt;
&lt;h5 id=&quot;틀린-내용-부족한-내용-꼭-지적-부탁드립니다&quot;&gt;틀린 내용, 부족한 내용 꼭 지적 부탁드립니다!&lt;/h5&gt;

&lt;h1 id=&quot;4-request-methods&quot;&gt;4. Request Methods&lt;/h1&gt;
&lt;h2 id=&quot;41-overview&quot;&gt;4.1 Overview&lt;/h2&gt;
&lt;p&gt;Request 메소드 토큰은 Request 요청에서 가장 큰의미를 나타내며 클라이언트가 요청을 한 목적과 성공적인 결과로 클라이언트가 기대하는것을 나타낸다.
(GET 요청을 했다면 리소스를 가져오는 목적이였을 것이며, 반환 값으로는 해당 리소스를 원했을 것이다)
Request 메소드의 의미론은 Request에 어떠한 헤더 필드가 있을 때, 추가된 의미론과 메소드가 충돌되지 않는 경우 더 적합할 수 있다. 예를 들어 클라이언트는 조건부 요청 헤더 필드를 보내 대상 리소스의 현재 상태를 조건으로 요청된 작업을 수행 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;method = token&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;HTTP는 원래 분산 객체 시스템에 대한 인터페이스로 사용할 수 있도록 설계 되었다. 요청 메소드는 식별된 객체에 대해 정의된 메소드를 호출하는 것과 거의 동일한 방법으로 대상 리소스에 의미론을 적용하도록 구상 되었다. 메소드 토큰은 대소문자를 구분한다. 왜나하면 대소문자를 구분하는 객체 기반 시스템의 게이트웨이로 사용될 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;분산된 객체와 달리, HTTP의 표준화된 요청 메소드는 리소스에 특정하지 않는다. 적합한 인터페이스는 네트워크 기반 시스템[REST]에서 더 나은 가시성과 재사용을 제공하기 때문이다. 표준화된 메소드는 어떠한 리소스에 적용될때 같은 의미론을 가진다. 각 리소스는 이러한 의미론이 구현되는지, 허용되는지는 자체적으로 결정한다. (개발자가 해당 메소드를 구현하냐 마냐에 대한 얘기인듯.)&lt;/p&gt;

&lt;p&gt;다음 표에는 요약된 바와 같이 HTTP에서 일반적으로 사용되는 다수의 표준화된 메서드를 정의한다. 표준화된 메서드는 대문자 US-ASCII 문자로 정의된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Method&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;대상 리소스의 현재 Representation을 전송&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HEAD&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;GET과 동일하나, status-line과 header부분만 전송&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;POST&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;요청 페이로드에서 리소스의 구체적인 처리 수행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;PUT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;대상 리소스의 모든 현재 Representation을 요청 페이로드로 대체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DELETE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;대상 리소스의 현재 Representation 모두 제거&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CONNECT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;대상 리소스로 식별된 서버에 대한 터널 설립&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;OPTIONS&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;대상 리소스에 대한 통신 옵션 설명&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TRACE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;대상 리소스의 경로를 따라 메시지 루프백 테스트를 수행&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;모든 범용 서버는 GET 및 HEAD 메서드를 지원해야한다. 다른 메서드는 선택사항이다.&lt;/p&gt;

&lt;p&gt;이 명세 범위를 벗어난 추가 메서드는 HTTP에서 사용할 수 있도록 표준화되었다. 이러한 모든 메서드는 IANA에 의해 유지 되는 “Hypertext TransferProtocol (HTTP) Method Registry” 내에 등록되어야 한다.&lt;/p&gt;

&lt;p&gt;대상 리소스가 허용되는 메서드 집합은 Allow 헤더 필드에 나열할 수 있다. 그러나 허용된 메서드 집합은 동적으로 변할 수 있다. 서버에서 인식되지 않거나 구현되지 않은 요청 메서드가 수신되면 서버는 501(Not Implemented) 상태 코드로 응답해야 한다. 서버에서 구현은 되어 있지만 대상 리소스에 대해 사용 할 수 없는 메소드라면 서버는 405(Method Not Allowed) 상태 코드로 응답해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;42-common-method-properties&quot;&gt;4.2. Common Method Properties&lt;/h2&gt;
&lt;h3 id=&quot;421-safe-methods&quot;&gt;4.2.1. Safe Methods&lt;/h3&gt;
&lt;p&gt;요청 메서드는 정의된 의미론이 읽기 전용인경우 ‘safe’로 간주한다. 예를 들어 리소스에 대해서 safe 한 method를 적용한 결과는 서버의 어떠한 상태변화에 대해서 요구하지도 기대하지도 않는다. 마찬가지로 safe method의 합리적인 사용은 서버에 어떠한 위협과 비정상적인 행위를 야기하지 않을것이다.&lt;/p&gt;

&lt;p&gt;이러한 safe methods는 완전한 읽기 전용이 아니거나, 호출하는 동안 부작용을 일으키는 행동을 구현하는것을 막지 않는다. 중요한 것은 클라이언트가 추가 행동을 요구하지 않았고 이에 대한 책임을 물을 수 없기 때문에 안전하게 구현을 해야한다. 예를 들어 대부분 서버는 메서드 관계없이 모든 응답이 완료될 때 로그파일에 액세스 하기 위해 요청 정보를 추가하며, 로그 저장소가 가득 차서 서버가 다운될 수 있더라도 안전하다고 간주된다. 마찬가지로 웹에서 광고를 선택하여 시작된 safe 요청은 종종 광고 계정에 요금을 청구하는 부작용을 낳을 것이다.&lt;/p&gt;

&lt;p&gt;이 명세에 의해 정의된 요청 메소드 중 GET, HEAD, OPTION, TRACE 메서드는 안전하다고 정의된다.&lt;/p&gt;

&lt;p&gt;안전한 메서드와 안전하지 않은 메서드를 구분하는 목적은 자동 검색 프로세스(spider)와 캐시 성능 최적화(pre-fetching)가 문제를 일으키질 않도록 하기 위함이다. 또한 잠재적으로 신뢰할 수 없는 콘텐츠를 처리할 때 안전하지 않은 메서드의 자동 사용에 적절한 제약 조건을 적용할 수 있도록 한다.&lt;/p&gt;

&lt;p&gt;사용자 에이전트는 사용자에게 잠재적 행동을 제시할 때 사용자가 요청하기 전에 안전하지 않은 메서드를 인지할 수 있도록 안전한 메서드와 안전하지 않은 메서드를 구분해야 한다.&lt;/p&gt;

&lt;p&gt;유효한 요청 URI 내의 매개변수가 action 선택의 영향을 미치도록 리소스를 구성할 때, action이 요청 메소드의 의미와 일치하는지 확인하는 것은 리소스 소유자의 책임이다. 예를 들어 웹 기반 콘텐츠 편집 소프트웨어는 “page?do=delete”와 같은 쿼리 매개변수 내의 작업을 사용하는 것이 일반적이다. 이러한 리소스의 목적이 안전하지 않은 작업을 수행하는 것이라면, 리소스 소유자는 안전한 요청 메소드를 사용하여 액세스할 때 해당 작업을 비활성화하거나 허용하지 않아야 한다. 그렇게 하지 않으면 자동화된 프로세스가 링크 유지보수, pre-fetching (어플리케이션의 성능 향상을 위해서 구동에 필요한 데이터를 메모리에 먼저 올려 놓는것.), 검색 인덱스 작성 등을 위해 모든 URI 참조에 대해 GET을 수행할 떄 적절하지 못한 부작용을 초래할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;422-idempotent-methods&quot;&gt;4.2.2 Idempotent Methods&lt;/h3&gt;
&lt;p&gt;요청 메서드는 해당 메서드를 여러번 요청했을때와 한번 요청했을때의 결과가 동일 한 경우, “idempotent”으로 간주된다(멱등성) 이 명세에 의해 정의된 요청 메서드 중 PUT, DELETE, 및 safe method는 멱등하다.&lt;/p&gt;

&lt;p&gt;안전함의 정의와 마찬가지로, 멱등의 속성은 사용자가 요청한 것에만 적용된다. 서버는 각 요청을 별도로 로깅하거나, 버전 기록을 유지하거나 또는 각각 멱등 요청에서 비-멱등한 결과를 구현하는것은 자유롭다.&lt;/p&gt;

&lt;p&gt;멱등 메서드는 클라이언트가 서버의 응답을 읽기 전에 통신 장애가 발생하면 요청이 자동으로 반복될 수 있기 때문에 구별된다. 예를 들어 클라이언트가 PUT 요청을 보내고 응답이 수신되기 전에 기본 커넥션이 닫히면 클라이언트는 새로운 커넥션을 설정하고 멱등한 요청을 재시도할 수 있다. 응답은 다를수 있지만, 이전의 요청이 성공했더라도, 우리는 요청을 반복하는 것은 의도된 것과 같은 효과를 낸 다는것을 알고 있다.&lt;/p&gt;

&lt;h3 id=&quot;423-cacheable-methods&quot;&gt;4.2.3. Cacheable Methods&lt;/h3&gt;
&lt;p&gt;요청 메소드는 “cacheable”로 정의하여 향후 재사용에 대한 응답을 저장할 수 있다. 일반적으로 현재(아마 현재 상태와 의존하는 뜻인듯)와 권한 있는 응답에 의존하지 않는 safe 메서드는 캐시 가능으로 정의 된다. GET, HEAD 및 POST를 캐시 가능으로 정의하지만, 압도적으로 캐시구현은 GET와 HEAD만 지원한다. (POST는 safe method가 아니라고 했는데 뭐지?? 어떠한 상태 변화도 하지 않는 POST 요청은 괜찮다는건가?)&lt;/p&gt;

&lt;h2 id=&quot;43-method-definitions&quot;&gt;4.3. Method Definitions&lt;/h2&gt;
&lt;h3 id=&quot;431-get&quot;&gt;4.3.1. GET&lt;/h3&gt;
&lt;p&gt;GET 메서드는 대상 리소스에 대해 현재 선택된 Representation의 전송을 요청한다. GET은 정보 검색의 주요 메커니즘이자 거의 모든 성능 최적화의 초점이다. 따라서 사람들이 HTTP를 통해 식별 가능한 정보를 검색하는 것을 일반적으로 GET 요청이라 말한다.
리소스 식별자를 원격 파일 시스템 경로, 그러한 파일의 내용을 복사한 것으로 생각한다. 실제로, 저런 방식으로 많은 리소스를 구현했다. 하지만 리소스 식별자를 표현하는 방법에는 한계가 없다. 리소스를 위한 HTTP 인터페이스는, 컨텐츠 객체의 트리, 다양한 데이터베이스 레코드에 대한 프로그램 뷰 또는 다른 정보 시스템으로의 게이트웨이처럼 구현될 가능성도 높다. URI 매핑 메커니즘이 파일 시스템에 연결되어 있는 경우에도 서버는 요청으로 파일을 입력으로 실행하고 파일을 직접 정송하지 않고 출력물을 Representation으로 전송하도록 구성할 수 있다. 그럼에도 서버는 각각의 리소스 식별자가 구현에 어떻게 대응하는지, GET에 대한 응답으로 대상 리소스의 현재 표현을 어떻게 선택하고 전송하는지를 알 필요가 있다.&lt;/p&gt;

&lt;p&gt;클라이언트는 요청에서 Range 헤더필드를 전송하여 선택된 representation의 일부만 전송을 요청하는 GET의 의미를 range request로 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;GET 요청 메세지 내의 페이로드는 의미를 가지지 않는다. GET 요청에 페이로드 본체를 전송하면 일부 구현에서는 요청을 거부할 수 있다.&lt;/p&gt;

&lt;p&gt;GET 요청에 대한 응답은 캐시가 가능하며, 캐시는 Cache-Control 헤더 필드에 달리 표시되지 않는 한 후속 GET 및 HEAD 요청을 충족하기 위해 캐시를 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;432-head&quot;&gt;4.3.2. HEAD&lt;/h3&gt;
&lt;p&gt;HEAD 메서드는 GET과 동일하지만, 서버가 응답에서 메시지 본문을 전송하면 안된다. (응답에서 헤더까지만 옴). 페이로드 헤더 필드를 생략할 수 있다는 점을 제외하고, 서버는 HEAD 요청에 응답하여 GET 요청과 동일한 헤더필드를 전송해야 한다. 이 메서드는 representation 데이터를 전송하지 않고 선택된 표현에 대한 메타데이터를 얻는 데 사용할 수 있다 예를 들면 representation 데이터에 대해서 HTTP 링크로 해당 리소스가 유효한지, 접근 가능한지, 최근 수정이 되었는지 확인하는데 사용된다.&lt;/p&gt;

&lt;p&gt;HEAD 요청 메시지 내의 페이로드는 의미를 가지지 않는다. HEAD 요청에 페이로드 본체를 전송하면 일부 구현에서는 요청을 거부할 수 있다.&lt;/p&gt;

&lt;p&gt;HEAD 요청에 대한 응답은 캐시가 가능하며, 캐시는 Cache-Control 헤더 필드에 달리 표시 되지 않는 한 후속 HEAD 요청을 만족시키기 위해 캐시를 사용할 수 있다. HEAD 응답은 이전에 캐시된 GET 응답에도 영향을 미칠 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;433-post&quot;&gt;4.3.3. POST&lt;/h3&gt;
&lt;p&gt;POST 메서드는 리소스 요청에 포함된 representation을 리소스 자체의 특정 의미에 따라 처리하도록 요청한다. 예를 들어, POST는 아래와 같은 기능에 사용된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공한다.&lt;/li&gt;
  &lt;li&gt;게시판, 뉴스 그룹, 메일 목록, 블로그등 유사한 그룹에 글을 포스팅할 수 있다.&lt;/li&gt;
  &lt;li&gt;서버에서 아직 식별되지 않은 리소스를 생성할 수 있다.&lt;/li&gt;
  &lt;li&gt;리소스의 기존 representation에 데이터를 추가 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서버는 POST 요청 처리 결과에 따라 적절한 상태 코드를 선택하여 응답 결과의 의미를 표현해야하며, 대부분 응답으로 POST(206(Partial Content), 304(Not Modified), 416(Range Not Satisfiable)것들이 올 수 있다.&lt;/p&gt;

&lt;p&gt;POST 요청을 성공적으로 처리한 결과로써 하나 이상의 리소스가 서버에 생성된 경우, 서버는 생성된 리소스의 식별자를 제공하는 Location 헤더 필드를 포함하는 201(Created)응답과 요청의 상태를 설명하는 representation을 전송해야 한다.&lt;/p&gt;

&lt;p&gt;POST 요청에 대한 응답은 명시적으로 리소스가 변경되지 않았다는 정보를 포함하는 경우에만 캐시할 수 있다. 그러나 POST 캐싱은 잘 구현되지 않는다. 서버가 POST 요청후 결과를 GET으로 캐시할 수 있기를 원하는 경우, 서버는 결과를 포함하는 200(OK) 응답과 POST의 유효한 요청 URI와 동일한 값을 갖는 Content-Location 헤더 필드를 전송하여 나중에 GET으로 재사용 할 수 있는 방식으로 POST 결과를 캐시할 수 있다.&lt;/p&gt;

&lt;p&gt;POST 처리 결과가 기존 리소스의 representation과 같을 경우, 서버는 Location 필드에 있는 기존 리소스 식별자와 함께 303(See Other) 응답을 전송하여 사용자 에이전트를 해당 리소스로 리다이렉트 할 수 있다. 이는 사용자 에이전트가 이미 캐시된 representation을 가지고 있지 않은 경우, 추가 요청의 비용으로 사용자 에이전트에 리소스 식별자를 제공하고, 공유 캐싱에 더 적합한 메서드를 통해 representation을 전송할 수 있는 이점이 있다. (이 말이 이해가 안된다면 303코드의 사용 예를 찾아보면 이해하기 쉬울 것이다.)&lt;/p&gt;

&lt;h3 id=&quot;434-put&quot;&gt;4.3.4. PUT&lt;/h3&gt;
&lt;p&gt;PUT 메서드는 대상 리소스의 상태를 생성하거나 요청 메시지 페이로드에 동봉된 representation에 정의된 상태로 대체할 것을 요청한다. 주어진 representation으로 PUT 요청을 성공했다면 동일한 대상 리소스에 대한 후속 GET이 200(OK) 응답으로 동등한 representation을 전송하게 된다는것을 암시할 수 있다. 대상 리소스가 다른 사용자 에이전트에 의해 병렬로 작용하거나, 후속 GET이 수신되기 전에 원서버에 의해 동적 처리될 수 있기 때문에 이러한 상태 변화를 관찰할 수 있다는 보장은 없다. 성공적인 응답은 사용자 에이전트의 의도가 원서버에 의해 처리되는 시점에 달성 되었음을 의미한다.&lt;/p&gt;

&lt;p&gt;위에 대한 내용을 예를 들어보자. 한 리소스에 대해 여러 사용자 에이전트가 PUT 요청을 하는 예를 보자.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;1번 사용자 에이전트가 PUT 요청을 보낸다.&lt;/li&gt;
  &lt;li&gt;2번 사용자가 1번 사용자와 동일한 시점에 PUT 요청을 보낸다.&lt;/li&gt;
  &lt;li&gt;1번 사용자의 PUT 요청에 대한 성공 응답이 반환된다.&lt;/li&gt;
  &lt;li&gt;2번 사용자의 PUT요청에 대한 성공 응답이 반환된다.&lt;/li&gt;
  &lt;li&gt;1번 사용자가 GET 요청을 한다.&lt;/li&gt;
  &lt;li&gt;1번 사용자의 GET 요청이 반환 되며 결과는 2번 사용자가 PUT 요청에 대한 결과값이 포함되어 반환된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 처럼 후속 GET이 수신 되기전에 서버에 의해 동적 처리 되거나 병렬로 작용한다면 원하는 상태를 얻는다고 확신할 수 없다.&lt;/p&gt;

&lt;p&gt;대상 리소스가 현재 representation을 가지고 있지 않고 PUT이 성공적으로 생성한다면. 서버는 201(Created) 응답을 전송하여 사용자 에이전트에게 알려야한다. 대상 리소스가 현재 representation을 가지고 있고 가지고 있는 representation이 수정될 representation(put 요청시 페이로드에 담기는)에 따라서 성공적으로 수정된다면 서버는 요청 성공 완료를 나타내기 위해 200 (OK) 또는 204(No Content) 응답을 보내야 한다.&lt;/p&gt;

&lt;p&gt;서버는 PUT 요청으로 인식되지 않는 수신된 헤더 필드를 무시해야한다.(또한 헤더필드들을 리소스 상태의 일부로 저장하지 마라).&lt;/p&gt;

&lt;p&gt;서버는 PUT representation이 PUT에 의해 변경될 수 없거나, 변경 되지 않을 대상 리소스에 대한 서버가 가지는 제약 조건과 일치하는지 확인해야한다. 이는 GET 응답에 대한 표현 메타데이터 값을 설정하기 위해 서버가 URI와 관련된 내부 구성 정보를 사용하는 경우에 특히 중요하다. PUT 표현이 대상 리소스와 일치하지 않을 경우, 서버는 representation을 변환하거나, 리소스 구성을 변경하여 일관성을 유지하거나, representation이 적합하지 않은 이유를 설명하기 위해 충분한 정보를 포함하는 적절한 오류 메시지로 반환해야한다. 409 (Conflict) 또는 415(Unsupported Media Type) 상태 코드가 제안되며, 후자는 Content-Type 값에 대한 제약 조건에 한정된다&lt;/p&gt;

&lt;p&gt;예를 들어, 대상 리소스가 항상 “text/html”의 Content-Type을 가지도록 구성되고 PUT 표현이 “image/jpeg”의 Content-Type을 가지도록 구성된 경우, 서버는 다음 중 하나를 수행해야 한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;새로운 미디어 타입을 반영하도록 대상 리소스를 재구성한다.&lt;/li&gt;
  &lt;li&gt;PUT representation을 새 리소스 상태로 저장하기 전에 리소스의 representation과 일치하는 형식으로 변환한다.&lt;/li&gt;
  &lt;li&gt;대상 리소스가 “text/html”로 제한됨을 나타내는 415(Unsupported Media Type) 응답으로 요청을 거부하며, 새 representation에 적합한 대상이 될 수 있는 다른 리소스에 대한 링크를 포함할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTTP는 사용자 에이전트 요청의 의도와 서버 응답의 의미에 의해 표현될 수 있는것을 넘어 PUT 메서드가 서버의 상태에 어떻게 영향을 미치는지 정확히 정의하지 않는다. 어떤 의미에서도 HTTP를 통해 제공되는 인터페이스를 넘어 리소스가 무엇인지 정의하지 않는다. 그것은 리소스 상태가 “저장된” 방식이나, 리소스 상태의 변경으로 인해 그러한 저장소가 어떻게 변경될 수 있는지, 또한 서버가 리소스 상태를 representation으로 변환하는 방법을 정의하지 않는다. 일반적으로 리소스 인터페이스 뒤에 있는 모든 구현 세부사항은 서버에 의해 의도적으로 숨겨 진다.
(그냥 개발자가 PUT 요청에 대한 의미를 부여하고 직접 위와 같은 내용을 구현해야한다는 내용 같음)&lt;/p&gt;

&lt;p&gt;서버는 본문에 적용된 변환 없이 요청의 representation 데이터가 저장되고 validator filed가 새 representation을 반영하지 않으면 (리소스의 새 representation 데이터가 PUT 요청에서 받은 representation 데이터와 동일할때.) ETag 또는 Last-Modified field와 같은 validator header field를 성공적인 PUT 응답에 전송해서는 안 된다. 이 요구사항은 사용자 에이전트가 PUT의 결과로 메모리에 있는 표현 본문이 최신 상태로 유지되는 시기를 알 수 있또록 허용하며, 따라서 서버에서 다시 검색할 필요가 없으며, 응답에 수신된 새 검증자를 향후 조건부 요청에 사용하여 실수로 덮어 쓰지 않도록 할 수 있다.
(이해가 안됨;)&lt;/p&gt;

&lt;p&gt;POST 메서드와 PUT 메서드의 근본적인 차이는 동봉된 representation에 대한 다른 의도에 의해 강조된다. POST 요청의 대상 리소스는 리소스 자체의 의미에 따라 동봉된 representation을 처리하기 위한 것이며, PUT 요청의 동봉된 representation은 대상 리소스 상태를 대체하는 것으로 정의된다. 따라서 PUT의 의도는 멱등하며, 정확한 효과는 서버에 의해서만 알려져 있음에도 어떻게 변하는지 알 수 있다.&lt;/p&gt;

&lt;p&gt;PUT 요청에 대한 적절한 해석은 사용자 에이전트가 원하는 대상 리소스를 알고 있다고 가정한다. 상태 변경 요청을 받은 후 클라이언트 대신 적절한 URI를 선택하는 서비스는, PUT이 아닌 POST 메서드를 사용해 실시해야 한다. 서버는 요청된 PUT 상태를 대상 리소스로 변경하지 않고, 리소스를 다른 URI로 이동한 경우와 같이 다른 리소스에 적용하려면, 서버가 적절한 3xx(Redirection) 응답을 보내야 한다. 사용자 에이전트는 요청을 리다이렉트 할지 여부에 대해 자체 결정을 내릴 수 있다.&lt;/p&gt;

&lt;p&gt;대상 리소스에 적용되는 PUT 요청은 다른 리소스에 부작용을 일으킬 수 있다. 예를 들어, 신문 기사에서 각 특정 버전(한 시점에서 현재 버전 리소스와 동일한 상태를 공유하는 다른 리소스)을 식별하는 URI와 별도의 “현재 버전”을 식별하기 위한 URI가 있을 수 있다. 따라서 “현재 버전” URI의 PUT 요청이 성공하면 대상 리소스의 상태를 변경하는 것 외에 새 버전 리소스가 생성될 수 있으며 관련 리소스 간에 링크가 추가될 수 도 있다.&lt;/p&gt;

&lt;p&gt;특정 대상 리소스에 PUT을 허용하는 서버는, PUT이 전체 representation으로서 잘못 표현된 부분 콘텐츠일 가능성이 있으므로 Content-Range 헤더필드를 포함하는 PUT 요청에 400(Bad Request) 응답을 보내야 한다. 부분 콘텐츠 업데이트는 큰 리소스의 일부와 겹치는 상태를 가진 별도의 식별된 리소스를 대상으로 하거나, 부분 업데이트에 대해 특별히 정의된 다른 메서드 (PATCH)를 사용하여 가능하다.&lt;/p&gt;

&lt;p&gt;PUT 방법에 대한 응답은 캐시할 수 없습니다. 성공적인 PUT 요청이 유효 요청 URI에 대해 하나 이상의 응답이 저장된 캐시를 통과하면 저장된 응답은 무효화 된다.&lt;/p&gt;

&lt;h3 id=&quot;435-delete&quot;&gt;4.3.5. DELETE&lt;/h3&gt;
&lt;p&gt;DELETE 메서드는 서버가 대상 리소스와 현재 기능간의 연결을 제거하도록 요청한다. 사실상, 이 메섣는 UNIX의 rm 명령과 유사하다. 이것은 이전에 연결된 정보가 삭제 될 것이라는 예상보다는 서버의 URI 매핑에 대한 삭제 작업을 나타낸다.&lt;/p&gt;

&lt;p&gt;대상 리소스에 하나 이상의 현재 representation을 가지고 있는 경우, 대상 리소스가 서버의 의해 제거되거나 제거되지 않을 수 있으며, 리소스의 특성과 서버에 의한 구현에 따라 관련 저장소가 회수되거나 회수되지 않을 수 있다. 마찬가지로, 리소스의 다른 구현(데이터베이스나 게이트웨이 커넥션) 측면도 DELETE의 결과로 비활성화하거나 아카이브되어야 할 수 있다. 일반적으로 서버는 삭제를 수행하기 위해 규정된 메커니즘을 가진 리소스에 대해서만 DELETE를 허용한다고 가정한다.&lt;/p&gt;

&lt;p&gt;비교적 적은 리소스로 DELETE 메서드를 사용할 수 있다. 이 메서드는 주로 사용자가 삭제효과에 대한 방향을 가지고 있는 원격 저작 환경에 사용된다. 예를 들어 PUT 요청을 사용하여 이전에 생성했거나 POST 요청에 대한 201(Created) 응답 후 Location 헤더 필드를 통해 식별된 리소스는 해당 DELETE 요청을 허용하여 해당 작업을 실행 취소할 수 있다.&lt;/p&gt;

&lt;p&gt;DELETE 메서드가 성공적으로 적용된 경우, DELETE가 성공할 가능성이 높지만 아직 수행 되지 않은 경우 원본 서버는 202 (Accepted) 상태 코드를 반환하거나, DELETE가 수행 되어 추가 정보가 제공되지 않은 경우 204(No Content) 상태 코드를 전송하거나, DELETE가 정상적으로 수행 된 경우 200(OK) 상태 코드를 전송해야 한다. 그리고 body에는 상태를 설명하는 representation을 포함하는 응답 메시지를 전송해야 한다.&lt;/p&gt;

&lt;p&gt;DELETE 요청 메시지 내의 페이로드에는 정의된 의미가 없으며, DELETE 요청에 따라 페이로드 본문을 전송하면 일부 기존 구현이 요청을 거부할 수 있다.&lt;/p&gt;

&lt;p&gt;DELETE 메서드에 대한 응답은 캐시할 수 없다. 요청 URI에 대해 하나 이상의 저장된 응답이 있는 캐시를 통해 DELETE 요청이 전달되는 경우 저장된 응답은 무효화 된다.&lt;/p&gt;

&lt;h3 id=&quot;436-connect&quot;&gt;4.3.6. CONNECT&lt;/h3&gt;
&lt;p&gt;CONNECT 메서드는 수신자에게 요청 대상으로 식별된 대상 서버에 터널(양방향 연결)을 설정하도록 요청하고, 그 후, 터널이 닫힐 때까지 패킷의 블라인드 포워딩으로 동작을 제한한다. 터널은 일반적으로 하나 이상의 프록시를 통해 end-to-end 가상 커넥션을 생성하는 데 사용되며, 이후 TSL(Transport Layer Security)를 사용하여 보안을 유지할 수 있다.&lt;/p&gt;

&lt;p&gt;CONNECT는 프록시에 대한 요청에서만 사용할 수 있다. 자신에게 CONNECT 요청을 수신한 서버는 2xx (Successful) 상태 코드로 응답하여 커넥션이 설정되었음을 표시한다. 그러나 대부분의 서버는 CONNECT를 구현하지 않는다.&lt;/p&gt;

&lt;p&gt;CONNECT 요청을 전송하는 클라이언트는 요청 대상의 권한 양식을 전송해야 한다. 즉, 요청 대상은 콜론으로 구분된 터널 대상의 호스트 이름과 포트번호로만 구성된다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CONNECT server.example.com:80 HTTP/1.1 
Host: server.example.com:80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;수신자 프록시는 request-target에 직접 연결하거나 다른 프록시를 사용하도록 구성된 경우 CONNECT 요청을 다음 인바운드 프록시로 전달하여 터널을 설정할 수 있다. 2xx(Successful) 응답은 발신자(및 모든 인바운드 프록시)가 성공적인 응답의 헤더 부문을 끝내는 빈 줄 바로 뒤에 터널 모드로 전환됨을 나타낸다. 빈 줄 이후에 수신된 데이터는 request-target으로 식별된 서버로부터 수신된다. 성공적인 응답 이외의 응답은 터널이 아직 형성되지 않았으며 커넥션은 HTTP에 의해 통제된 상태로 남아 있음을 나타낸다.&lt;/p&gt;

&lt;p&gt;터널 중개자는 어느 한쪽이 커넥션을 닫았음을 감지할 때 터널이 닫힌다: 중개자는 닫힌 쪽에서 온 해결되지 않은 데이터를 다른 쪽으로 보내고, 양쪽 커넥션을 모두 닫은 다음, 전달되지 않은 나머지 데이터는 모두 폐기해야 한다.
프록시 인증을 사용하여 터널 생성 권한을 설정할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CONNECT server.example.com:80 HTTP/1.1 
Host: server.example.com:80 
Proxy-Authorization: basic aGVsbG86d29ybGQ=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;임의 서버에 대한 터널을 설정하는 경우, 특히 대상이 웹 트래픽을 대상으로 하지 않는 잘 알려져 있거나 예약된 TCP 포트인 경우 상당한 위험이 있다. 예를 들어 “example.com:25”의 request-target에 대한 CONNECT는 프록시가 SMTP 트래픽을 위해 예약된 포트에 연결하도록 제안할 수 있으며, 허용된 경우 프록시를 속여 스팸 전자 메일을 전달할 수 있다. CONNECT를 지원하는 프록시는 제한된 알려진 포트 집합 또는 안전한 요청 대상의 구성 가능한 화이트리스트로 사용을 제한해야한다.&lt;/p&gt;

&lt;p&gt;서버는 2xx(Successful) 응답으로 CONNECT에 Transfer-Encoding 또는 Content-Length 헤더 필드를 전송해서는 안 된다. 클라이언트는 CONNECT에 대한 성공적인 응답으로 수신된 Content-Length 또는 Transfer-Encoding 헤더 필드를 무시해야 한다.&lt;/p&gt;

&lt;p&gt;CONNECT 요청 메시지 내의 페이로드는 의미론을 정의하지 않는다; CONNECT 요청에 페이로드 본체를 전송하면 일부 기존 구현이 요청을 거부할 수 있다.&lt;/p&gt;

&lt;p&gt;CONNECT 메서드에 대한 응답은 캐시할 수 없다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CONNECT에 대해선 더 학습이 필요할것같다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;437-options&quot;&gt;4.3.7. OPTIONS&lt;/h3&gt;
&lt;p&gt;OPTION 메서드는 대상 리소스에 사용할 수 있는 통신 옵션에 대한 정보를 오리진 서버 또는 중개자에게 요청한다.
이 메서드를 사용하면 클라이언트가 리소스 작업을 암시하지 않고 리소스 또는 서버의 기능과 관련된 옵션 또는 요구 사항을 결정할 수 있다.&lt;/p&gt;

&lt;p&gt;” * “를 요청 대상으로 하는 OPTIONS 요청은 특정 리소스가 아닌 일반적으로 서버에 적용된다. 
서버의 통신 옵션은 일반적으로 리소스에 따라 다르기 때문에, “ * “ 요청은 “ping” 또는 “no-op” 유형의 메소드만 유효하며, 
클라이언트가 서버의 기능을 테스트할 수 있도록 허용하는것 외에는 아무것도 하지 않는다. 예를 들어, HTTP/1.1 적합성(적합하지 않은지)에 대한 프록시를 테스트하는 데 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;요청 대상이 별표가 아닌 경우 OPTION 요청은 대상 리소스와 통신할 때 사용할 수 있는 옵션에 적용된다.&lt;/p&gt;

&lt;p&gt;OPTION에 대한 성공적인 응답을 생성하는 서버는 이 명세에 정의되지 않은 잠재적 확장을 포함하여 서버가 구현하고
대상 리소스(e.g, Allow)에 적용할 수 있는 선택적 기능을 나타낼 수 있는 헤더 필드를 전송해야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/http1-1SemanticsAndContent/OPTIONS.png&quot; alt=&quot;OPTIONS 예제&quot; /&gt;&lt;br /&gt;
사진처럼 URL에 OPTIONS 헤더를 보내면 allow 헤더를 통해 어떤 메서드를 사용할 수 있는지 나타난다.&lt;/p&gt;

&lt;p&gt;응답 페이로드(있는 경우)는 기계나 사람이 읽을 수 있는 representation에서 통신 옵션을 설명할 수도 있다. 이러한 representation에 대한 
표준 형식은 이 명세에 의해 정의되지 않지만 HTTP에 대한 향후 확장에 의해 정의될 수 있다. 응답에서 페이로드 본문을 전송하지 않으려면 서버는
“0”의 값을 가진 Content-Length 필드를 생성해야 한다.&lt;/p&gt;

&lt;p&gt;클라이언트 OPTIONS 요청의 Max-Forwards 헤더 필드를 요청 체인의 특정 수신자를 대상으로 보낼 수 있다.
요청이 Max-Forwards 필드와 수신되지 않은 경우 프록시는 요청을 전달하는 동안 MaxForwards 헤더 필드를 생성해서는 안 된다.&lt;br /&gt;
&lt;a href=&quot;https://withbundo.blogspot.com/2017/08/http-15-http-v-max-forwards-proxy.html&quot;&gt;MAX-Forwards&lt;/a&gt;에 대해선
이 분의 블로그에 잘 설명 되어 있으므로 참고하길 바란다.&lt;/p&gt;

&lt;p&gt;페이로드 본문을 포함하는 OPTIONS 요청을 생성하는 클라이언트는 representation의 미디어 타입 유형을 설명하는 유효한 Content-Type 헤더 필드를 전송해야 한다.
이 명세는 이러한 페이로드에 대한 사용을 정의하지 않지만, 이 후 HTTP에 대한 확장은 OPTIONS 본문을 사용하여 대상 리소스에 대한 보다 상세한 쿼리를 할 수 있다.&lt;/p&gt;

&lt;p&gt;OPTIONS 메서드에 대한 응답은 캐시 할 수 없다.&lt;/p&gt;

&lt;p&gt;CORS에서 OPTIONS 메소드를 통해 프리플라이트 요청, 즉 사전 요청을 보내 서버가 해당 parameters를 포함한 요청을 보내도 되는지에 대한 응답을 줄 수 있게 한다.&lt;/p&gt;

&lt;p&gt;Access-Control-Request-Method 헤더는 프리플라이트 요청의 일부분으로 서버에게 실제 요청이 전달 될 때 POST 요청 메소드로 전달될 것 임을 명시한다.&lt;/p&gt;

&lt;p&gt;Access-Control-Request-Headers 헤더는 서버에게 실제 요청이 전달될 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X-PINGOTHER&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt; custom headers 와 함께 전달될 것 임을 명시한다.
서버는 그럼 이러한 요구사항들에 맞춰 요청을 수락할 것인지 정할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OPTIONS /resources/post-here/ HTTP/1.1
Host: bar.other
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Origin: http://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;아래 응답을 보면 서버는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Allow-Methods&lt;/code&gt;로 응답하고, POST, GET 그리고 OPTIONS 메소드를 통해서 해당하는 자원을 query할 수 있음을 알려준다.
이 헤더는 Allow 응답 헤더와 비슷하지만 반드시 CORS에 한해서만 사용된다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;438-trace&quot;&gt;4.3.8. TRACE&lt;/h3&gt;
&lt;p&gt;TRACE 메서드는 요청 메시지의 원격 어플리케이션-레벨 루프백을 요청한다. 
요청의 최종 수신자는 아래에 설명된 일부 필드를 제외하고 수신된 메시지를 
“message/http”의 내용 유형으로 200(OK) 응답의 메시지 본문으로 클라이언트에 다시 반영해야 한다.
최종 수신자는 요청에서 Max_Forwards의 0값을 수신한 첫 번째 서버 또는 원 서버 이다.&lt;/p&gt;

&lt;p&gt;클라이언트는 TRACE 요청에서 응답에 의해 공개될 수 있는 중요한 데이터를 포함하여 헤더필드를 생성해서는 안 된다.
예를 들어 사용자가 에이전트가 저장된 사용자 자격 증명 또는 쿠기를 TRACE 요청으로 전송하는 것은 어리석은 일이다.
요청의 최종 수신자는 응답 본문을 생성할 때 중요한 데이터를 포함할 가능성이 있는 요청 헤더 필드를 제외해야한다.&lt;/p&gt;

&lt;p&gt;TRACE는 클라이언트가 요청 체인의 다른 쪽 끝에서 수신되는 것을 확인하고 테스트 또는 진단 정보를 위해 해당 데이터를 사용할 수 있도록 한다.
via 헤더 필드의 값은 요청 체인의 추적 역할을 하므로 특히 중요하다. Max-Forwards 헤더 필드를 사용하면 클라이언트가 요청 체인의 길이를 제한할 수 있으며,
이는 무한 루프에서 메시지 전달 프록시 체인을 테스트하는데 유용하다.&lt;/p&gt;

&lt;p&gt;클라이언트는 TRACE 요청으로 메시지 본문을 보내서는 안된다.&lt;/p&gt;

&lt;p&gt;TRACE 메서드에 대한 응답은 캐시할 수 없다.&lt;/p&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="http" /><category term="Web" /><category term="HTTP1.1" /><summary type="html">참고 자료 이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본 https://roka88.dev/106 MDN Web Docs https://developer.mozilla.org/ko/docs/Web/HTTP 이외 자료는 내용 중 링크 추가 틀린 내용, 부족한 내용 꼭 지적 부탁드립니다! 4. Request Methods 4.1 Overview Request 메소드 토큰은 Request 요청에서 가장 큰의미를 나타내며 클라이언트가 요청을 한 목적과 성공적인 결과로 클라이언트가 기대하는것을 나타낸다. (GET 요청을 했다면 리소스를 가져오는 목적이였을 것이며, 반환 값으로는 해당 리소스를 원했을 것이다) Request 메소드의 의미론은 Request에 어떠한 헤더 필드가 있을 때, 추가된 의미론과 메소드가 충돌되지 않는 경우 더 적합할 수 있다. 예를 들어 클라이언트는 조건부 요청 헤더 필드를 보내 대상 리소스의 현재 상태를 조건으로 요청된 작업을 수행 할 수 있다. method = token HTTP는 원래 분산 객체 시스템에 대한 인터페이스로 사용할 수 있도록 설계 되었다. 요청 메소드는 식별된 객체에 대해 정의된 메소드를 호출하는 것과 거의 동일한 방법으로 대상 리소스에 의미론을 적용하도록 구상 되었다. 메소드 토큰은 대소문자를 구분한다. 왜나하면 대소문자를 구분하는 객체 기반 시스템의 게이트웨이로 사용될 수 있기 때문이다. 분산된 객체와 달리, HTTP의 표준화된 요청 메소드는 리소스에 특정하지 않는다. 적합한 인터페이스는 네트워크 기반 시스템[REST]에서 더 나은 가시성과 재사용을 제공하기 때문이다. 표준화된 메소드는 어떠한 리소스에 적용될때 같은 의미론을 가진다. 각 리소스는 이러한 의미론이 구현되는지, 허용되는지는 자체적으로 결정한다. (개발자가 해당 메소드를 구현하냐 마냐에 대한 얘기인듯.) 다음 표에는 요약된 바와 같이 HTTP에서 일반적으로 사용되는 다수의 표준화된 메서드를 정의한다. 표준화된 메서드는 대문자 US-ASCII 문자로 정의된다. Method Description GET 대상 리소스의 현재 Representation을 전송 HEAD GET과 동일하나, status-line과 header부분만 전송 POST 요청 페이로드에서 리소스의 구체적인 처리 수행 PUT 대상 리소스의 모든 현재 Representation을 요청 페이로드로 대체 DELETE 대상 리소스의 현재 Representation 모두 제거 CONNECT 대상 리소스로 식별된 서버에 대한 터널 설립 OPTIONS 대상 리소스에 대한 통신 옵션 설명 TRACE 대상 리소스의 경로를 따라 메시지 루프백 테스트를 수행 모든 범용 서버는 GET 및 HEAD 메서드를 지원해야한다. 다른 메서드는 선택사항이다. 이 명세 범위를 벗어난 추가 메서드는 HTTP에서 사용할 수 있도록 표준화되었다. 이러한 모든 메서드는 IANA에 의해 유지 되는 “Hypertext TransferProtocol (HTTP) Method Registry” 내에 등록되어야 한다. 대상 리소스가 허용되는 메서드 집합은 Allow 헤더 필드에 나열할 수 있다. 그러나 허용된 메서드 집합은 동적으로 변할 수 있다. 서버에서 인식되지 않거나 구현되지 않은 요청 메서드가 수신되면 서버는 501(Not Implemented) 상태 코드로 응답해야 한다. 서버에서 구현은 되어 있지만 대상 리소스에 대해 사용 할 수 없는 메소드라면 서버는 405(Method Not Allowed) 상태 코드로 응답해야 한다. 4.2. Common Method Properties 4.2.1. Safe Methods 요청 메서드는 정의된 의미론이 읽기 전용인경우 ‘safe’로 간주한다. 예를 들어 리소스에 대해서 safe 한 method를 적용한 결과는 서버의 어떠한 상태변화에 대해서 요구하지도 기대하지도 않는다. 마찬가지로 safe method의 합리적인 사용은 서버에 어떠한 위협과 비정상적인 행위를 야기하지 않을것이다. 이러한 safe methods는 완전한 읽기 전용이 아니거나, 호출하는 동안 부작용을 일으키는 행동을 구현하는것을 막지 않는다. 중요한 것은 클라이언트가 추가 행동을 요구하지 않았고 이에 대한 책임을 물을 수 없기 때문에 안전하게 구현을 해야한다. 예를 들어 대부분 서버는 메서드 관계없이 모든 응답이 완료될 때 로그파일에 액세스 하기 위해 요청 정보를 추가하며, 로그 저장소가 가득 차서 서버가 다운될 수 있더라도 안전하다고 간주된다. 마찬가지로 웹에서 광고를 선택하여 시작된 safe 요청은 종종 광고 계정에 요금을 청구하는 부작용을 낳을 것이다. 이 명세에 의해 정의된 요청 메소드 중 GET, HEAD, OPTION, TRACE 메서드는 안전하다고 정의된다. 안전한 메서드와 안전하지 않은 메서드를 구분하는 목적은 자동 검색 프로세스(spider)와 캐시 성능 최적화(pre-fetching)가 문제를 일으키질 않도록 하기 위함이다. 또한 잠재적으로 신뢰할 수 없는 콘텐츠를 처리할 때 안전하지 않은 메서드의 자동 사용에 적절한 제약 조건을 적용할 수 있도록 한다. 사용자 에이전트는 사용자에게 잠재적 행동을 제시할 때 사용자가 요청하기 전에 안전하지 않은 메서드를 인지할 수 있도록 안전한 메서드와 안전하지 않은 메서드를 구분해야 한다. 유효한 요청 URI 내의 매개변수가 action 선택의 영향을 미치도록 리소스를 구성할 때, action이 요청 메소드의 의미와 일치하는지 확인하는 것은 리소스 소유자의 책임이다. 예를 들어 웹 기반 콘텐츠 편집 소프트웨어는 “page?do=delete”와 같은 쿼리 매개변수 내의 작업을 사용하는 것이 일반적이다. 이러한 리소스의 목적이 안전하지 않은 작업을 수행하는 것이라면, 리소스 소유자는 안전한 요청 메소드를 사용하여 액세스할 때 해당 작업을 비활성화하거나 허용하지 않아야 한다. 그렇게 하지 않으면 자동화된 프로세스가 링크 유지보수, pre-fetching (어플리케이션의 성능 향상을 위해서 구동에 필요한 데이터를 메모리에 먼저 올려 놓는것.), 검색 인덱스 작성 등을 위해 모든 URI 참조에 대해 GET을 수행할 떄 적절하지 못한 부작용을 초래할 수 있다. 4.2.2 Idempotent Methods 요청 메서드는 해당 메서드를 여러번 요청했을때와 한번 요청했을때의 결과가 동일 한 경우, “idempotent”으로 간주된다(멱등성) 이 명세에 의해 정의된 요청 메서드 중 PUT, DELETE, 및 safe method는 멱등하다. 안전함의 정의와 마찬가지로, 멱등의 속성은 사용자가 요청한 것에만 적용된다. 서버는 각 요청을 별도로 로깅하거나, 버전 기록을 유지하거나 또는 각각 멱등 요청에서 비-멱등한 결과를 구현하는것은 자유롭다. 멱등 메서드는 클라이언트가 서버의 응답을 읽기 전에 통신 장애가 발생하면 요청이 자동으로 반복될 수 있기 때문에 구별된다. 예를 들어 클라이언트가 PUT 요청을 보내고 응답이 수신되기 전에 기본 커넥션이 닫히면 클라이언트는 새로운 커넥션을 설정하고 멱등한 요청을 재시도할 수 있다. 응답은 다를수 있지만, 이전의 요청이 성공했더라도, 우리는 요청을 반복하는 것은 의도된 것과 같은 효과를 낸 다는것을 알고 있다. 4.2.3. Cacheable Methods 요청 메소드는 “cacheable”로 정의하여 향후 재사용에 대한 응답을 저장할 수 있다. 일반적으로 현재(아마 현재 상태와 의존하는 뜻인듯)와 권한 있는 응답에 의존하지 않는 safe 메서드는 캐시 가능으로 정의 된다. GET, HEAD 및 POST를 캐시 가능으로 정의하지만, 압도적으로 캐시구현은 GET와 HEAD만 지원한다. (POST는 safe method가 아니라고 했는데 뭐지?? 어떠한 상태 변화도 하지 않는 POST 요청은 괜찮다는건가?) 4.3. Method Definitions 4.3.1. GET GET 메서드는 대상 리소스에 대해 현재 선택된 Representation의 전송을 요청한다. GET은 정보 검색의 주요 메커니즘이자 거의 모든 성능 최적화의 초점이다. 따라서 사람들이 HTTP를 통해 식별 가능한 정보를 검색하는 것을 일반적으로 GET 요청이라 말한다. 리소스 식별자를 원격 파일 시스템 경로, 그러한 파일의 내용을 복사한 것으로 생각한다. 실제로, 저런 방식으로 많은 리소스를 구현했다. 하지만 리소스 식별자를 표현하는 방법에는 한계가 없다. 리소스를 위한 HTTP 인터페이스는, 컨텐츠 객체의 트리, 다양한 데이터베이스 레코드에 대한 프로그램 뷰 또는 다른 정보 시스템으로의 게이트웨이처럼 구현될 가능성도 높다. URI 매핑 메커니즘이 파일 시스템에 연결되어 있는 경우에도 서버는 요청으로 파일을 입력으로 실행하고 파일을 직접 정송하지 않고 출력물을 Representation으로 전송하도록 구성할 수 있다. 그럼에도 서버는 각각의 리소스 식별자가 구현에 어떻게 대응하는지, GET에 대한 응답으로 대상 리소스의 현재 표현을 어떻게 선택하고 전송하는지를 알 필요가 있다. 클라이언트는 요청에서 Range 헤더필드를 전송하여 선택된 representation의 일부만 전송을 요청하는 GET의 의미를 range request로 변경할 수 있다. GET 요청 메세지 내의 페이로드는 의미를 가지지 않는다. GET 요청에 페이로드 본체를 전송하면 일부 구현에서는 요청을 거부할 수 있다. GET 요청에 대한 응답은 캐시가 가능하며, 캐시는 Cache-Control 헤더 필드에 달리 표시되지 않는 한 후속 GET 및 HEAD 요청을 충족하기 위해 캐시를 사용할 수 있다. 4.3.2. HEAD HEAD 메서드는 GET과 동일하지만, 서버가 응답에서 메시지 본문을 전송하면 안된다. (응답에서 헤더까지만 옴). 페이로드 헤더 필드를 생략할 수 있다는 점을 제외하고, 서버는 HEAD 요청에 응답하여 GET 요청과 동일한 헤더필드를 전송해야 한다. 이 메서드는 representation 데이터를 전송하지 않고 선택된 표현에 대한 메타데이터를 얻는 데 사용할 수 있다 예를 들면 representation 데이터에 대해서 HTTP 링크로 해당 리소스가 유효한지, 접근 가능한지, 최근 수정이 되었는지 확인하는데 사용된다. HEAD 요청 메시지 내의 페이로드는 의미를 가지지 않는다. HEAD 요청에 페이로드 본체를 전송하면 일부 구현에서는 요청을 거부할 수 있다. HEAD 요청에 대한 응답은 캐시가 가능하며, 캐시는 Cache-Control 헤더 필드에 달리 표시 되지 않는 한 후속 HEAD 요청을 만족시키기 위해 캐시를 사용할 수 있다. HEAD 응답은 이전에 캐시된 GET 응답에도 영향을 미칠 수 있다. 4.3.3. POST POST 메서드는 리소스 요청에 포함된 representation을 리소스 자체의 특정 의미에 따라 처리하도록 요청한다. 예를 들어, POST는 아래와 같은 기능에 사용된다. HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공한다. 게시판, 뉴스 그룹, 메일 목록, 블로그등 유사한 그룹에 글을 포스팅할 수 있다. 서버에서 아직 식별되지 않은 리소스를 생성할 수 있다. 리소스의 기존 representation에 데이터를 추가 할 수 있다. 서버는 POST 요청 처리 결과에 따라 적절한 상태 코드를 선택하여 응답 결과의 의미를 표현해야하며, 대부분 응답으로 POST(206(Partial Content), 304(Not Modified), 416(Range Not Satisfiable)것들이 올 수 있다. POST 요청을 성공적으로 처리한 결과로써 하나 이상의 리소스가 서버에 생성된 경우, 서버는 생성된 리소스의 식별자를 제공하는 Location 헤더 필드를 포함하는 201(Created)응답과 요청의 상태를 설명하는 representation을 전송해야 한다. POST 요청에 대한 응답은 명시적으로 리소스가 변경되지 않았다는 정보를 포함하는 경우에만 캐시할 수 있다. 그러나 POST 캐싱은 잘 구현되지 않는다. 서버가 POST 요청후 결과를 GET으로 캐시할 수 있기를 원하는 경우, 서버는 결과를 포함하는 200(OK) 응답과 POST의 유효한 요청 URI와 동일한 값을 갖는 Content-Location 헤더 필드를 전송하여 나중에 GET으로 재사용 할 수 있는 방식으로 POST 결과를 캐시할 수 있다. POST 처리 결과가 기존 리소스의 representation과 같을 경우, 서버는 Location 필드에 있는 기존 리소스 식별자와 함께 303(See Other) 응답을 전송하여 사용자 에이전트를 해당 리소스로 리다이렉트 할 수 있다. 이는 사용자 에이전트가 이미 캐시된 representation을 가지고 있지 않은 경우, 추가 요청의 비용으로 사용자 에이전트에 리소스 식별자를 제공하고, 공유 캐싱에 더 적합한 메서드를 통해 representation을 전송할 수 있는 이점이 있다. (이 말이 이해가 안된다면 303코드의 사용 예를 찾아보면 이해하기 쉬울 것이다.) 4.3.4. PUT PUT 메서드는 대상 리소스의 상태를 생성하거나 요청 메시지 페이로드에 동봉된 representation에 정의된 상태로 대체할 것을 요청한다. 주어진 representation으로 PUT 요청을 성공했다면 동일한 대상 리소스에 대한 후속 GET이 200(OK) 응답으로 동등한 representation을 전송하게 된다는것을 암시할 수 있다. 대상 리소스가 다른 사용자 에이전트에 의해 병렬로 작용하거나, 후속 GET이 수신되기 전에 원서버에 의해 동적 처리될 수 있기 때문에 이러한 상태 변화를 관찰할 수 있다는 보장은 없다. 성공적인 응답은 사용자 에이전트의 의도가 원서버에 의해 처리되는 시점에 달성 되었음을 의미한다. 위에 대한 내용을 예를 들어보자. 한 리소스에 대해 여러 사용자 에이전트가 PUT 요청을 하는 예를 보자. 1번 사용자 에이전트가 PUT 요청을 보낸다. 2번 사용자가 1번 사용자와 동일한 시점에 PUT 요청을 보낸다. 1번 사용자의 PUT 요청에 대한 성공 응답이 반환된다. 2번 사용자의 PUT요청에 대한 성공 응답이 반환된다. 1번 사용자가 GET 요청을 한다. 1번 사용자의 GET 요청이 반환 되며 결과는 2번 사용자가 PUT 요청에 대한 결과값이 포함되어 반환된다. 이 처럼 후속 GET이 수신 되기전에 서버에 의해 동적 처리 되거나 병렬로 작용한다면 원하는 상태를 얻는다고 확신할 수 없다. 대상 리소스가 현재 representation을 가지고 있지 않고 PUT이 성공적으로 생성한다면. 서버는 201(Created) 응답을 전송하여 사용자 에이전트에게 알려야한다. 대상 리소스가 현재 representation을 가지고 있고 가지고 있는 representation이 수정될 representation(put 요청시 페이로드에 담기는)에 따라서 성공적으로 수정된다면 서버는 요청 성공 완료를 나타내기 위해 200 (OK) 또는 204(No Content) 응답을 보내야 한다. 서버는 PUT 요청으로 인식되지 않는 수신된 헤더 필드를 무시해야한다.(또한 헤더필드들을 리소스 상태의 일부로 저장하지 마라). 서버는 PUT representation이 PUT에 의해 변경될 수 없거나, 변경 되지 않을 대상 리소스에 대한 서버가 가지는 제약 조건과 일치하는지 확인해야한다. 이는 GET 응답에 대한 표현 메타데이터 값을 설정하기 위해 서버가 URI와 관련된 내부 구성 정보를 사용하는 경우에 특히 중요하다. PUT 표현이 대상 리소스와 일치하지 않을 경우, 서버는 representation을 변환하거나, 리소스 구성을 변경하여 일관성을 유지하거나, representation이 적합하지 않은 이유를 설명하기 위해 충분한 정보를 포함하는 적절한 오류 메시지로 반환해야한다. 409 (Conflict) 또는 415(Unsupported Media Type) 상태 코드가 제안되며, 후자는 Content-Type 값에 대한 제약 조건에 한정된다 예를 들어, 대상 리소스가 항상 “text/html”의 Content-Type을 가지도록 구성되고 PUT 표현이 “image/jpeg”의 Content-Type을 가지도록 구성된 경우, 서버는 다음 중 하나를 수행해야 한다. 새로운 미디어 타입을 반영하도록 대상 리소스를 재구성한다. PUT representation을 새 리소스 상태로 저장하기 전에 리소스의 representation과 일치하는 형식으로 변환한다. 대상 리소스가 “text/html”로 제한됨을 나타내는 415(Unsupported Media Type) 응답으로 요청을 거부하며, 새 representation에 적합한 대상이 될 수 있는 다른 리소스에 대한 링크를 포함할 수 있다. HTTP는 사용자 에이전트 요청의 의도와 서버 응답의 의미에 의해 표현될 수 있는것을 넘어 PUT 메서드가 서버의 상태에 어떻게 영향을 미치는지 정확히 정의하지 않는다. 어떤 의미에서도 HTTP를 통해 제공되는 인터페이스를 넘어 리소스가 무엇인지 정의하지 않는다. 그것은 리소스 상태가 “저장된” 방식이나, 리소스 상태의 변경으로 인해 그러한 저장소가 어떻게 변경될 수 있는지, 또한 서버가 리소스 상태를 representation으로 변환하는 방법을 정의하지 않는다. 일반적으로 리소스 인터페이스 뒤에 있는 모든 구현 세부사항은 서버에 의해 의도적으로 숨겨 진다. (그냥 개발자가 PUT 요청에 대한 의미를 부여하고 직접 위와 같은 내용을 구현해야한다는 내용 같음) 서버는 본문에 적용된 변환 없이 요청의 representation 데이터가 저장되고 validator filed가 새 representation을 반영하지 않으면 (리소스의 새 representation 데이터가 PUT 요청에서 받은 representation 데이터와 동일할때.) ETag 또는 Last-Modified field와 같은 validator header field를 성공적인 PUT 응답에 전송해서는 안 된다. 이 요구사항은 사용자 에이전트가 PUT의 결과로 메모리에 있는 표현 본문이 최신 상태로 유지되는 시기를 알 수 있또록 허용하며, 따라서 서버에서 다시 검색할 필요가 없으며, 응답에 수신된 새 검증자를 향후 조건부 요청에 사용하여 실수로 덮어 쓰지 않도록 할 수 있다. (이해가 안됨;) POST 메서드와 PUT 메서드의 근본적인 차이는 동봉된 representation에 대한 다른 의도에 의해 강조된다. POST 요청의 대상 리소스는 리소스 자체의 의미에 따라 동봉된 representation을 처리하기 위한 것이며, PUT 요청의 동봉된 representation은 대상 리소스 상태를 대체하는 것으로 정의된다. 따라서 PUT의 의도는 멱등하며, 정확한 효과는 서버에 의해서만 알려져 있음에도 어떻게 변하는지 알 수 있다. PUT 요청에 대한 적절한 해석은 사용자 에이전트가 원하는 대상 리소스를 알고 있다고 가정한다. 상태 변경 요청을 받은 후 클라이언트 대신 적절한 URI를 선택하는 서비스는, PUT이 아닌 POST 메서드를 사용해 실시해야 한다. 서버는 요청된 PUT 상태를 대상 리소스로 변경하지 않고, 리소스를 다른 URI로 이동한 경우와 같이 다른 리소스에 적용하려면, 서버가 적절한 3xx(Redirection) 응답을 보내야 한다. 사용자 에이전트는 요청을 리다이렉트 할지 여부에 대해 자체 결정을 내릴 수 있다. 대상 리소스에 적용되는 PUT 요청은 다른 리소스에 부작용을 일으킬 수 있다. 예를 들어, 신문 기사에서 각 특정 버전(한 시점에서 현재 버전 리소스와 동일한 상태를 공유하는 다른 리소스)을 식별하는 URI와 별도의 “현재 버전”을 식별하기 위한 URI가 있을 수 있다. 따라서 “현재 버전” URI의 PUT 요청이 성공하면 대상 리소스의 상태를 변경하는 것 외에 새 버전 리소스가 생성될 수 있으며 관련 리소스 간에 링크가 추가될 수 도 있다. 특정 대상 리소스에 PUT을 허용하는 서버는, PUT이 전체 representation으로서 잘못 표현된 부분 콘텐츠일 가능성이 있으므로 Content-Range 헤더필드를 포함하는 PUT 요청에 400(Bad Request) 응답을 보내야 한다. 부분 콘텐츠 업데이트는 큰 리소스의 일부와 겹치는 상태를 가진 별도의 식별된 리소스를 대상으로 하거나, 부분 업데이트에 대해 특별히 정의된 다른 메서드 (PATCH)를 사용하여 가능하다. PUT 방법에 대한 응답은 캐시할 수 없습니다. 성공적인 PUT 요청이 유효 요청 URI에 대해 하나 이상의 응답이 저장된 캐시를 통과하면 저장된 응답은 무효화 된다. 4.3.5. DELETE DELETE 메서드는 서버가 대상 리소스와 현재 기능간의 연결을 제거하도록 요청한다. 사실상, 이 메섣는 UNIX의 rm 명령과 유사하다. 이것은 이전에 연결된 정보가 삭제 될 것이라는 예상보다는 서버의 URI 매핑에 대한 삭제 작업을 나타낸다. 대상 리소스에 하나 이상의 현재 representation을 가지고 있는 경우, 대상 리소스가 서버의 의해 제거되거나 제거되지 않을 수 있으며, 리소스의 특성과 서버에 의한 구현에 따라 관련 저장소가 회수되거나 회수되지 않을 수 있다. 마찬가지로, 리소스의 다른 구현(데이터베이스나 게이트웨이 커넥션) 측면도 DELETE의 결과로 비활성화하거나 아카이브되어야 할 수 있다. 일반적으로 서버는 삭제를 수행하기 위해 규정된 메커니즘을 가진 리소스에 대해서만 DELETE를 허용한다고 가정한다. 비교적 적은 리소스로 DELETE 메서드를 사용할 수 있다. 이 메서드는 주로 사용자가 삭제효과에 대한 방향을 가지고 있는 원격 저작 환경에 사용된다. 예를 들어 PUT 요청을 사용하여 이전에 생성했거나 POST 요청에 대한 201(Created) 응답 후 Location 헤더 필드를 통해 식별된 리소스는 해당 DELETE 요청을 허용하여 해당 작업을 실행 취소할 수 있다. DELETE 메서드가 성공적으로 적용된 경우, DELETE가 성공할 가능성이 높지만 아직 수행 되지 않은 경우 원본 서버는 202 (Accepted) 상태 코드를 반환하거나, DELETE가 수행 되어 추가 정보가 제공되지 않은 경우 204(No Content) 상태 코드를 전송하거나, DELETE가 정상적으로 수행 된 경우 200(OK) 상태 코드를 전송해야 한다. 그리고 body에는 상태를 설명하는 representation을 포함하는 응답 메시지를 전송해야 한다. DELETE 요청 메시지 내의 페이로드에는 정의된 의미가 없으며, DELETE 요청에 따라 페이로드 본문을 전송하면 일부 기존 구현이 요청을 거부할 수 있다. DELETE 메서드에 대한 응답은 캐시할 수 없다. 요청 URI에 대해 하나 이상의 저장된 응답이 있는 캐시를 통해 DELETE 요청이 전달되는 경우 저장된 응답은 무효화 된다. 4.3.6. CONNECT CONNECT 메서드는 수신자에게 요청 대상으로 식별된 대상 서버에 터널(양방향 연결)을 설정하도록 요청하고, 그 후, 터널이 닫힐 때까지 패킷의 블라인드 포워딩으로 동작을 제한한다. 터널은 일반적으로 하나 이상의 프록시를 통해 end-to-end 가상 커넥션을 생성하는 데 사용되며, 이후 TSL(Transport Layer Security)를 사용하여 보안을 유지할 수 있다. CONNECT는 프록시에 대한 요청에서만 사용할 수 있다. 자신에게 CONNECT 요청을 수신한 서버는 2xx (Successful) 상태 코드로 응답하여 커넥션이 설정되었음을 표시한다. 그러나 대부분의 서버는 CONNECT를 구현하지 않는다. CONNECT 요청을 전송하는 클라이언트는 요청 대상의 권한 양식을 전송해야 한다. 즉, 요청 대상은 콜론으로 구분된 터널 대상의 호스트 이름과 포트번호로만 구성된다. CONNECT server.example.com:80 HTTP/1.1 Host: server.example.com:80 수신자 프록시는 request-target에 직접 연결하거나 다른 프록시를 사용하도록 구성된 경우 CONNECT 요청을 다음 인바운드 프록시로 전달하여 터널을 설정할 수 있다. 2xx(Successful) 응답은 발신자(및 모든 인바운드 프록시)가 성공적인 응답의 헤더 부문을 끝내는 빈 줄 바로 뒤에 터널 모드로 전환됨을 나타낸다. 빈 줄 이후에 수신된 데이터는 request-target으로 식별된 서버로부터 수신된다. 성공적인 응답 이외의 응답은 터널이 아직 형성되지 않았으며 커넥션은 HTTP에 의해 통제된 상태로 남아 있음을 나타낸다. 터널 중개자는 어느 한쪽이 커넥션을 닫았음을 감지할 때 터널이 닫힌다: 중개자는 닫힌 쪽에서 온 해결되지 않은 데이터를 다른 쪽으로 보내고, 양쪽 커넥션을 모두 닫은 다음, 전달되지 않은 나머지 데이터는 모두 폐기해야 한다. 프록시 인증을 사용하여 터널 생성 권한을 설정할 수 있다. CONNECT server.example.com:80 HTTP/1.1 Host: server.example.com:80 Proxy-Authorization: basic aGVsbG86d29ybGQ= 임의 서버에 대한 터널을 설정하는 경우, 특히 대상이 웹 트래픽을 대상으로 하지 않는 잘 알려져 있거나 예약된 TCP 포트인 경우 상당한 위험이 있다. 예를 들어 “example.com:25”의 request-target에 대한 CONNECT는 프록시가 SMTP 트래픽을 위해 예약된 포트에 연결하도록 제안할 수 있으며, 허용된 경우 프록시를 속여 스팸 전자 메일을 전달할 수 있다. CONNECT를 지원하는 프록시는 제한된 알려진 포트 집합 또는 안전한 요청 대상의 구성 가능한 화이트리스트로 사용을 제한해야한다. 서버는 2xx(Successful) 응답으로 CONNECT에 Transfer-Encoding 또는 Content-Length 헤더 필드를 전송해서는 안 된다. 클라이언트는 CONNECT에 대한 성공적인 응답으로 수신된 Content-Length 또는 Transfer-Encoding 헤더 필드를 무시해야 한다. CONNECT 요청 메시지 내의 페이로드는 의미론을 정의하지 않는다; CONNECT 요청에 페이로드 본체를 전송하면 일부 기존 구현이 요청을 거부할 수 있다. CONNECT 메서드에 대한 응답은 캐시할 수 없다. CONNECT에 대해선 더 학습이 필요할것같다 4.3.7. OPTIONS OPTION 메서드는 대상 리소스에 사용할 수 있는 통신 옵션에 대한 정보를 오리진 서버 또는 중개자에게 요청한다. 이 메서드를 사용하면 클라이언트가 리소스 작업을 암시하지 않고 리소스 또는 서버의 기능과 관련된 옵션 또는 요구 사항을 결정할 수 있다. ” * “를 요청 대상으로 하는 OPTIONS 요청은 특정 리소스가 아닌 일반적으로 서버에 적용된다. 서버의 통신 옵션은 일반적으로 리소스에 따라 다르기 때문에, “ * “ 요청은 “ping” 또는 “no-op” 유형의 메소드만 유효하며, 클라이언트가 서버의 기능을 테스트할 수 있도록 허용하는것 외에는 아무것도 하지 않는다. 예를 들어, HTTP/1.1 적합성(적합하지 않은지)에 대한 프록시를 테스트하는 데 사용할 수 있다. 요청 대상이 별표가 아닌 경우 OPTION 요청은 대상 리소스와 통신할 때 사용할 수 있는 옵션에 적용된다. OPTION에 대한 성공적인 응답을 생성하는 서버는 이 명세에 정의되지 않은 잠재적 확장을 포함하여 서버가 구현하고 대상 리소스(e.g, Allow)에 적용할 수 있는 선택적 기능을 나타낼 수 있는 헤더 필드를 전송해야한다. 사진처럼 URL에 OPTIONS 헤더를 보내면 allow 헤더를 통해 어떤 메서드를 사용할 수 있는지 나타난다. 응답 페이로드(있는 경우)는 기계나 사람이 읽을 수 있는 representation에서 통신 옵션을 설명할 수도 있다. 이러한 representation에 대한 표준 형식은 이 명세에 의해 정의되지 않지만 HTTP에 대한 향후 확장에 의해 정의될 수 있다. 응답에서 페이로드 본문을 전송하지 않으려면 서버는 “0”의 값을 가진 Content-Length 필드를 생성해야 한다. 클라이언트 OPTIONS 요청의 Max-Forwards 헤더 필드를 요청 체인의 특정 수신자를 대상으로 보낼 수 있다. 요청이 Max-Forwards 필드와 수신되지 않은 경우 프록시는 요청을 전달하는 동안 MaxForwards 헤더 필드를 생성해서는 안 된다. MAX-Forwards에 대해선 이 분의 블로그에 잘 설명 되어 있으므로 참고하길 바란다. 페이로드 본문을 포함하는 OPTIONS 요청을 생성하는 클라이언트는 representation의 미디어 타입 유형을 설명하는 유효한 Content-Type 헤더 필드를 전송해야 한다. 이 명세는 이러한 페이로드에 대한 사용을 정의하지 않지만, 이 후 HTTP에 대한 확장은 OPTIONS 본문을 사용하여 대상 리소스에 대한 보다 상세한 쿼리를 할 수 있다. OPTIONS 메서드에 대한 응답은 캐시 할 수 없다. CORS에서 OPTIONS 메소드를 통해 프리플라이트 요청, 즉 사전 요청을 보내 서버가 해당 parameters를 포함한 요청을 보내도 되는지에 대한 응답을 줄 수 있게 한다. Access-Control-Request-Method 헤더는 프리플라이트 요청의 일부분으로 서버에게 실제 요청이 전달 될 때 POST 요청 메소드로 전달될 것 임을 명시한다. Access-Control-Request-Headers 헤더는 서버에게 실제 요청이 전달될 때 X-PINGOTHER 와 Content-Type custom headers 와 함께 전달될 것 임을 명시한다. 서버는 그럼 이러한 요구사항들에 맞춰 요청을 수락할 것인지 정할 수 있다. OPTIONS /resources/post-here/ HTTP/1.1 Host: bar.other Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Origin: http://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type 아래 응답을 보면 서버는 Access-Control-Allow-Methods로 응답하고, POST, GET 그리고 OPTIONS 메소드를 통해서 해당하는 자원을 query할 수 있음을 알려준다. 이 헤더는 Allow 응답 헤더와 비슷하지만 반드시 CORS에 한해서만 사용된다. HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 Vary: Accept-Encoding, Origin Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 4.3.8. TRACE TRACE 메서드는 요청 메시지의 원격 어플리케이션-레벨 루프백을 요청한다. 요청의 최종 수신자는 아래에 설명된 일부 필드를 제외하고 수신된 메시지를 “message/http”의 내용 유형으로 200(OK) 응답의 메시지 본문으로 클라이언트에 다시 반영해야 한다. 최종 수신자는 요청에서 Max_Forwards의 0값을 수신한 첫 번째 서버 또는 원 서버 이다. 클라이언트는 TRACE 요청에서 응답에 의해 공개될 수 있는 중요한 데이터를 포함하여 헤더필드를 생성해서는 안 된다. 예를 들어 사용자가 에이전트가 저장된 사용자 자격 증명 또는 쿠기를 TRACE 요청으로 전송하는 것은 어리석은 일이다. 요청의 최종 수신자는 응답 본문을 생성할 때 중요한 데이터를 포함할 가능성이 있는 요청 헤더 필드를 제외해야한다. TRACE는 클라이언트가 요청 체인의 다른 쪽 끝에서 수신되는 것을 확인하고 테스트 또는 진단 정보를 위해 해당 데이터를 사용할 수 있도록 한다. via 헤더 필드의 값은 요청 체인의 추적 역할을 하므로 특히 중요하다. Max-Forwards 헤더 필드를 사용하면 클라이언트가 요청 체인의 길이를 제한할 수 있으며, 이는 무한 루프에서 메시지 전달 프록시 체인을 테스트하는데 유용하다. 클라이언트는 TRACE 요청으로 메시지 본문을 보내서는 안된다. TRACE 메서드에 대한 응답은 캐시할 수 없다.</summary></entry><entry><title type="html">HTTP 1.1 Reference - Semantics and Content (3) (최종 수정 날짜 : 2021-02-22)</title><link href="https://lcy960729.github.io/http/2021/02/22/HTTP1-1-Semantics-And-Content(3).html" rel="alternate" type="text/html" title="HTTP 1.1 Reference - Semantics and Content (3) (최종 수정 날짜 : 2021-02-22)" /><published>2021-02-22T00:00:00+09:00</published><updated>2021-02-22T00:00:00+09:00</updated><id>https://lcy960729.github.io/http/2021/02/22/HTTP1-1-Semantics-And-Content(3)</id><content type="html" xml:base="https://lcy960729.github.io/http/2021/02/22/HTTP1-1-Semantics-And-Content(3).html">&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본&lt;br /&gt;
&lt;a href=&quot;https://roka88.dev/106&quot;&gt;https://roka88.dev/106&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MDN Web Docs&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP&quot;&gt;https://developer.mozilla.org/ko/docs/Web/HTTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외 자료는 내용 중 링크 추가&lt;/p&gt;
&lt;h5 id=&quot;틀린-내용-부족한-내용-꼭-지적-부탁드립니다&quot;&gt;틀린 내용, 부족한 내용 꼭 지적 부탁드립니다!&lt;/h5&gt;

&lt;h1 id=&quot;5-request-header-fields&quot;&gt;5. Request Header Fields&lt;/h1&gt;
&lt;p&gt;클라이언트는 요청 헤더 필드를 보내 요청 컨텍스트에 대한 자세한 정보를 제공하거나, 
대상 리소스 상태에 따라 요청을 조건화하거나, 응답에 대한 기본 형식을 제안하거나, 
인증 정보를 제공하거나, 예상 요청 처리를 수정합니다. 
이 필드는 프로그래밍 언어 메서드 호출의 매개 변수와 유사한 요청 수정자 역할을 합니다.&lt;/p&gt;

&lt;h2 id=&quot;51-controls&quot;&gt;5.1. Controls&lt;/h2&gt;
&lt;p&gt;Controls는 요청의 특정 처리를 지시하는 요청 헤더 필드이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Cache-Control&lt;/li&gt;
  &lt;li&gt;Expect&lt;/li&gt;
  &lt;li&gt;Host&lt;/li&gt;
  &lt;li&gt;Max_Forwards&lt;/li&gt;
  &lt;li&gt;Pragma&lt;/li&gt;
  &lt;li&gt;Range&lt;/li&gt;
  &lt;li&gt;TE&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;511-expect&quot;&gt;5.1.1. Expect&lt;/h3&gt;
&lt;p&gt;요청의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Expect&lt;/code&gt; 헤더 필드는 요청을 적절하게 처리하기 위해 서버가 반환할 특정
동작(기대치)을 나타낸다. 이 명세에 의해 정의된 유일한 기대치는 100-continue이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Expect = &quot;100-continue&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Expect filed-value는 대소문자를 구분하지 않는다.&lt;/p&gt;

&lt;p&gt;100(continue) 이외의 417(expectation Failed) 상태 코드로 응답하여 예상하지 못한 기대치를 충족할 수 없음을 나타낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;100 continue&lt;/code&gt; 기대치는 수신자에게 클라이언트가 요청에서 (아마도 큰) 메시지 본문을 전송하기 이전에
100(continue) 임시 응답을 받기를 원함을 알린다 
이를 통해 클라이언트는 실제로 메시지 본문을 보내기 전에 메시지 본문을 보낼 수 있는지 확인 할 수 있으며, 
이는 메시지 본문이 크거나 클라이언트가 오류가 발생할 것으로 예상할 때 효율성을 향상시킬 수 있습니다. 
(e.g, 상태 변경 메서드를 보낼때, 처음으로, 이전에 확인된 인증 자격 없이)&lt;/p&gt;

&lt;p&gt;예를 들어 다음으로 시작하는 요청에서&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT /somewhere/fun HTTP/1.1
Host: origin.example.com 
Content-Type: video/h264 
Content-Length: 1234567890987 
Expect: 100-continue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;클라이언트가 불필요한 데이터 전송으로 파이프를 채우기 시작하기 전에 원서버가 401(Unauthorized) 또는 405(Method Not Allowed)와 같은 
오류 메시지로 즉시 응답할 수 있도록 허용한다.&lt;/p&gt;

&lt;p&gt;클라이언트를 위한 요구사항으로&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클라이언트는 메시지 본문을 포함하지 않는 요청에서 100-continue를 생성해서는 안된다.&lt;/li&gt;
  &lt;li&gt;요청 메시지를 보내기 전에 100(Continue) 응답을 기다리는 클라이언트는 100-continue가 포함된 Expect 헤더 필드를 전송해야 한다.&lt;/li&gt;
  &lt;li&gt;100-continue를 전송하는 클라이언트는 특정 시간 동안 기다릴 필요가 없다. 그러한 클라이언트는 아직 응답을 받지 못했더라도 메시지 본문을 전송하는 것을 계속할 수 있다.&lt;/li&gt;
  &lt;li&gt;또한, 100 (continue) 응답은 HTTP/1.0를 통해 전송할 수 없으므로, 해당 클라이언트는 메시지 본문을 보내기 전에 무기한으로 기다려서는 안 된다.&lt;/li&gt;
  &lt;li&gt;100-continue를 포함하는 요청에 응답하여 417 (Expectation Failed) 상태 코드를 수신하는 클라이언트는 응답 체인이 기대한 것과 다름을 나타낼 뿐이므로 (e.g, HTTP/1.0 서버를 경유함) 100-continue 없이 해당 요청을 반복해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서버를 위한 요구사항으로&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP/1.0 요청에서 100-continue를 수신하는 서버는 해당 기대를 무시해야 한다.&lt;/li&gt;
  &lt;li&gt;서버는 해당 요청에 대한 메시지 본문의 일부 또는 전부를 이미 수신했거나 프레임에 메시지 본문이 없는 것으로 표시된 경우 100(Continue) 응답 전송을 생략할 수 있다.&lt;/li&gt;
  &lt;li&gt;100 (Continue) 응답을 전송하는 서버는 커넥션이 조기에 종료되지 않는 한 메시지 본문이 수신되고 처리되면 최종 상태 코드를 전송해야 한다.&lt;/li&gt;
  &lt;li&gt;전체 메시지 본문을 읽기 전에 최종 상태 코드로 응답하는 서버는 커넥션을 종료할 것인지 또는 요청 메시지를 계속 읽고 폐기할 것인지를 해당 응답에 표시해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;원서버는 request-line 및 헤더 필드만 검사하여 상태를 확인할 수 있는 경우, HTTP/1.1(또는 그 이상) request-line 및 100-continue를 포함하고 
요청 메시지 본문이 따를 것임을 나타내는 전체 헤더 부문을 수신한 후 최종 상태 코드를 사용하여 응답을 즉시 전송하거나, 클라이언트가 요청의 메시지 본문을 보내도록 하기 위해 
100 (Continue) 응답을 즉시 전송해야한다. 원서버는 100(Continue) 응답을 보내기 전에 메시지 본문을 기다려서는 안된다.&lt;/p&gt;

&lt;p&gt;프록시는 request-line 및 헤더 필드만 검사하여 상태를 확인할 수 있는 경우, HTTP/1.1 (또는 그 이상) request-line 및 100-continue를 포함하고 
요청 메시지 본문이 따를 것임을 나타내는 전체 헤더 부문을 수신한 후 최종 상태 코드를 사용하여 응답을 즉시 전송하거나, 해당 request-line 및 헤더 부문을 
다음 인바운드 서버로 전달하며 원서버를 향해 요청을 전송해야 한다. 프록시가 다음 인바운드 서버가 HTTP/1.0만 지원한다고 믿는 경우 (구성 또는 과거 상호 작용에서) 프록시는 클라이언트가 메시지 본문을 보내도록 권장하기 위해
100 (Continue) 응답을 즉시 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;참고: Expect 헤더 필드는 중간 100 (Continue) 응답을 요청하는 수단 및 반드시 이해해야 하는 확장을 표시하는 일반적인 메커니즘으로 
HTTP/1.1의 최초 발행 후 추가 되었다. 그러나 확장 메커니즘은 클라이언트에 의해 사용되지 않았고, 반드시 이해되어야 하는 요구사항은 많은 서버에 의해 구현되지 않아 확장 메커니즘이 무용지물이 되었다.
이 명세는 100-continue 저의와 처리를 단순화하기 위해 확장 메커니즘을 제거하였다.&lt;/p&gt;

&lt;h3 id=&quot;512-max-forwards&quot;&gt;5.1.2. Max-Forwards&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Max-Forwards&lt;/code&gt; 헤더 필드는 요청이 프록시에 의해 전달되는 횟수를 제한하는 TRACE 및 OPTION 요청 메서드와 메커니즘을 제공한다. 
이는 클라이언트가 실패한 것을 보이거나 중간 체인의 루프로 보이는 요청을 추적하려고 할 때 유용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Max-Forwards = 1*DIGIT&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Max-Forwards 값은 이 요청 메시지를 전달할 수 있는 남은 횟수를 나타내는 십진수 정수다.&lt;/p&gt;

&lt;p&gt;Max-Forwards 헤더 필드가 포함된 TRACE 또는 OPTIONS 요청을 수신한 각 중개자는 요청을 전달하기 전에 해당 값을 확인하고 갱신해야 한다.
수신된 값이 0인 경우, 중개자는 요청을 전달하지 않아야 하며, 대신 중개자는 최종 수신자로 응답해야 한다. 
수신한 Max-Forwards 값이 0보다 클 경우, 중개자는 수신한 값이 Max-Forwards에 대해 수신자의 
최대 지원 값 또는 Max-Forwards 필드 값에서 1 감소된 값을 사용하여 전달된 메시지에 갱신된 Max-Forwards 필드를 생성해야한다.&lt;/p&gt;

&lt;p&gt;수신자는 다른 요청 메서드 (OPTIONS, TRACE가 아닐때) 수신한 Max-Forwards 헤더 필드를 무시할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;52-conditionals&quot;&gt;5.2 Conditionals&lt;/h2&gt;
&lt;p&gt;HTTP 조건부 요청 헤더 필드는 클라이언트가 대상 리소스의 상태에 전제 조건을 둘 수 있도록 하여 전제 조건이 거짓으로 평가하면 
메서드 의미론에 해당하는 조치가 적용되지 않도록 한다. 이 명세에 의해 정의된 각 전제조건은 대상 리소스의 이전 representation에서 얻은 검증자 집합과
선택된 representation에 대한 현재 검증자 상태 간의 비교로 구성된다. 따라서 이러한 전제 조건은 대상 리소스의 상태가 클라이언트가 알고 있는 특정 상태 이후 변경되었는지 
여부를 평가한다. 그러한 평가의 효과는 RFC7232의 Section 5(아직 안읽어봄)에서 정의한 조건부 메서드 의미와 선택에 따라 달라진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If-Mactch&lt;/li&gt;
  &lt;li&gt;If-None-Match&lt;/li&gt;
  &lt;li&gt;If-Modified-Since&lt;/li&gt;
  &lt;li&gt;If-Unmodified-Since&lt;/li&gt;
  &lt;li&gt;If-Range&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;53-content-negotitation&quot;&gt;5.3 Content Negotitation&lt;/h2&gt;
&lt;p&gt;다음 요청 헤더 필드는 사용자 에이전트에 의해 응답 내용의 협상을 위해 전송된다. 이러한 필드에서 전송되는 환경설정은 대상 리소스의 representation,
오류 또는 처리 상태의 표현, 프로토콜 내에 나타날 수 있는 기타 텍스트 문자열까지 포함하여 응답의 모든 내용에 적용된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Accept&lt;/li&gt;
  &lt;li&gt;Accept-Charset&lt;/li&gt;
  &lt;li&gt;Accept-Encoding&lt;/li&gt;
  &lt;li&gt;Accept-Language&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;531-quality-values&quot;&gt;5.3.1. Quality Values&lt;/h3&gt;
&lt;p&gt;사전 협상을 위해 많은 요청 헤더 필드는 “q”(대소문자를 구분하지 않음)라는 공통 매개변수를 사용하여 관련 콘텐츠의 선호도에 상대적인 “weight”를 할당한다.
이 가중치를 “quality value” (또는 “qvalue)라고 하는데, 같은 매개변수 이름이 리소스를 위해 선택할 수 있는 다양한 representation의
상대적 품질에 가중치를 할당하기 위해 서버 구성 내에서 자주 사용되기 때문이다.&lt;/p&gt;

&lt;p&gt;가중치는 0에서 1사이의 범위에서 실제 숫자로 정규화되며, 여기서 0.001은 가장 성호되지 않고 1은 가장 선호되며, 0의 값은 “not acceptable”을 의미한다. 
“q” 매개변수가 없는 경우 기본 가중치는 1이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;weight = OWS &quot;;&quot; OWS &quot;q=&quot; qvalue 
qvalue = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
        / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래의 예를 보면 가중치 별로 우선 순위가 정해진다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;text/html and application/xhtml+xml	1.0&lt;/li&gt;
  &lt;li&gt;application/xml	0.9&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;/&lt;/em&gt;	0.8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두번째 예를 보면 가중치가 동일하지만 구체적으로 명시한 값이 우선순위가 높음을 알 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text/html;q=0.8,text/*;q=0.8,*/*;q=0.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;text/html	0.8 (but totally specified)&lt;/li&gt;
  &lt;li&gt;text/*	0.8 (partially specified)&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;/&lt;/em&gt;	0.8 (not specified)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;q값을 보낸 사람은 소수점 이후 세 자리 이상의 숫자를 생성해서는 안 된다.&lt;/p&gt;

&lt;h3 id=&quot;531-accept&quot;&gt;5.3.1. Accept&lt;/h3&gt;
&lt;p&gt;“Accept” 헤더 필드는 사용자 에이전트에서 허용 가능한 응답 미디어 타입을 지정하는 데 사용할 수 있다. 
Accept 헤더 필드는 인라인 이미지 요청의 경우처럼 요청이 특별히 원하는 타입의 작은 집합으로 제한되었음을 나타내는 데 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept = #( media-range [ accept-params ] )
media-range = ( &quot;*/*&quot;
          / ( type &quot;/&quot; &quot;*&quot; )
          / ( type &quot;/&quot; subtype )
          ) *( OWS &quot;;&quot; OWS parameter ) 
accept-params = weight *( accept-ext )
accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;별표 “ * “ 문자는 모든 미디어 타입을 나타내며 “* / * “ 는 해당 유형의 모든 하위 타입을 타나내는 “ type/* “와 함께 미디어 타입을 범위로 그룹화하는 데 사용된다.
미디어 범위는 해당 범위에 적용되는 미디어 타입 매개변수를 포함할 수 있다.&lt;/p&gt;

&lt;p&gt;각 미디어 범위에는 0개 이상의 적용 가능한 미디어 타입 매개변수(charset), 상대 가중치를 나타내는 선택적 “q” 매개변수 및 그 이상의 확장 매개변수가 뒤 따를 수 있따.
“q” 매개변수는 두 매개변수 집합 사이에 구분자 역할을 하기 때문에 확장자(accept-ext)가 있는 경우 필요하다.&lt;/p&gt;

&lt;p&gt;참고 : “q” 매개변수 이름을 사용하여 확장 매개변수 승인에서 미디어 타입 매개변수를 구분하는 것은 과거 관행 때문이다. “q”라는 이름의 미디어 타입 매개변수가 
미디어 범위에 사용될 수 없지만, IANA 미디어 타입 레지스트리에 “q”매개변수가 없고 Accept에 있는 미디어 타입 매개변수가 드물게 사용된다는 점에서 이러한 문제는 
어려울 것으로 생각된다. 미래의 미디어 타입은 “q”라는 매개변수를 동록하는것을 꺼린다.&lt;/p&gt;

&lt;p&gt;예를 들어&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept: audio/*; q=0.2, audio/basic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;는 audio/basic를 선호하지만, 80%의 품질 저하 후 가장 적합한 오디오 타입을 보내달라 라는 의미이다.&lt;/p&gt;

&lt;p&gt;Accept 헤더 필드가 없는 요청은 사용자 에이전트가 응답에 대한 모든 미디어 타입을 수락함을 의미한다.
요청에 헤더 필드가 있고 응답에 사용할 수 있는 representation 중 허용가능한 것으로 나열된 미디어 타입이 없는 경우, 
406(Acceptable) 응답을 전송하여 헤더 필드를 존중하거나, 응답을 협상 대상이 아닌것처럼 처리하여 헤더 필드를 무시할 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 아래는 “text/html과 text/x-c가 동일하게 가중치를 가지는 미디어 타입이지만, 만약 그것들이 존재하지 않는다면,
text/x-dvi 표현을 보내고, 만약 그것이 존재하지 않는다면, text/plain 표현을 보내라”로 해설될 것이다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;미디어 범위는 더 구체적인 미디어 범위 또는 특정 미디어 타입에 의해 재정의 될 수 있다. 두 개 이상의 미디어 범위가 특정 타입에 적용되는 경우 
가장 구체적인 참조가 우선한다. 예를 들면 아래와 같은 우선 순위를 갖는다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept: text/*, text/plain, text/plain;format=flowed, */*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;text/plain;format=flowed&lt;/li&gt;
  &lt;li&gt;text/plain&lt;/li&gt;
  &lt;li&gt;text/*&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;/&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;주어진 형식과 관련된 미디어 타입 품질 가중치는 형식과 일치하는 가장 높은 우선순위의 미디어 범위를 찾아 결정된다.
예를 들면,&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;text/html;level=1    1.0&lt;/li&gt;
  &lt;li&gt;text/html            0.7&lt;/li&gt;
  &lt;li&gt;text/plain           0.3&lt;/li&gt;
  &lt;li&gt;image/jpeg           0.5&lt;/li&gt;
  &lt;li&gt;text/html;level=2    0.4&lt;/li&gt;
  &lt;li&gt;text/html;level=3    0.7&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5번이 6번보다 가중치가 낮지만 높은 레벨을 가지기 때문에 높은 우선순위를 가지게 된다.&lt;/p&gt;

&lt;p&gt;참고 : 사용자 에이전트에 특정 미디어 범위에 대한 기본 품질 값 집합이 제공될 수 있다. 단, 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수 없는
폐쇄형 시스템이 아닌 한, 이 기본 설정은 사용자가 구성해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;533-accept-charset&quot;&gt;5.3.3. Accept-Charset&lt;/h3&gt;
&lt;p&gt;“Accept-Charset” 헤더 필드는 사용자 에이전트가 텍스트 응답 내용에서 허용되는 charset(이하 문자 집합)을 표시하기 위해 전송할 수 있다. 
이 필드는 보다 포괄적이거나 특수 목적의 문자 집합을 이해할 수 있는 사용자 에이전트가 해당 문자 집합 정보를 나타낼 수 있는 원서버에 해당 기능을 수용할 수 있도록 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept-Charset = 1#( ( charset / &quot;*&quot; ) [ weight ] )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용자 에이전트는 5.3.1.에서 정의한 바와 같이 해당문자 집합에 대한 사용자의 상대적 선호도를 나타내기 위해 품질 값을 각 문자 집합과 연결할 수 있다.
예시로는 아래와 같을 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Accept-Charset 필드에 있는 경우 특수 값 “ * “은 Accept-Charset 필드의 다른곳에서 언급되지 않은 모든 문자 집합과 일치한다. 
Accept-Charset 필드에 “ * “가 없는 경우, 필드에 명시적으로 언급되지 않은 모든 문자 집합은 클라이언트에 “not acceptable” 것으로 간주 된다.&lt;/p&gt;

&lt;p&gt;Accept-Charset 헤더 필드가 없는 요청은 사용자 에이전트가 응답에 대한 모든 문자 집합을 수용함을 의미한다. 
대부분의 범용 사용자 에이전트는 특별히 구성 되지 않은 한 Accept-Charset를 발송하지 않는데, 이는 지원되는 문자 집합의 상세 목록을 통해 서버가 사용자 에이전트의 
요청 특성에 따라 개인을 쉽게 식별할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;요청에 Accept-Charset 헤더 필드가 있고 응답에 대해 사용 가능한 표현 중 허용 가능한 것으로 나열된 문자 집합이 없는 경우,
원서버는 406(Not Acceptable) 응답을 전송하여 헤더 필드를 존중하거나 리소스를 콘텐츠 협상의 대상이 아닌 것처럼 처리하여 헤더 필드를 무시할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;534-accept-encoding&quot;&gt;5.3.4. Accept-Encoding&lt;/h3&gt;
&lt;p&gt;사용자 에이전트는 “Accept-Encoding” 헤더 필드를 사용하여 응답에서 허용되는 content-coding 응답을 표시할 수 있다. 
“identity” 토큰은 인코딩이 선호되지 않을때 통신하기 위해 “no encoding”의 동의어로 사용된다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept-Encoding = #( codings [ weight ] ) 
codings = content-coding / &quot;identity&quot; / &quot;*&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 codings 값에는 인코딩에 대한 가중치를 나타내는 관렴 품질 값이 제공될 수 있다. 
Accept-Encoding 필드의 별표 “ * “ 기호는 헤더 필드에 명시적으로 나열되지 않은 사용 가능한 모든 content-coding과 일치한다.
예를 들어,&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0 Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Accept-Encoding 헤더 필드가 없는 요청은 사용자 에이전트에 content-coding에 대한 환결 설정이 없음을 의미한다. 
이것은 서버가 응답에 어떤 content-coding도 사용할 수 있도록 허용하지만, 사용자 에이전트가 모든 인코딩을 올바르게 처리할 수 있음을 의미하지는 않는다.&lt;/p&gt;

&lt;p&gt;서버는 다음 규칙을 사용하여 주어진 표현에 대한 content-coding이 허용되는지 여부를 테스트 한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;요청에 Accept-Encoding 필드가 없는 경우, 모든 content-coding은 사용자 에이전트에 의해 허용 가능한 것으로 간주된다.&lt;/li&gt;
  &lt;li&gt;representation에 content-coding이 없는 경우, “identity”에 대한 더 구체적인 항목 없이 “identity;q=0” 또는 “*;q=0”를 명시하는 Accept-Encoding 필드에 의해 특별히 제외되지 않는 한 기본적으로 허용된다.&lt;/li&gt;
  &lt;li&gt;representation의 content-coding이 Accept-Encoding 필드에 나열된 content-codings 중 하나인 경우, q=0을 동반하지 않는 한 허용된다.&lt;/li&gt;
  &lt;li&gt;여러개의 content-codings가 허용되는 경우, 0이 아닌 q값이 가장 높은 content-coding이 선호된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;field-value가 비어있는 Accept-Encoding 헤더 필드는 사용자 에이전트가 응답에 대한 content-coding을 원하지 않음을 의미한다. 
요청에 Accept-Encoding 헤더 필드가 있고 응답에 대해 사용 가능한 representation 중 허용 가능한 것으로 나열된 content-coding이 없는 경우, 
원 서버는 content-coding 없이 응답을 보내야 한다.&lt;/p&gt;

&lt;p&gt;참고 : 대부분의 HTTP/1.0 응용 프로그램은 content-codings와 관련된 q값을 인식하거나 준수하지 않는다. 
이는 q값이 작동하지 않을 수 있고 x-gzip 또는 x-compress에서 허용되지 않을 수 있음을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;535-accept-language&quot;&gt;5.3.5. Accept-Language&lt;/h3&gt;
&lt;p&gt;사용자 에이전트는 “Accept-Language” 헤더 필드를 사용하여 응답에서 선호하는 자연어 집합을 나타낼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept-Language = 1#( language-range [ weight ] ) 
language-range = &amp;lt;language-range, see [RFC4647], Section 2.1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 language-range는 해당 범위로 지정된 언어에 대한 사용자의 선호도 추정을 나타내는 관련 품질 값을 부여할 수 있다.
예를 들면 한국어를 선호하지만 영국 영어와, 다른 종류의 영어를 받아들일것이다 라는 의미를 아래처럼 표현한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accept-Language: ko, en-gb;q=0.8, en;q=0.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Accept-Language 헤더 필드가 없는 요청은 사용자 에이전트가 응답에 대한 모든 언어를 수용하는 것을 의미한다. 
요청에 헤더 필드가 있고 응답에 사용할 수 있는 표현 중 매칭하는 언어 태그가 없는 경우, 원서버는 응답을 협상 대상이 아닌것처럼
처리하여 헤더 필드를 무시하거나 406(Not Acceptable) 응답을 보내 헤더 필드를 존중할 수 있다. 그러나, 후자는 권장되지 않는다.
그 이유는 사용자가 사용할 수 있는 콘텐츠에 접근하는 것을 막을 수 있기 때문이다.(예: 번역 소프트웨어 사용)&lt;/p&gt;

&lt;p&gt;일부 수신자는 언어 태그가 내림차순 우선순위의 표시로 나열되는 순서를 취급하는데, 특히 동일한 품질 값이 할당된 태그의 경우(어떤 값도 q=1과 동일하지 않음)에 참고한다. 
그러나 이런 행동은 믿을 수 없다. 일관성과 상호 운용성을 극대화 하기 위해, 많은 사용자 에이전트는 각 언어 태그에 고유한 품질 값을 할당하는 동시에 품질을 낮추는 순서로 나열한다.&lt;/p&gt;

&lt;p&gt;모든 요청에서 사용자의 언어 선호도가 완전한 Accept-Language 헤더 필드를 전송하는 것은 사용자의 개인 정보 보호 기대에 반대될 수 있다.&lt;/p&gt;

&lt;p&gt;이해할 수 있는 사항은 개별 사용자에게 매우 의존적이기 때문에, 사용자 에이전트는 (사용자 에이전트 자체의 구성을 통해 또는 사용자 제어 가능한 시스템 설정으로 기본 설정) 
언어 선호에 대한 사용자 제어를 허용해야 한다. 사용자에게 이러한 제어 권한을 제공하지 않는 사용자 에이전트는 언어 허용 헤더 필드를 전송해서는 안 됩니다.&lt;/p&gt;

&lt;p&gt;참고 : 사용자 에이전트는 사용자가 위에서 설명한 언어 매칭의 세부사항을 거의 알지 못하기 때문에 기본 설정을 설정할 때 사용자에게 지침을 제공해야 한다. 
예를 들어, 사용자는 “en-gb”를 선택할 때 영국식 영어를 사용할 수 없는 경우 어떤 종류의 영어 문서도 제공된다고 가정할 수 있다. 이러한 경우 사용자 에이전트는 
더 나은 일치 동작을 위해 목록에 “en”을 추가하도록 제안할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;54-authentication-credentials&quot;&gt;5.4. Authentication Credentials&lt;/h2&gt;
&lt;p&gt;RFC7235에서 정의한 인증 자격 증명을 전달하는 데 두 개의 헤더 필드가 사용된다. 사용자 인증을 위한 다양한 사용자 정의 메커니즘은 
RFC6265에서 정의한 Cookie 헤더 필드를 이러한 목적으로 사용한다는 점에 참고한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Authorization        RFC7235 Section 4.2&lt;/li&gt;
  &lt;li&gt;Proxy-Authorization  RFC7235 Section 4.4&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;55-request-context&quot;&gt;5.5 Request Context&lt;/h2&gt;
&lt;p&gt;다음 요청 헤더 필드는 요청 뒤에 있는 사용자, 사용자 에이전트 및 리소스에 대한 정보를 포함하여 요청 컨텍스트에 대한 추가 정보를 제공한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;From&lt;/li&gt;
  &lt;li&gt;Referer&lt;/li&gt;
  &lt;li&gt;User-Agent&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;551-from&quot;&gt;5.5.1. From&lt;/h3&gt;
&lt;p&gt;“From” 헤더 필드에는 요청된 사용자 에이전트를 제어하는 사용자의 인터넷 전자 메일 주소가 포함되어 있다.
주소는 RFC5322에서 “mailbox”에 의해 정의된 대로 기계적으로 사용할 수 있어야 한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;From = mailbox
mailbox = &amp;lt;mailbox, see [RFC5322], Section 3.4&amp;gt;

From: webmaster@example.org
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From 헤더 필드는 로봇이 아닌 사용자 에이전트에 의해 전송되는 경우가 거의 없다. 사용자 에이전트는 사용자의 개인 정보 보호 또는 
사이트의 보안 정책과 충돌할 수 있으므로 사용자의 명시적 구성 없이 From 헤더 필드를 보내서는 안 된다.&lt;/p&gt;

&lt;p&gt;로봇틱(자동화 기계 의미인듯) 사용자 에이전트는 로봇이 과도한 요청, 원하지 않는 요청 또는 잘못된 요청을 보내는 경우와 같이 서버에서 문제가 발생할 경우 
로봇을 실행할 담당자에게 연락할 수 있도록 유효한 From 헤더 필드를 전송해야 한다.&lt;/p&gt;

&lt;p&gt;대부분의 수신자는 From 헤더 필드 값을 공용 정보로 간주하므로 서버는 접근 제어 또는 인증에 From 헤더 필드를 사용해서는 안 된다.&lt;/p&gt;

&lt;h3 id=&quot;552-referer&quot;&gt;5.5.2. Referer&lt;/h3&gt;
&lt;p&gt;“Referer” 헤더 필드는 사용자 에이전트가 대상 URI를 얻은 리소스에 대한 URI 참조이다.
사용자 에이전트는 Referer 필드 값을 생성 할 때 URI 참조 [RFC3986]의 조각 및 사용자 정보 구성 요소를 포함하지 않아야합니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Referer = absolute-URI / partial-URI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Referer 헤더 필드를 사용하면 서버가 간단한 분석, 로깅, 최적화 된 캐싱 등을 위해 다른 리소스에 대한 백 링크를 생성 할 수 있습니다. 
또한 유지 관리를 위해 오래되거나 잘못 입력 된 링크를 찾을 수 있습니다. 일부 서버는 Referer 헤더 필드를 다른 사이트의 링크를 거부 (소위 “딥 링크”)하거나 
CSRF (교차 사이트 요청 위조)를 제한하는 수단으로 사용하지만 모든 요청이 이를 포함하지는 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Referer: http://www.example.org/hypertext/Overview.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대상 URI가 자체 URI가 없는 소스(예: 사용자 키보드의 입력 또는 사용자의 책갈피/즐겨찾기 내 항목)에서 가져온 경우, 
사용자 에이전트는 Referer 필드를 제외하거나 “about:blank” 값으로 전송해야 합니다.&lt;/p&gt;

&lt;p&gt;Referer 필드는 사용자의 요청 컨텍스트 또는 검색 기록에 대한 정보를 공개 할 수 있습니다. 
이는 참조 리소스의 식별자가 개인 정보 (예 : 계정 이름) 또는 기밀로 간주되는 리소스 (예 : 방화벽 뒤 또는 보안 서비스 내부와 같은). 
대부분의 범용 사용자 에이전트는 참조 리소스가 로컬 “파일”또는 “데이터”URI 인 경우 Referer 헤더 필드를 전송하지 않습니다. 
참조 페이지가 보안 프로토콜로 수신 된 경우 사용자 에이전트는 보안되지 않은 HTTP 요청에서 Referer 헤더 필드를 보내지 않아야합니다.&lt;/p&gt;

&lt;p&gt;일부 중개자는 나가는 요청에서 Referer 헤더 필드를 무차별 적으로 제거하는 것으로 알려져 있습니다. 
이는 사용자에게 훨씬 더 해로울 수있는 CSRF 공격에 대한 보호를 방해하는 불행한 부작용이 있습니다. 
Referer에서 정보 공개를 제한하려는 중개자 및 사용자 에이전트 확장은 내부 도메인 이름을 가명으로 바꾸거나 쿼리 및 / 또는 경로 구성 요소를 자르는 등의 특정 편집에 대한 변경을 제한해야합니다. 
중개자는 필드 값이 요청 대상과 동일한 체계 및 호스트를 공유 할 때 Referer 헤더 필드를 수정하거나 삭제하면 안됩니다.&lt;/p&gt;

&lt;p&gt;간단하게 Referer 요청 헤더는 현재 요청된 페이지 링크 이전의 웹 페이지 주소를 포함한다. Referer 헤더는 사람들이 어디로부터 와서 방문 중인지를 인식할 수 있도록 해주며
해당 데이터는 분석, 로깅, 캐싱 최적화에 사용될 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;553-user-agent&quot;&gt;5.5.3. User-Agent&lt;/h3&gt;
&lt;p&gt;User-Agent 헤더 필드에는 요청을 시작하는 User-Agent에 대한 정보가 포함되어 있으며, 이 정보는 서버에서 보고된 상호 운용성 문제의 범위를 식별하고, 
특정 사용자 에이전트 제한을 방지하고, 브라우저 또는 운영 체제 사용과 관련된 분석을 위해 응답을 조정하기 위해 자주 사용 된다. 
특별히 구성되지 않은 경우 사용자 에이전트는 각 요청에서 User-Agent 필드를 전송 해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;User-Agent = product *( RWS ( product / comment ) )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;User-Agent 필드 값은 하나 이상의 product 식별자로 구성되며, 각각 0개 이상의 주석으로 구성되며, 사용자 에이전트 소프트웨어와 
그 중요한 하위 제품을 함께 식별한다. 관용적으로 product 식별자는 사용자 에이전트 소프트웨어 식별에 대한 중요도의 감소 순서에 따라 나열된다. 
각 product 식별자는 이름과 선택 버전으로 구성 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;product = token [&quot;/&quot; product-version] 
product-version = token
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;발신자는 생성된 product 식별자를 product 식별에 필요한 것으로 제한해야 하며, 발신자는 product 식별자 내에서 광고나 기타 비필수 정보를 생성해서는 안 된다.
발신자는 버전 식별자가 아닌 product-version에서 정보를 생성해서는 안 된다.(즉, 동일한 제품 이름의 연속 버전은 product 식별자의 product-version 부분에서만 달라야 한다.)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_1)
            AppleWebKit/537.36 (KHTML, like Gecko)
            Chrome/88.0.4324.182 
            Safari/537.36
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용자 에이전트는 불필요한 세부 정보가 포함된 User-Agent 필드를 생성해서는 안되며, 제 3자의 하위 제품 추가를 제한해야 한다.
지나치게 길고 상세한 User-Agent 필드 값은 요청 대기 시간을 증가시키고 사용자가 자신의 뜻에 반하여 식별될 위험(“fingerprinting”)을 증가 시킨다.&lt;/p&gt;

&lt;p&gt;마찬가지로, 구현은 필드의 목적을 회피하기 떄문에 다른 구현의 product 토큰을 사용하여 호환성을 선언하지 않도록 권장된다.
사용자 에이전트가 다른 사용자 에이전트로 위장하는 경우, 수신자는 사용 중인 실제 사용자 에이전트에 대해 제대로 작동하지 않더라도 
사용자가 의도적으로 식별된 사용자 에이전트에 적합한 응답을 보기를 원한다고 가정할 수 있다.&lt;/p&gt;

&lt;p&gt;결국엔 내가 어떤 기기를 사용하는지를 알려주고 대부분은 통계 자료로 사용된다고 한다.&lt;/p&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="http" /><category term="Web" /><category term="HTTP1.1" /><summary type="html">참고 자료 이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본 https://roka88.dev/106 MDN Web Docs https://developer.mozilla.org/ko/docs/Web/HTTP 이외 자료는 내용 중 링크 추가 틀린 내용, 부족한 내용 꼭 지적 부탁드립니다! 5. Request Header Fields 클라이언트는 요청 헤더 필드를 보내 요청 컨텍스트에 대한 자세한 정보를 제공하거나, 대상 리소스 상태에 따라 요청을 조건화하거나, 응답에 대한 기본 형식을 제안하거나, 인증 정보를 제공하거나, 예상 요청 처리를 수정합니다. 이 필드는 프로그래밍 언어 메서드 호출의 매개 변수와 유사한 요청 수정자 역할을 합니다. 5.1. Controls Controls는 요청의 특정 처리를 지시하는 요청 헤더 필드이다. Cache-Control Expect Host Max_Forwards Pragma Range TE 5.1.1. Expect 요청의 Expect 헤더 필드는 요청을 적절하게 처리하기 위해 서버가 반환할 특정 동작(기대치)을 나타낸다. 이 명세에 의해 정의된 유일한 기대치는 100-continue이다. Expect = &quot;100-continue&quot; Expect filed-value는 대소문자를 구분하지 않는다. 100(continue) 이외의 417(expectation Failed) 상태 코드로 응답하여 예상하지 못한 기대치를 충족할 수 없음을 나타낼 수 있다. 100 continue 기대치는 수신자에게 클라이언트가 요청에서 (아마도 큰) 메시지 본문을 전송하기 이전에 100(continue) 임시 응답을 받기를 원함을 알린다 이를 통해 클라이언트는 실제로 메시지 본문을 보내기 전에 메시지 본문을 보낼 수 있는지 확인 할 수 있으며, 이는 메시지 본문이 크거나 클라이언트가 오류가 발생할 것으로 예상할 때 효율성을 향상시킬 수 있습니다. (e.g, 상태 변경 메서드를 보낼때, 처음으로, 이전에 확인된 인증 자격 없이) 예를 들어 다음으로 시작하는 요청에서 PUT /somewhere/fun HTTP/1.1 Host: origin.example.com Content-Type: video/h264 Content-Length: 1234567890987 Expect: 100-continue 클라이언트가 불필요한 데이터 전송으로 파이프를 채우기 시작하기 전에 원서버가 401(Unauthorized) 또는 405(Method Not Allowed)와 같은 오류 메시지로 즉시 응답할 수 있도록 허용한다. 클라이언트를 위한 요구사항으로 클라이언트는 메시지 본문을 포함하지 않는 요청에서 100-continue를 생성해서는 안된다. 요청 메시지를 보내기 전에 100(Continue) 응답을 기다리는 클라이언트는 100-continue가 포함된 Expect 헤더 필드를 전송해야 한다. 100-continue를 전송하는 클라이언트는 특정 시간 동안 기다릴 필요가 없다. 그러한 클라이언트는 아직 응답을 받지 못했더라도 메시지 본문을 전송하는 것을 계속할 수 있다. 또한, 100 (continue) 응답은 HTTP/1.0를 통해 전송할 수 없으므로, 해당 클라이언트는 메시지 본문을 보내기 전에 무기한으로 기다려서는 안 된다. 100-continue를 포함하는 요청에 응답하여 417 (Expectation Failed) 상태 코드를 수신하는 클라이언트는 응답 체인이 기대한 것과 다름을 나타낼 뿐이므로 (e.g, HTTP/1.0 서버를 경유함) 100-continue 없이 해당 요청을 반복해야 한다. 서버를 위한 요구사항으로 HTTP/1.0 요청에서 100-continue를 수신하는 서버는 해당 기대를 무시해야 한다. 서버는 해당 요청에 대한 메시지 본문의 일부 또는 전부를 이미 수신했거나 프레임에 메시지 본문이 없는 것으로 표시된 경우 100(Continue) 응답 전송을 생략할 수 있다. 100 (Continue) 응답을 전송하는 서버는 커넥션이 조기에 종료되지 않는 한 메시지 본문이 수신되고 처리되면 최종 상태 코드를 전송해야 한다. 전체 메시지 본문을 읽기 전에 최종 상태 코드로 응답하는 서버는 커넥션을 종료할 것인지 또는 요청 메시지를 계속 읽고 폐기할 것인지를 해당 응답에 표시해야 한다. 원서버는 request-line 및 헤더 필드만 검사하여 상태를 확인할 수 있는 경우, HTTP/1.1(또는 그 이상) request-line 및 100-continue를 포함하고 요청 메시지 본문이 따를 것임을 나타내는 전체 헤더 부문을 수신한 후 최종 상태 코드를 사용하여 응답을 즉시 전송하거나, 클라이언트가 요청의 메시지 본문을 보내도록 하기 위해 100 (Continue) 응답을 즉시 전송해야한다. 원서버는 100(Continue) 응답을 보내기 전에 메시지 본문을 기다려서는 안된다. 프록시는 request-line 및 헤더 필드만 검사하여 상태를 확인할 수 있는 경우, HTTP/1.1 (또는 그 이상) request-line 및 100-continue를 포함하고 요청 메시지 본문이 따를 것임을 나타내는 전체 헤더 부문을 수신한 후 최종 상태 코드를 사용하여 응답을 즉시 전송하거나, 해당 request-line 및 헤더 부문을 다음 인바운드 서버로 전달하며 원서버를 향해 요청을 전송해야 한다. 프록시가 다음 인바운드 서버가 HTTP/1.0만 지원한다고 믿는 경우 (구성 또는 과거 상호 작용에서) 프록시는 클라이언트가 메시지 본문을 보내도록 권장하기 위해 100 (Continue) 응답을 즉시 생성할 수 있다. 참고: Expect 헤더 필드는 중간 100 (Continue) 응답을 요청하는 수단 및 반드시 이해해야 하는 확장을 표시하는 일반적인 메커니즘으로 HTTP/1.1의 최초 발행 후 추가 되었다. 그러나 확장 메커니즘은 클라이언트에 의해 사용되지 않았고, 반드시 이해되어야 하는 요구사항은 많은 서버에 의해 구현되지 않아 확장 메커니즘이 무용지물이 되었다. 이 명세는 100-continue 저의와 처리를 단순화하기 위해 확장 메커니즘을 제거하였다. 5.1.2. Max-Forwards Max-Forwards 헤더 필드는 요청이 프록시에 의해 전달되는 횟수를 제한하는 TRACE 및 OPTION 요청 메서드와 메커니즘을 제공한다. 이는 클라이언트가 실패한 것을 보이거나 중간 체인의 루프로 보이는 요청을 추적하려고 할 때 유용할 수 있다. Max-Forwards = 1*DIGIT Max-Forwards 값은 이 요청 메시지를 전달할 수 있는 남은 횟수를 나타내는 십진수 정수다. Max-Forwards 헤더 필드가 포함된 TRACE 또는 OPTIONS 요청을 수신한 각 중개자는 요청을 전달하기 전에 해당 값을 확인하고 갱신해야 한다. 수신된 값이 0인 경우, 중개자는 요청을 전달하지 않아야 하며, 대신 중개자는 최종 수신자로 응답해야 한다. 수신한 Max-Forwards 값이 0보다 클 경우, 중개자는 수신한 값이 Max-Forwards에 대해 수신자의 최대 지원 값 또는 Max-Forwards 필드 값에서 1 감소된 값을 사용하여 전달된 메시지에 갱신된 Max-Forwards 필드를 생성해야한다. 수신자는 다른 요청 메서드 (OPTIONS, TRACE가 아닐때) 수신한 Max-Forwards 헤더 필드를 무시할 수 있다. 5.2 Conditionals HTTP 조건부 요청 헤더 필드는 클라이언트가 대상 리소스의 상태에 전제 조건을 둘 수 있도록 하여 전제 조건이 거짓으로 평가하면 메서드 의미론에 해당하는 조치가 적용되지 않도록 한다. 이 명세에 의해 정의된 각 전제조건은 대상 리소스의 이전 representation에서 얻은 검증자 집합과 선택된 representation에 대한 현재 검증자 상태 간의 비교로 구성된다. 따라서 이러한 전제 조건은 대상 리소스의 상태가 클라이언트가 알고 있는 특정 상태 이후 변경되었는지 여부를 평가한다. 그러한 평가의 효과는 RFC7232의 Section 5(아직 안읽어봄)에서 정의한 조건부 메서드 의미와 선택에 따라 달라진다. If-Mactch If-None-Match If-Modified-Since If-Unmodified-Since If-Range 5.3 Content Negotitation 다음 요청 헤더 필드는 사용자 에이전트에 의해 응답 내용의 협상을 위해 전송된다. 이러한 필드에서 전송되는 환경설정은 대상 리소스의 representation, 오류 또는 처리 상태의 표현, 프로토콜 내에 나타날 수 있는 기타 텍스트 문자열까지 포함하여 응답의 모든 내용에 적용된다. Accept Accept-Charset Accept-Encoding Accept-Language 5.3.1. Quality Values 사전 협상을 위해 많은 요청 헤더 필드는 “q”(대소문자를 구분하지 않음)라는 공통 매개변수를 사용하여 관련 콘텐츠의 선호도에 상대적인 “weight”를 할당한다. 이 가중치를 “quality value” (또는 “qvalue)라고 하는데, 같은 매개변수 이름이 리소스를 위해 선택할 수 있는 다양한 representation의 상대적 품질에 가중치를 할당하기 위해 서버 구성 내에서 자주 사용되기 때문이다. 가중치는 0에서 1사이의 범위에서 실제 숫자로 정규화되며, 여기서 0.001은 가장 성호되지 않고 1은 가장 선호되며, 0의 값은 “not acceptable”을 의미한다. “q” 매개변수가 없는 경우 기본 가중치는 1이다. weight = OWS &quot;;&quot; OWS &quot;q=&quot; qvalue qvalue = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] ) / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] ) 아래의 예를 보면 가중치 별로 우선 순위가 정해진다. text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 text/html and application/xhtml+xml 1.0 application/xml 0.9 / 0.8 두번째 예를 보면 가중치가 동일하지만 구체적으로 명시한 값이 우선순위가 높음을 알 수 있다. text/html;q=0.8,text/*;q=0.8,*/*;q=0.8 text/html 0.8 (but totally specified) text/* 0.8 (partially specified) / 0.8 (not specified) q값을 보낸 사람은 소수점 이후 세 자리 이상의 숫자를 생성해서는 안 된다. 5.3.1. Accept “Accept” 헤더 필드는 사용자 에이전트에서 허용 가능한 응답 미디어 타입을 지정하는 데 사용할 수 있다. Accept 헤더 필드는 인라인 이미지 요청의 경우처럼 요청이 특별히 원하는 타입의 작은 집합으로 제한되었음을 나타내는 데 사용할 수 있다. Accept = #( media-range [ accept-params ] ) media-range = ( &quot;*/*&quot; / ( type &quot;/&quot; &quot;*&quot; ) / ( type &quot;/&quot; subtype ) ) *( OWS &quot;;&quot; OWS parameter ) accept-params = weight *( accept-ext ) accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ] 별표 “ * “ 문자는 모든 미디어 타입을 나타내며 “* / * “ 는 해당 유형의 모든 하위 타입을 타나내는 “ type/* “와 함께 미디어 타입을 범위로 그룹화하는 데 사용된다. 미디어 범위는 해당 범위에 적용되는 미디어 타입 매개변수를 포함할 수 있다. 각 미디어 범위에는 0개 이상의 적용 가능한 미디어 타입 매개변수(charset), 상대 가중치를 나타내는 선택적 “q” 매개변수 및 그 이상의 확장 매개변수가 뒤 따를 수 있따. “q” 매개변수는 두 매개변수 집합 사이에 구분자 역할을 하기 때문에 확장자(accept-ext)가 있는 경우 필요하다. 참고 : “q” 매개변수 이름을 사용하여 확장 매개변수 승인에서 미디어 타입 매개변수를 구분하는 것은 과거 관행 때문이다. “q”라는 이름의 미디어 타입 매개변수가 미디어 범위에 사용될 수 없지만, IANA 미디어 타입 레지스트리에 “q”매개변수가 없고 Accept에 있는 미디어 타입 매개변수가 드물게 사용된다는 점에서 이러한 문제는 어려울 것으로 생각된다. 미래의 미디어 타입은 “q”라는 매개변수를 동록하는것을 꺼린다. 예를 들어 Accept: audio/*; q=0.2, audio/basic 는 audio/basic를 선호하지만, 80%의 품질 저하 후 가장 적합한 오디오 타입을 보내달라 라는 의미이다. Accept 헤더 필드가 없는 요청은 사용자 에이전트가 응답에 대한 모든 미디어 타입을 수락함을 의미한다. 요청에 헤더 필드가 있고 응답에 사용할 수 있는 representation 중 허용가능한 것으로 나열된 미디어 타입이 없는 경우, 406(Acceptable) 응답을 전송하여 헤더 필드를 존중하거나, 응답을 협상 대상이 아닌것처럼 처리하여 헤더 필드를 무시할 수 있다. 예를 들어 아래는 “text/html과 text/x-c가 동일하게 가중치를 가지는 미디어 타입이지만, 만약 그것들이 존재하지 않는다면, text/x-dvi 표현을 보내고, 만약 그것이 존재하지 않는다면, text/plain 표현을 보내라”로 해설될 것이다. Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c 미디어 범위는 더 구체적인 미디어 범위 또는 특정 미디어 타입에 의해 재정의 될 수 있다. 두 개 이상의 미디어 범위가 특정 타입에 적용되는 경우 가장 구체적인 참조가 우선한다. 예를 들면 아래와 같은 우선 순위를 갖는다. Accept: text/*, text/plain, text/plain;format=flowed, */* text/plain;format=flowed text/plain text/* / 주어진 형식과 관련된 미디어 타입 품질 가중치는 형식과 일치하는 가장 높은 우선순위의 미디어 범위를 찾아 결정된다. 예를 들면, Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5 text/html;level=1 1.0 text/html 0.7 text/plain 0.3 image/jpeg 0.5 text/html;level=2 0.4 text/html;level=3 0.7 5번이 6번보다 가중치가 낮지만 높은 레벨을 가지기 때문에 높은 우선순위를 가지게 된다. 참고 : 사용자 에이전트에 특정 미디어 범위에 대한 기본 품질 값 집합이 제공될 수 있다. 단, 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수 없는 폐쇄형 시스템이 아닌 한, 이 기본 설정은 사용자가 구성해야 한다. 5.3.3. Accept-Charset “Accept-Charset” 헤더 필드는 사용자 에이전트가 텍스트 응답 내용에서 허용되는 charset(이하 문자 집합)을 표시하기 위해 전송할 수 있다. 이 필드는 보다 포괄적이거나 특수 목적의 문자 집합을 이해할 수 있는 사용자 에이전트가 해당 문자 집합 정보를 나타낼 수 있는 원서버에 해당 기능을 수용할 수 있도록 한다. Accept-Charset = 1#( ( charset / &quot;*&quot; ) [ weight ] ) 사용자 에이전트는 5.3.1.에서 정의한 바와 같이 해당문자 집합에 대한 사용자의 상대적 선호도를 나타내기 위해 품질 값을 각 문자 집합과 연결할 수 있다. 예시로는 아래와 같을 수 있다. Accept-Charset: iso-8859-5, unicode-1-1;q=0.8 Accept-Charset 필드에 있는 경우 특수 값 “ * “은 Accept-Charset 필드의 다른곳에서 언급되지 않은 모든 문자 집합과 일치한다. Accept-Charset 필드에 “ * “가 없는 경우, 필드에 명시적으로 언급되지 않은 모든 문자 집합은 클라이언트에 “not acceptable” 것으로 간주 된다. Accept-Charset 헤더 필드가 없는 요청은 사용자 에이전트가 응답에 대한 모든 문자 집합을 수용함을 의미한다. 대부분의 범용 사용자 에이전트는 특별히 구성 되지 않은 한 Accept-Charset를 발송하지 않는데, 이는 지원되는 문자 집합의 상세 목록을 통해 서버가 사용자 에이전트의 요청 특성에 따라 개인을 쉽게 식별할 수 있기 때문이다. 요청에 Accept-Charset 헤더 필드가 있고 응답에 대해 사용 가능한 표현 중 허용 가능한 것으로 나열된 문자 집합이 없는 경우, 원서버는 406(Not Acceptable) 응답을 전송하여 헤더 필드를 존중하거나 리소스를 콘텐츠 협상의 대상이 아닌 것처럼 처리하여 헤더 필드를 무시할 수 있다. 5.3.4. Accept-Encoding 사용자 에이전트는 “Accept-Encoding” 헤더 필드를 사용하여 응답에서 허용되는 content-coding 응답을 표시할 수 있다. “identity” 토큰은 인코딩이 선호되지 않을때 통신하기 위해 “no encoding”의 동의어로 사용된다. Accept-Encoding = #( codings [ weight ] ) codings = content-coding / &quot;identity&quot; / &quot;*&quot; 각 codings 값에는 인코딩에 대한 가중치를 나타내는 관렴 품질 값이 제공될 수 있다. Accept-Encoding 필드의 별표 “ * “ 기호는 헤더 필드에 명시적으로 나열되지 않은 사용 가능한 모든 content-coding과 일치한다. 예를 들어, Accept-Encoding: compress, gzip Accept-Encoding: Accept-Encoding: * Accept-Encoding: compress;q=0.5, gzip;q=1.0 Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0 Accept-Encoding 헤더 필드가 없는 요청은 사용자 에이전트에 content-coding에 대한 환결 설정이 없음을 의미한다. 이것은 서버가 응답에 어떤 content-coding도 사용할 수 있도록 허용하지만, 사용자 에이전트가 모든 인코딩을 올바르게 처리할 수 있음을 의미하지는 않는다. 서버는 다음 규칙을 사용하여 주어진 표현에 대한 content-coding이 허용되는지 여부를 테스트 한다. 요청에 Accept-Encoding 필드가 없는 경우, 모든 content-coding은 사용자 에이전트에 의해 허용 가능한 것으로 간주된다. representation에 content-coding이 없는 경우, “identity”에 대한 더 구체적인 항목 없이 “identity;q=0” 또는 “*;q=0”를 명시하는 Accept-Encoding 필드에 의해 특별히 제외되지 않는 한 기본적으로 허용된다. representation의 content-coding이 Accept-Encoding 필드에 나열된 content-codings 중 하나인 경우, q=0을 동반하지 않는 한 허용된다. 여러개의 content-codings가 허용되는 경우, 0이 아닌 q값이 가장 높은 content-coding이 선호된다. field-value가 비어있는 Accept-Encoding 헤더 필드는 사용자 에이전트가 응답에 대한 content-coding을 원하지 않음을 의미한다. 요청에 Accept-Encoding 헤더 필드가 있고 응답에 대해 사용 가능한 representation 중 허용 가능한 것으로 나열된 content-coding이 없는 경우, 원 서버는 content-coding 없이 응답을 보내야 한다. 참고 : 대부분의 HTTP/1.0 응용 프로그램은 content-codings와 관련된 q값을 인식하거나 준수하지 않는다. 이는 q값이 작동하지 않을 수 있고 x-gzip 또는 x-compress에서 허용되지 않을 수 있음을 의미한다. 5.3.5. Accept-Language 사용자 에이전트는 “Accept-Language” 헤더 필드를 사용하여 응답에서 선호하는 자연어 집합을 나타낼 수 있다. Accept-Language = 1#( language-range [ weight ] ) language-range = &amp;lt;language-range, see [RFC4647], Section 2.1&amp;gt; 각 language-range는 해당 범위로 지정된 언어에 대한 사용자의 선호도 추정을 나타내는 관련 품질 값을 부여할 수 있다. 예를 들면 한국어를 선호하지만 영국 영어와, 다른 종류의 영어를 받아들일것이다 라는 의미를 아래처럼 표현한다. Accept-Language: ko, en-gb;q=0.8, en;q=0.7 Accept-Language 헤더 필드가 없는 요청은 사용자 에이전트가 응답에 대한 모든 언어를 수용하는 것을 의미한다. 요청에 헤더 필드가 있고 응답에 사용할 수 있는 표현 중 매칭하는 언어 태그가 없는 경우, 원서버는 응답을 협상 대상이 아닌것처럼 처리하여 헤더 필드를 무시하거나 406(Not Acceptable) 응답을 보내 헤더 필드를 존중할 수 있다. 그러나, 후자는 권장되지 않는다. 그 이유는 사용자가 사용할 수 있는 콘텐츠에 접근하는 것을 막을 수 있기 때문이다.(예: 번역 소프트웨어 사용) 일부 수신자는 언어 태그가 내림차순 우선순위의 표시로 나열되는 순서를 취급하는데, 특히 동일한 품질 값이 할당된 태그의 경우(어떤 값도 q=1과 동일하지 않음)에 참고한다. 그러나 이런 행동은 믿을 수 없다. 일관성과 상호 운용성을 극대화 하기 위해, 많은 사용자 에이전트는 각 언어 태그에 고유한 품질 값을 할당하는 동시에 품질을 낮추는 순서로 나열한다. 모든 요청에서 사용자의 언어 선호도가 완전한 Accept-Language 헤더 필드를 전송하는 것은 사용자의 개인 정보 보호 기대에 반대될 수 있다. 이해할 수 있는 사항은 개별 사용자에게 매우 의존적이기 때문에, 사용자 에이전트는 (사용자 에이전트 자체의 구성을 통해 또는 사용자 제어 가능한 시스템 설정으로 기본 설정) 언어 선호에 대한 사용자 제어를 허용해야 한다. 사용자에게 이러한 제어 권한을 제공하지 않는 사용자 에이전트는 언어 허용 헤더 필드를 전송해서는 안 됩니다. 참고 : 사용자 에이전트는 사용자가 위에서 설명한 언어 매칭의 세부사항을 거의 알지 못하기 때문에 기본 설정을 설정할 때 사용자에게 지침을 제공해야 한다. 예를 들어, 사용자는 “en-gb”를 선택할 때 영국식 영어를 사용할 수 없는 경우 어떤 종류의 영어 문서도 제공된다고 가정할 수 있다. 이러한 경우 사용자 에이전트는 더 나은 일치 동작을 위해 목록에 “en”을 추가하도록 제안할 수 있다. 5.4. Authentication Credentials RFC7235에서 정의한 인증 자격 증명을 전달하는 데 두 개의 헤더 필드가 사용된다. 사용자 인증을 위한 다양한 사용자 정의 메커니즘은 RFC6265에서 정의한 Cookie 헤더 필드를 이러한 목적으로 사용한다는 점에 참고한다. Authorization RFC7235 Section 4.2 Proxy-Authorization RFC7235 Section 4.4 5.5 Request Context 다음 요청 헤더 필드는 요청 뒤에 있는 사용자, 사용자 에이전트 및 리소스에 대한 정보를 포함하여 요청 컨텍스트에 대한 추가 정보를 제공한다. From Referer User-Agent 5.5.1. From “From” 헤더 필드에는 요청된 사용자 에이전트를 제어하는 사용자의 인터넷 전자 메일 주소가 포함되어 있다. 주소는 RFC5322에서 “mailbox”에 의해 정의된 대로 기계적으로 사용할 수 있어야 한다. From = mailbox mailbox = &amp;lt;mailbox, see [RFC5322], Section 3.4&amp;gt; From: webmaster@example.org From 헤더 필드는 로봇이 아닌 사용자 에이전트에 의해 전송되는 경우가 거의 없다. 사용자 에이전트는 사용자의 개인 정보 보호 또는 사이트의 보안 정책과 충돌할 수 있으므로 사용자의 명시적 구성 없이 From 헤더 필드를 보내서는 안 된다. 로봇틱(자동화 기계 의미인듯) 사용자 에이전트는 로봇이 과도한 요청, 원하지 않는 요청 또는 잘못된 요청을 보내는 경우와 같이 서버에서 문제가 발생할 경우 로봇을 실행할 담당자에게 연락할 수 있도록 유효한 From 헤더 필드를 전송해야 한다. 대부분의 수신자는 From 헤더 필드 값을 공용 정보로 간주하므로 서버는 접근 제어 또는 인증에 From 헤더 필드를 사용해서는 안 된다. 5.5.2. Referer “Referer” 헤더 필드는 사용자 에이전트가 대상 URI를 얻은 리소스에 대한 URI 참조이다. 사용자 에이전트는 Referer 필드 값을 생성 할 때 URI 참조 [RFC3986]의 조각 및 사용자 정보 구성 요소를 포함하지 않아야합니다. Referer = absolute-URI / partial-URI Referer 헤더 필드를 사용하면 서버가 간단한 분석, 로깅, 최적화 된 캐싱 등을 위해 다른 리소스에 대한 백 링크를 생성 할 수 있습니다. 또한 유지 관리를 위해 오래되거나 잘못 입력 된 링크를 찾을 수 있습니다. 일부 서버는 Referer 헤더 필드를 다른 사이트의 링크를 거부 (소위 “딥 링크”)하거나 CSRF (교차 사이트 요청 위조)를 제한하는 수단으로 사용하지만 모든 요청이 이를 포함하지는 않습니다. Referer: http://www.example.org/hypertext/Overview.html 대상 URI가 자체 URI가 없는 소스(예: 사용자 키보드의 입력 또는 사용자의 책갈피/즐겨찾기 내 항목)에서 가져온 경우, 사용자 에이전트는 Referer 필드를 제외하거나 “about:blank” 값으로 전송해야 합니다. Referer 필드는 사용자의 요청 컨텍스트 또는 검색 기록에 대한 정보를 공개 할 수 있습니다. 이는 참조 리소스의 식별자가 개인 정보 (예 : 계정 이름) 또는 기밀로 간주되는 리소스 (예 : 방화벽 뒤 또는 보안 서비스 내부와 같은). 대부분의 범용 사용자 에이전트는 참조 리소스가 로컬 “파일”또는 “데이터”URI 인 경우 Referer 헤더 필드를 전송하지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우 사용자 에이전트는 보안되지 않은 HTTP 요청에서 Referer 헤더 필드를 보내지 않아야합니다. 일부 중개자는 나가는 요청에서 Referer 헤더 필드를 무차별 적으로 제거하는 것으로 알려져 있습니다. 이는 사용자에게 훨씬 더 해로울 수있는 CSRF 공격에 대한 보호를 방해하는 불행한 부작용이 있습니다. Referer에서 정보 공개를 제한하려는 중개자 및 사용자 에이전트 확장은 내부 도메인 이름을 가명으로 바꾸거나 쿼리 및 / 또는 경로 구성 요소를 자르는 등의 특정 편집에 대한 변경을 제한해야합니다. 중개자는 필드 값이 요청 대상과 동일한 체계 및 호스트를 공유 할 때 Referer 헤더 필드를 수정하거나 삭제하면 안됩니다. 간단하게 Referer 요청 헤더는 현재 요청된 페이지 링크 이전의 웹 페이지 주소를 포함한다. Referer 헤더는 사람들이 어디로부터 와서 방문 중인지를 인식할 수 있도록 해주며 해당 데이터는 분석, 로깅, 캐싱 최적화에 사용될 수도 있다. 5.5.3. User-Agent User-Agent 헤더 필드에는 요청을 시작하는 User-Agent에 대한 정보가 포함되어 있으며, 이 정보는 서버에서 보고된 상호 운용성 문제의 범위를 식별하고, 특정 사용자 에이전트 제한을 방지하고, 브라우저 또는 운영 체제 사용과 관련된 분석을 위해 응답을 조정하기 위해 자주 사용 된다. 특별히 구성되지 않은 경우 사용자 에이전트는 각 요청에서 User-Agent 필드를 전송 해야 한다. User-Agent = product *( RWS ( product / comment ) ) User-Agent 필드 값은 하나 이상의 product 식별자로 구성되며, 각각 0개 이상의 주석으로 구성되며, 사용자 에이전트 소프트웨어와 그 중요한 하위 제품을 함께 식별한다. 관용적으로 product 식별자는 사용자 에이전트 소프트웨어 식별에 대한 중요도의 감소 순서에 따라 나열된다. 각 product 식별자는 이름과 선택 버전으로 구성 된다. product = token [&quot;/&quot; product-version] product-version = token 발신자는 생성된 product 식별자를 product 식별에 필요한 것으로 제한해야 하며, 발신자는 product 식별자 내에서 광고나 기타 비필수 정보를 생성해서는 안 된다. 발신자는 버전 식별자가 아닌 product-version에서 정보를 생성해서는 안 된다.(즉, 동일한 제품 이름의 연속 버전은 product 식별자의 product-version 부분에서만 달라야 한다.) User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36 사용자 에이전트는 불필요한 세부 정보가 포함된 User-Agent 필드를 생성해서는 안되며, 제 3자의 하위 제품 추가를 제한해야 한다. 지나치게 길고 상세한 User-Agent 필드 값은 요청 대기 시간을 증가시키고 사용자가 자신의 뜻에 반하여 식별될 위험(“fingerprinting”)을 증가 시킨다. 마찬가지로, 구현은 필드의 목적을 회피하기 떄문에 다른 구현의 product 토큰을 사용하여 호환성을 선언하지 않도록 권장된다. 사용자 에이전트가 다른 사용자 에이전트로 위장하는 경우, 수신자는 사용 중인 실제 사용자 에이전트에 대해 제대로 작동하지 않더라도 사용자가 의도적으로 식별된 사용자 에이전트에 적합한 응답을 보기를 원한다고 가정할 수 있다. 결국엔 내가 어떤 기기를 사용하는지를 알려주고 대부분은 통계 자료로 사용된다고 한다.</summary></entry><entry><title type="html">Spring Security의 기능 (최종 수정 날짜 : 2021-02-22)</title><link href="https://lcy960729.github.io/spring-security/2021/02/07/Spring-Security%EC%9D%98-%EA%B8%B0%EB%8A%A5.html" rel="alternate" type="text/html" title="Spring Security의 기능 (최종 수정 날짜 : 2021-02-22)" /><published>2021-02-07T00:00:00+09:00</published><updated>2021-02-07T00:00:00+09:00</updated><id>https://lcy960729.github.io/spring-security/2021/02/07/Spring-Security%EC%9D%98-%EA%B8%B0%EB%8A%A5</id><content type="html" xml:base="https://lcy960729.github.io/spring-security/2021/02/07/Spring-Security%EC%9D%98-%EA%B8%B0%EB%8A%A5.html">&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 시큐리티 레퍼런스&lt;br /&gt;
&lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/5.4.2/reference/html5/&quot;&gt;https://docs.spring.io/spring-security/site/docs/5.4.2/reference/html5/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외 자료는 내용 중 링크 추가&lt;/p&gt;
&lt;h5 id=&quot;틀린-내용-부족한-내용-꼭-지적-부탁드립니다&quot;&gt;틀린 내용, 부족한 내용 꼭 지적 부탁드립니다!&lt;/h5&gt;

&lt;h1 id=&quot;1-스프링-시큐리티의-기능&quot;&gt;1. 스프링 시큐리티의 기능&lt;/h1&gt;
&lt;p&gt;스프링 시큐리티는 인증, 권한 부여, 및 보호에 대한 종합적인 지원을 하며 단순하게 사용하기 위해 다른 라이브러리와의 통합을 제공한다.&lt;/p&gt;

&lt;h2 id=&quot;11-인증-authentication&quot;&gt;1.1. 인증 (Authentication)&lt;/h2&gt;
&lt;p&gt;인증은 특정 리소스에 접근하려는 주체의 신원을 확인하는 것이다. 사용자를 인증하는 일반적인 방법은 사용자에게 이름과 비밀번호를 입력하도록 요구하는것이다. 인증이 수행되면 사용자의 신원(아이디와 비밀번호)을 알게 되며 신원을 인증 할 수 있게 된다. 스프링 시큐리티는 사용자 인증을 위한 기능을 내장하여 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;111-authentication-support&quot;&gt;1.1.1. Authentication Support&lt;/h3&gt;
&lt;p&gt;Spring Security는 사용자 인증을위한 내장 지원을 제공합니다.&lt;/p&gt;

&lt;h3 id=&quot;112-password-storage&quot;&gt;1.1.2. Password Storage&lt;/h3&gt;
&lt;p&gt;스프링 시큐리티의 PasswordEncoder 인터페이스는 비밀번호를 안전하게 저장할 수 있도록 비밀번호의 단방향 변환을 수행하는데 사용된다. PasswordEncoder는 단방향 변환이므로 양방향이 필요한 경우(데이터 베이스 인증에 사용되는 자격 증명 저장)에는 사용할 수 없다. 일반적으로 PasswordEncoder는 인증시 사용자가 제공한 암호와 비교해야하는 암호를 저장하는데 사용 된다.&lt;/p&gt;

&lt;h4 id=&quot;password-storage-history&quot;&gt;Password Storage History&lt;/h4&gt;
&lt;p&gt;처음의 암호는 일반 텍스트로 저장되었다. 텍스트로 저장하던 때의 암호는 데이터 저장소에 저장 되었으며 이 저장소에 접근 하기위해선 자격 증명이 필요했기 때문에 개발자들은 충분히 안전하다고 생각했다. 그러나 악의적인 사용자가 SQL Injection과 같은 공격을 사용하여 대규모의 사용자 정보를 얻는 방법이 나타났고 이후부터 암호를 더 강력히 보호 해야함을 깨달았다.&lt;/p&gt;

&lt;p&gt;이후 SHA-256과 같은 단방향 해시를 통해 암호를 저장하도록 권장되었다. 해시로 주어진 암호는 전수공격하여 계산하기에 큰 어려움이 있었기 때문에 안전하다 생각하였다(현재 하드웨어 기준으론 아님). 하지만 해시를 이용한 방법도 Rainbow Tables(해시 함수로 변환 가능한 모든 해시 값을 저장시켜 놓은 조회 테이블)로 인해 해시로 저장된 비밀번호만 있으면 원래의 비밀번호를 추출할 수 있는 문제가 생겼다.&lt;/p&gt;

&lt;p&gt;개발자들은 이러한 Rainbow Tables의 효과를 막기 위해 개발자는 솔트된 암호를 사용하였다. 솔트된 암호란 해시 함수에 대한 입력으로 암호만 사용하는 대신 모든 사용자의 암호에 대해 임의의 바이트(솔트)가 생성 된다. 솔트와 입력된 사용자의 비밀번호는 해시 함수를 통해 고유한 해시값을 생성하게 된다. 사용자가 인증을 시도하면 사용자 입력 암호와 솔트를 이용하여 해시 함수를 통해 해시 값을 만들어낸다. 만들어진 해시 값을 저장소에 저장된 고유한 해시값과 비교하게 된다. 솔트 값은 모든 암호마다 다르기 때문에 RainbowTables를 이용하여 비밀번호를 복호화 할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;현재는 이러한 해시 함수 또한 하드웨어의 발전으로 안전하지 않게 되었다(SHA-256을 초당 백만, 천만번 씩 수행할 수 있게 됨). 개발자들은 Adaptive one-way function을 이용하여 암호를 저장하는 방식을 발전하였다. Adaptive one-way function을 사용하는 암호의 유효성 검사는 의도적으로 하드웨어 리소스를 사용하여 암호화 시간을 조절 할 수 있다. 암호화 작업 시간은 1초가 적당하다. Spring Security는 사용자가 직접 암호화 작업 시간을 정의 하도록 하였다. 스프링 시큐리티가 제공하는 Adaptive one-way function을 사용하는 암호화 방식은 bcrypt, PBKDF2, scrypt, argon2가 있다.&lt;/p&gt;

&lt;p&gt;위에 소개한 내용으로 스프링 시큐리티가 왜 이러한 암호화 방식을 채택했는지 이해 됐을것이다. 이후엔 스프링 시큐리티가 PasswordEncoder에 대해서 알아보겠다.&lt;/p&gt;

&lt;h4 id=&quot;delegatingpasswordencoder&quot;&gt;DelegatingPasswordEncoder&lt;/h4&gt;
&lt;p&gt;스프링 시큐리티 5.0 이전에는 기본 PasswordEncoder가 일반 텍스트 암호가 필요한 NoOpPasswordEncoder였다. 그러나 Password Storage History에 따라서 기본 PasswordEncoder는 BCryptPasswordEncoder를 사용할 수도 안할 수도 있다. 기본 PasswordEncoder가 변경됨에 따라서 3가지 큰 문제를 일으키는데 첫번째로 이전 암호 인코딩을 사용하는 많은 프로그램이 있어 쉽게 마이그레이션을 할 수 없다. 두번째, 암호 저장에 대한 모범 사례가 다시 변경 된다. 세번째 프레임 워크로서 자주 변경이 일어나면 안된다. 이 문제를 해결하기 위해 DelegatingPasswordEncoder를 도입하였고 DelegatingPasswordEncoder는 아래와 같은 기능으로 위의 문제들을 해결하였다. 첫번째로 현재 암호 저장소가 권장하는 방식을 사용하여 인코딩 되는지 확인한다. 두번째는 최신 및 레거시 형식의 암호 유효성 검사를 허용한다. 세번째는 향후 인코딩 업그레이드를 허용한다.&lt;/p&gt;

&lt;p&gt;DelegatingPasswordEncoder는 PasswordEncoderFactories를 이용하여 인스턴스를 생성할 수 있다.&lt;/p&gt;

&lt;h5 id=&quot;기본-delegatingpasswordencoder를-생성하는-방법이다&quot;&gt;기본 DelegatingPasswordEncoder를 생성하는 방법이다.&lt;/h5&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;PasswordEncoder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passwordEncoder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;PasswordEncoderFactories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createDelegatingPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;커스텀-delegatingpasswordencoder를-생성하는-방법이다&quot;&gt;커스텀 DelegatingPasswordEncoder를 생성하는 방법이다.&lt;/h5&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idForEncode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bcrypt&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idForEncode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BCryptPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;noop&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NoOpPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pbkdf2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pbkdf2PasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;scrypt&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SCryptPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sha256&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StandardPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;PasswordEncoder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;passwordEncoder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DelegatingPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idForEncode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;password-storage-format&quot;&gt;Password Storage Format&lt;/h5&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{id}encodePassword
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;id는 PasswordEncoder의 식별자이고 encodedPassword는 인코딩된 password를 뜻한다. id를 찾을 수 없으면 null로 반환된다.&lt;/p&gt;

&lt;h5 id=&quot;password-matching&quot;&gt;Password Matching&lt;/h5&gt;
&lt;p&gt;매칭은 {id} 나 생성자에서 제공된 PasswordEncoder의 ID 매핑을 기반으로 수행된다. 패스워드나 맵핑되지 않은 ID를 사용하여 match를 호출하면 IllegalArgumentException이 발생한다. 이러한 오류를 예방하기 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DelegatingPasswordEncoder.setDefaultPasswordEncoderForMatches (PasswordEncoder)&lt;/code&gt;
을 이용하여 기본값을 지정할 수 있다. 또한 암호가 저장되는 방식을 파악하여 아래처럼 명시적으로 제공을 해주면 된다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$2a$10$dXJ3SW6G7P50lGmMkkmwe. ...&lt;/code&gt; =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe. ...&lt;/code&gt;&lt;/p&gt;

&lt;h6 id=&quot;withdefaultpasswordencoder-example&quot;&gt;withDefaultPasswordEncoder Example&lt;/h6&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withDefaultPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;roles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getPassword&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;withdefaultpasswordencoder-reusing-the-builder&quot;&gt;withDefaultPasswordEncoder Reusing the Builder&lt;/h5&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;UserBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withDefaultPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;roles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USER&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;admin&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;roles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USER&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ADMIN&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 두 예제는 암호를 해시하지만 암호는 여전히 메모리와 컴파일된 소스에 노출되고 있다.
이러한 문제는 큰 보안 사고로 이어질 수 있으므로 실제 프로덕션일 경우는 암호를 외부에서 해시 하여야 한다. 외부에서 인코딩하는 방법 중 하나를 아래에 설명하겠다.&lt;/p&gt;

&lt;h5 id=&quot;encode-with-spring-boot-cli&quot;&gt;Encode with Spring Boot CLI&lt;/h5&gt;
&lt;p&gt;비밀번호를 외부에서 해시하는 방법 중 쉬운 방법으로는 Spring Boot CLI를 사용한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;아래처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DelegatingPasswordEncoder&lt;/code&gt;로 암호화할 암호를 Spring CLI에 아래와 같이 입력 후 인코딩된 암호를 생성한다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/2020-02-04-Spring-Security의-기능/1.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반환 되는 암호를 프로젝트의 application.properties에 user 비밀번호에 추가해 준다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/2020-02-04-Spring-Security의-기능/2.png&quot; alt=&quot;2.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이후 컨트롤러를 생성후 아무 API을 만들고 요청을 하면 아래와 같은 로그인 화면이 나타나고 user의 이름과 패스워드를(pas1234) 입력한다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/2020-02-04-Spring-Security의-기능/3.png&quot; alt=&quot;3.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정상적으로 로그인이 되며 인증이 진행된걸 확인할 수 있다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/2020-02-04-Spring-Security의-기능/4.png&quot; alt=&quot;4.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;아래에 소개하는 인코더들은 암호 크래킹의 내성을 위해 의도적으로 느리게 설계되어있으며 약 1초정도 걸리도록 조정하는것이 바람직하다. 자체 시스템에서 매개 변수를 조정하여 테스트하여 1초가 걸리도록 하면 된다. 알고리즘이 궁금하다면 알아서 찾아보도록…&lt;/p&gt;

&lt;h4 id=&quot;bcryptpasswordencoder&quot;&gt;BCryptPasswordEncoder&lt;/h4&gt;
&lt;p&gt;BCryptPasswordEncoder는 bdcrypt 알고리즘을 사용하여 암호를 해시한다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;BCryptPasswordEncoder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BCryptPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myPassword&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myPassword&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;argon2passwordencoder&quot;&gt;Argon2PasswordEncoder&lt;/h4&gt;
&lt;p&gt;Argon2PasswordEncoder는 Argon2 알고리즘을 사용하여 암호를 해시한다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Argon2PasswordEncoder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Argon2PasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myPassword&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myPassword&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;pbkdf2passwordencoder&quot;&gt;Pbkdf2PasswordEncoder&lt;/h4&gt;
&lt;p&gt;Pbkdf2PasswordEncoder는 PBKDF2 알고리즘을 사용하여 암호를 해시한다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Pbkdf2PasswordEncoder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pbkdf2PasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myPassword&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myPassword&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;scryptpasswordencoder&quot;&gt;SCryptPasswordEncoder&lt;/h4&gt;
&lt;p&gt;SCryptPasswordEncoder SCrypt 알고리즘을 사용하여 암호를 해시한다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;SCryptPasswordEncoder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SCryptPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myPassword&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;assertTrue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myPassword&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;other-passwordencoders&quot;&gt;Other PasswordEncoders&lt;/h4&gt;
&lt;p&gt;이전 버전과의 호환성을 위해 구현된 PasswordEncoder들이 있다. 더 이상 안전하지 않기 때문에 사용되지 않는다.&lt;/p&gt;

&lt;h4 id=&quot;password-storage-configuration&quot;&gt;Password Storage Configuration&lt;/h4&gt;
&lt;p&gt;NoOpPasswordEncoder를 사용하기 위해선 Spring bean으로 등록하여 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NoOpPasswordEncoder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;passwordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NoOpPasswordEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;12-protection-against-exploits-악용에-대한-보호&quot;&gt;1.2. Protection Against Exploits (악용에 대한 보호)&lt;/h2&gt;
&lt;p&gt;스프링 시큐리티는 일반적인 악용에 대한 방어를 제공한다. 가능하면 보호 기능은 기본적으로 활성화 되어 있다.&lt;/p&gt;

&lt;h3 id=&quot;121-cross-site-request-forgery-csrf&quot;&gt;1.2.1. Cross Site Request Forgery (CSRF)&lt;/h3&gt;
&lt;p&gt;스프링 시큐리티는 CSRF 공격을 보호하는 기능을 제공한다.&lt;/p&gt;

&lt;h4 id=&quot;what-is-a-csrf-attack&quot;&gt;What is a CSRF Attack?&lt;/h4&gt;
&lt;p&gt;은행 웹 사이트에서 현재 로그인 한 사용자의 금액을 다른 은행 계좌로 이체할 수 있는 양식을 제공한다고 가정하자.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/transfer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;amount&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;routingNumber&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;account&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Transfer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HTTP 요청은 아래와 같다&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&amp;amp;routingNumber=1234&amp;amp;account=9876
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다음은 은행 웹사이트에 인증한 것처럼 가장한다. 은행 사이트에서 로그아웃하지 않고 악의적인 웹사이트를 접속한다. 악의적인 웹 사이트는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://bank.example.com/transfer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;amount&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100.00&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;routingNumber&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;evilsRoutingNumber&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;account&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;evilsAccountNumber&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Win Money!&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;아마도 의심이 없는 사람이라면 돈을 벌기 위해 제출 버튼을 누를것이고 이 과정에서 의도하지 않은 evilsAccountNumber로 100달러를 보내게 될것이다. 이것은 악의적인 사이트가 사용자의 쿠키를 볼 수는 없지만 은행과 관련된 쿠키는 여전히 요청과 함께 전송되기 때문에 가능하게 된다.&lt;/p&gt;

&lt;p&gt;최악의 경우 이 프로세스가 javaScript를 이용하여 자동화 되었다면 접속과 동시에 송금이 될것이다. 또한 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85&quot;&gt;XSS&lt;/a&gt;공격으로 실제 정직한 은행 사이트를 방문 할 때도 악의적인 송금을 발생시킬 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;protecting-against-csrf-attacks&quot;&gt;Protecting Against CSRF Attacks&lt;/h4&gt;
&lt;p&gt;CSRF 공격이 가능한 이유는 피해자 웹 사이트의 HTTP 요청과 공격자 웹 사이트의 요청이 정확히 동일하기 때문이다. 즉, 악의적인 웹 사이트에서 오는 요청을 거부하고 은행 웹 사이트에서 오는 요청을 허용 할 방법이 없다. CSRF 공격으로부터 보호하려면 요청에 악의적인 사이트가 제공 할 수 없는 것이 있는지 확인하여 두 요청을 구분할 수 있어야 한다.
스프링은 CSRF 공격으로부터 보호하기 위해 아래 두가지 메커니즘을 제공한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Synchronizer Token Pattern&lt;/li&gt;
  &lt;li&gt;쿠키에 SameSite Attribute을 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;safe-methods-must-be-idempotent&quot;&gt;Safe Methods Must be Idempotent&lt;/h4&gt;
&lt;p&gt;CSRF에 대한 보호가 작동하려면 어플리케이션이 safe한 메소드가 멱등성을 보장해야한다. 
(멱등성이란 어떠한 연산을 여러번 하더라도 결과가 달라지지 않는 성질이다.)
HTTP 메서드 중 GET, HEAD, OPTIONS, TRACE를 사용하는 요청은 리소스의 상태를 변경해서는 안된다.&lt;/p&gt;

&lt;h4 id=&quot;synchronizer-token-pattern&quot;&gt;Synchronizer Token Pattern&lt;/h4&gt;
&lt;p&gt;CSRF 공격으로부터 보호하는 가장 잘알려진 방법은 Synchronizer Token을 사용하는 것이다. 이 방법은 각 HTTP 요청에 세션 쿠키 외 CSRF 토큰이라는 임의 생성 값을 넣어 보내는 것이다.
HTTP 요청이 제출되면 서버는 예상되는 CSRF 토큰을 찾아 HTTP 요청의 CSRF 토큰과 비교한다. 값이 일치하지 않으면 해당 요청을 거부한다.
Synchronizer Token 방법의 핵심은 CSRF 토큰이 브라우저에 의해 자동으로 포함되지 않는 HTTP 요청의 일부에 있어야한다는 것이다(쿠키에 CSRF 토큰이 있으면 안됨 이후 설명). 예를 들어 HTTP 매개변수 또는 HTTP 헤더에 실제 CSRF 토큰을 요구하면 CSRF 공격으로부터 보호된다. 쿠키는 브라우저의 HTTP 요청에 자동으로 포함되므로 쿠키에 CSRF 토큰을 요구하는 것은 동작하지 않는다.
리소스 상태를 업데이트하는 HTTP 요청에 대해 CSRF 토큰만 필요하도록 할 수 있다. 이것이 동작하려면 우리는 HTTP 메소드가 멱등성을 보장해야한다. 이는 외부 사이트의 링크를 사용하여 당사 웹사이트로의 링크를 허용하기 때문에 사용성을 향상 시킨다. 또한 토큰이 유출 될 수 있으므로 HTTP GET에 토큰을 포함하지 않아야 한다.&lt;/p&gt;

&lt;p&gt;Synchronizer Token Pattern을 사용하는 예제를 확인해보자&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/transfer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;_csrf&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;4bfd1575-3ad1-4d21-96c7-4ef2d9f86721&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;amount&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;routingNumber&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;account&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Transfer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;양식에 CSRF 토큰값이 숨겨져 있다. Same Origin Policy이 악의적 사이트가 응답을 읽을 수 없도록 보장하기 떄문에 외부 사이트는 CSRF 토큰을 읽을 수 없다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&amp;amp;routingNumber=1234&amp;amp;account=9876&amp;amp;_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HTTP 요청서에 _csrf 매개 변수가 포함되어 있는것을 확인할 수 있다. 악의적인 웹사이트는 _csrf 매개변수에 대한 올바른 값을 제공 할 수 없으며 서버가 CSRF 토큰을 예상 된 CSRF 토큰과 비교할 때 전송이 실패한다.&lt;/p&gt;

&lt;h4 id=&quot;samesite-attribute&quot;&gt;SameSite Attribute&lt;/h4&gt;
&lt;p&gt;CSRF 공격으로 부터 보호하는 새로운 방법은 쿠키에 SameSite 속성을 지정하는 것이다. 서버는 쿠키를 설정할 때 SameSite 속성을 지정하여 외부 사이트에서 올 때 쿠키를 보내지 않아야 함을 나타낼 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;스프링 시큐리티는 세션 쿠키 생성을 직접 제어하지 않으므로 SameSite 속성에 대한 지원을 제공하지 않는다. 스프링 세션은 서블릿 기반 어플리케이션에서 SameSite 속성에 대한 지원을 제공한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SameSite 속성이 있는 HTTP 응답 헤더를 보자&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;SameSite 속성의 값은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Strict - 지정된 경우 동일한 사이트에서 들어오는 모든 요청에 쿠키가 포함된다. 동일한 사이트가 아니라면 쿠키가 HTTP 요청에 포함되지 않는다&lt;/li&gt;
  &lt;li&gt;Lax - 동일한 사이트거나 요청이 최상위 수준 탐색에서 오고 메서드가 멱등성인 경우 지정된 쿠키가 전송된다. 그렇지 않으면 쿠키가 HTTP 요청에 포함되지 않는다.
&lt;a href=&quot;&quot;&gt;, &lt;link href=&quot;&quot; /&gt;, &amp;lt;form method=get&amp;gt;은 예외 나머지는 Strict와 동일.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SameSite 속성을 사용하여 은행 송금 예제를 보호하는 방법을 알아보자. 은행 어플리케이션은 세션 쿠키에 SameSite 속성을 지정하여 CSRF로 부터 보호 할 수 있다.
세션 쿠키에 SameSite 속성이 설정되어 있으면 브라우저는 은행 웹 사이트에서 오는 요청과 함께 JSESSIONID 쿠키를 계속 보낸다. 그러나 악의적인 웹 사이트에서 들어오는 전송 요청은 JSESSIONID 쿠키를 보내지 않는다. 세션이 더 이상 악의적인 웹사이트에서 오는 전송 요청에 존재하지 않으므로 애플리케이션은 CSRF 공격으로부터 보호된다.&lt;/p&gt;

&lt;p&gt;SameSite 속성을 Strict로 설정하면 더 강력한 방어가 제공되지만 사용자에게 혼란을 줄 수 있다. https://social.example.com에서 호스팅 되는 소셜 미디어 사이트에 로그인 되어 있는 사용자를 생각해보자. 사용자는 https://email.example.org에서 소셜 미디어 사이트에 대한 링크가 포함된 이메일을 받는다. 사용자가 링크를 클릭하면 소셜 미디어 사이트에 대한 인증을 받을 것으로 기대한다. 하지만 SameSite 속성이 Strict이면 쿠키가 전송되지 않으므로 사용자가 인증되지 않는다.&lt;/p&gt;

&lt;p&gt;또 다른 고려 사항은 SameSite 속성이 사용자를 보호하려면 브라우저가 SameSite 속성을 지원해야한다. 이러한 이유로 CSRF 공격에 대한 보호로 유일한 방법을 사용하는것보다 여러 방법을 사용하는것이 권장된다.&lt;/p&gt;

&lt;h4 id=&quot;when-to-use-csrf-protection&quot;&gt;When to use CSRF protection&lt;/h4&gt;
&lt;p&gt;일반 사용자가 브라우저에서 처리할 수 있는 모든 요청에 대해 CSRF 보호가 되야 한다. 브라우저가 아닌 클라이언트에서 사용하는 서비스만 만드는 경우 CSRF 보호를 비활성화 할 수 있다. (세션을 사용하지 않거나 브라우저를 사용하지 않으면 쿠키를 사용할 일이 없기 때문.)&lt;/p&gt;

&lt;h4 id=&quot;csrf-protection-and-json&quot;&gt;CSRF protection and JSON&lt;/h4&gt;
&lt;p&gt;JSON 요청에 영향을 줄 수 있는 CSRF 위협이 있으므로 주의해야한다. 예를 들어 악의적인 사용자는 아래와 같이 CSRF를 만들 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://bank.example.com/transfer&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;enctype=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/plain&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'{&quot;amount&quot;:100,&quot;routingNumber&quot;:&quot;evilsRoutingNumber&quot;,&quot;account&quot;:&quot;evilsAccountNumber&quot;, &quot;ignore_me&quot;:&quot;'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'test&quot;}'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'hidden'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Win Money!&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위처럼 name에 json을 양식을 작성하고 value값과 연결되는 =을 없애기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;ignore_me&quot;:&quot;' value='test&quot;}'&lt;/code&gt;이런식으로 끝나도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;input &amp;gt;&lt;/code&gt;을 작성한다.
결과 값은 아래와 같은 JSON 구조가 된다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;amount&quot;: 100,
&quot;routingNumber&quot;: &quot;evilsRoutingNumber&quot;,
&quot;account&quot;: &quot;evilsAccountNumber&quot;,
&quot;ignore_me&quot;: &quot;=test&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;어플리케이션이 Content-Type의 유효성을 검사하지 않으면 이 악용에 노출된다. 설정에 따라 Content-Type을 검증하는 Spring MVC 프로그램은 아래와 같이 .json으로 끝나도록 URL 접미사를 업데이트하여 악용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://bank.example.com/transfer.json&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;enctype=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/plain&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'{&quot;amount&quot;:100,&quot;routingNumber&quot;:&quot;evilsRoutingNumber&quot;,&quot;account&quot;:&quot;evilsAccountNumber&quot;, &quot;ignore_me&quot;:&quot;'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'test&quot;}'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'hidden'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Win Money!&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;csrf-and-stateless-browser-applications&quot;&gt;CSRF and Stateless Browser Applications&lt;/h4&gt;
&lt;p&gt;어플리케이션이 stateless 하더라도 CSRF의 공격에 대해 안전한것은 아니다. 실제로 사용자가 특정 요청에 대해 웹브라우저에서 어떠한 작업도(SameSite 쿠키를 이용한다거나 Synchronizer Token과 같은 작업) 수행할 필요가 없다면 CSRF 공격에 여전히 취약 할 수 있다.
예를 들어 JSESSIONID 대신 인증을 위해 모든 상태를 포함하는 사용자 지정 쿠키를 사용하는 어플리케이션이 있다. CSRF 공격이 발생하면 이전 예제에서 JSESSIONID 쿠키가 전송 된 것과 동일한 방식으로 사용자 지정 쿠키가 요청과 함께 전송된다. 이런 어플리케이션은 CSRF 공격에 취약하다.&lt;/p&gt;

&lt;h4 id=&quot;csrf-considerations&quot;&gt;CSRF Considerations&lt;/h4&gt;
&lt;p&gt;CSRF 공격에 대한 보호를 구현할 때 고려해야 할 몇 가지 특별한 고려사항이 있다.&lt;/p&gt;

&lt;h4 id=&quot;logging-in&quot;&gt;Logging In&lt;/h4&gt;
&lt;p&gt;위조 된 로그인 요청으로부터 보호하려면 로그인 HTTP 요청을 CSRF 공격으로부터 보호해야한다. 위조 로그인 요청으로부터 보호하여 악의적 인 사용자가 피해자의 민감한 정보를 읽을 수 없도록 해야한다. 로그인시 공격은 아래와 같은 방식으로 이루어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;악의적인 사용자는 악의적인 사용자의 자격 증명을 사용하여 CSRF 로그인을 수행한다. 피해자는 이제 악의적인 사용자로 인증된다.(로그인을 위해 필요한 자격 증명을 악의적인 사용자의 것을 이용한다는 것이다. 여기서 설명하는 자격 증명은 csrf토큰이나 쿠키의 samesite 속성과 같이 HTTP 요청이 올바른 곳에서 요청 됐다는것을 나타낼수 있는 정보를 나타내는것 같다.)&lt;/li&gt;
  &lt;li&gt;이후 악의적인 사용자가 피해자를 속여 악의적인 웹 사이트를 방문하도록 하고 민감한 정보를 입력하도록 한다.&lt;/li&gt;
  &lt;li&gt;정보는 악의적인 사용자의 계정과 연결되어 있으므로 악의적인 사용자는 자신의 자격 증명으로 로그인하여 피해자의 민감한 정보를 볼 수 있다. (악의적인 사용자의 자격 증명으로 인해 악의적인 사이트에서도 로그인 요청이 가능하게 됨.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로그인 HTTP 요청이 CSRF 공격으로부터 보호되도록 하는데 발생할 수 있는 문제는 세션 타임 아웃 때문에 사용자가 요청이 거부되는 경험을 할 수 있다. 세션 타임아웃은 로그인하기 위해 세션이 필요하지 않을것으로 예상하는 사용자들을 놀랍게 한다.&lt;/p&gt;

&lt;h4 id=&quot;logging-out&quot;&gt;Logging Out&lt;/h4&gt;
&lt;p&gt;위조된 로그아웃 요청으로부터 보호하려면 로그아웃 HTTP 요청을 CSRF 공격으로부터 보호해야한다. 악의적인 사용자가 피해자의 민감한 정보를 읽을 수 없도록 위조 로그아웃 요청으로부터 보호해야한다. 공격에 대한 내용은 아래와 같은 방식으로 이루어진다.&lt;/p&gt;

&lt;p&gt;ApplicationX는 login/logout CSRF를 가진 OAUTH 제공자라고 가정한다. ApplicationY는 ApplicationX와의 연결을 구현했다. 연결되어있는 ApplicationX의 계정을 ApplicationY의 권한 인증하는데 사용할 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;공격자 CSRF가 ApplicationX로 부터 피해자를 로그아웃한다.&lt;/li&gt;
  &lt;li&gt;공격자 CSRF가 ApplicationX에 피해자를 로그인한다. (피해자는 이제 ApplicationX에서 공격자로 로그인 되었다)&lt;/li&gt;
  &lt;li&gt;공격자는 피해자에게 ApplicationX 연결 기능을 보낸다&lt;/li&gt;
  &lt;li&gt;공격자의 ApplicationX 계정을 피해자의 ApplicationY 계정으로 연결한다.&lt;/li&gt;
  &lt;li&gt;공격자는 ApplicationX 로그인을 사용하여 ApplicationY에서 피해자로 인증을 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이외 추가적인 내용은 &lt;a href=&quot;https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/&quot;&gt;여기를 참고&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;로그아웃 HTTP 요청이 CSRF 공격으로부터 보호되도록 하기 위해 발생할 수 있는 문제는 세션 타임 아웃 때문에 사용자가 요청이 거부되는 경험을 할 수 있다. 세션 타임아웃은 로그아웃하기 위해 세션이 필요하지 않을 것으로 예상하는 사용자들을 놀랍게 한다.&lt;/p&gt;

&lt;h4 id=&quot;csrf-and-session-timeouts&quot;&gt;CSRF and Session Timeouts&lt;/h4&gt;
&lt;p&gt;서버에서는 CSRF 토큰이 세션에 저장 된다. 이는 세션이 만료되면 서버가 해당하는 CSRF 토큰을 찾지 못하고 HTTP 요청을 거부 한다. 타임 아웃을 해결하는 데는 여러가지 옵션이 있으며 각 옵션 마다 장단점이 존재한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;타임 아웃을 완화하는 가장 좋은 방법은 JavaScript를 사용하여 양식 제출시 CSRF 토큰을 요청하는것이다. 그런다음 양식이 CSRF 토큰으로 업데이트 되고 제출 된다.&lt;/li&gt;
  &lt;li&gt;다른 옵션은 사용자에게 세션이 만료 될 예정임을 알리는 JavaScript를 사용하는 것이다. 사용자는 버튼을 클릭하여 세션을 지속하거나 재부여할 수 있다.&lt;/li&gt;
  &lt;li&gt;마지막으로 CSRF 토큰을 쿠키에 저장할 수 있다. 이를 통해 CSRF 토큰이 세션보다 오래 지속될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CSRF 토큰이 기본적으로 쿠키에 저장되지 않는 이유를 물을 수 있다. 다른 도메인에서 헤더(쿠키 지정)를 설정할 수 있는 알려진 공격이 있다. 이는 Ruby on Rails가 헤더 X-Requested-With가있을 때 더 이상 CSRF 검사를 건너 뛰지 않는 이유와 같다. 또 다른 단점은 상태 (즉, 시간 제한)를 제거하면 토큰이 손상된 경우 강제로 무효화 할 수있는 기능이 없다.&lt;/p&gt;

&lt;h4 id=&quot;multipart-file-upload&quot;&gt;Multipart (file upload)&lt;/h4&gt;
&lt;p&gt;CSRF 공격이 발생하지 않도록 하려면 CSRF 토큰을 얻기 위해 HTTP 요청 본문을 읽어야한다. 그러나 본문을 읽는다는 것은 파일이 업로드 된다는 것을 의미하므로 외부 사이트에서 파일을 업로드 할 수 있다.
이렇기 때문에 MUltipart/form-data에서 CSRF 보호를 사용하는 두가지 옵션이 존재한다.&lt;/p&gt;

&lt;h5 id=&quot;place-csrf-token-in-the-body&quot;&gt;Place CSRF Token in the Body&lt;/h5&gt;
&lt;p&gt;첫번째 옵션은 요청 본문에서 실제 CSRF 토큰을 포함하는 것이다. CSRF 토큰을 본문에 배치하면 권한이 수행되기 전에 본문을 읽게 된다. 즉, 누구나 서버에 임시 파일을 저장할 수 있다. 그러나 승인 된 사용자의 요청만 파일을 제출할 수 있다. 일반적으로 임시 파일 업로드는 대부분의 서버에 거의 영향을 미치지 않기 때문에 권장되는 접근 방식이다.&lt;/p&gt;

&lt;h5 id=&quot;include-csrf-token-in-url&quot;&gt;Include CSRF Token in URL&lt;/h5&gt;
&lt;p&gt;권한이 없는 사용자가 임시 파일을 업로드 하도록 허용하는 것이 허용되지 않는 경우, 대안은 서버의 CSRF 토큰을 form 속성에 쿼리 매개변수로 포함하는 것이다. 이 방식의 단점은 쿼리 매개 변수가 유출 될 수 있다는 것이다. 일반적으로 중요한 데이터는 유출되지 않도록 본문 또는 헤더 내에 배치하는 것이 모범 사례이다.&lt;/p&gt;

&lt;h5 id=&quot;hiddenhttpmethodfilter&quot;&gt;HiddenHttpMethodFilter&lt;/h5&gt;
&lt;p&gt;일부 어플리케이션에서는 form 매개 변수를 사용하여 HTTP 메서드를 재정의 할 수 있다. 예를 들어 아래처럼 HTTP 메서드를 POST가 아닌 DELETE로 처리할 수 있다&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/process&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- ... --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;_method&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;delete&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HTTP 메서드 오버라이딩은 필터에서 발생한다. 해당 필터는 Spring Security 이전에 배치 되어야 한다. 오버라이딩은 POST에서만 발생하므로 실제로 문제가 발생하지 않을 가능성이 있다. 그러나 Spring Security의 필터 앞에 배치 되도록 하는것이 모범 사례이다.&lt;/p&gt;

&lt;h3 id=&quot;122-security-http-response-headers&quot;&gt;1.2.2. Security HTTP Response Headers&lt;/h3&gt;
&lt;p&gt;웹 어플리케이션의 보안을 강화하는데 사용할 수 있는 많은 HTTP 응답 헤더가 있다. Spring Security가 명시적으로 지원하는 다양한 HTTP 응답 헤더를 설명한다. 필요한 경우 사용자 지정 헤더를 제공하도록 Spring Security를 구성할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;default-security-headers&quot;&gt;Default Security Headers&lt;/h4&gt;
&lt;p&gt;스프링 시큐리티는 기본적인 보안 값을 제공하기 위해 보안 관련 HTTP 응답 헤더의 기본 집합을 제공한다.
스프링 시큐리티의 기본값은 다음 헤더를 포한한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
// Strict-Transport-Security는 HTTPS 요청에만 추가됩니다.
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;기본값이 요구 사항을 충족하지 않는 경우 이러한 기본값에서 헤더를 쉽게 제거, 수정 또는 추가 할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;cache-control&quot;&gt;Cache Control&lt;/h4&gt;
&lt;p&gt;스프링 시큐리티의 기본값은 사용자 컨텐츠를 보호하기 위해 캐싱을 비활성화 하는 것이다.
사용자가 민감한 정보를 보기 위해 인증한 다음 로그아웃하는 경우 악의적인 사용자가 뒤로 버튼을 클릭하여 민감한 정보를 볼 수 없도록 한다.
기본적으로 전송되는 캐시 제어 헤더는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;기본적인 보안을 유지하기 위해 스프링 시큐리티는 기본적으로 헤더를 추가한다. 그러나 응용 프로그램이 자체 캐시 제어 헤더를 제공하는 경우
스프링 시큐리티는 중단된다. 이를 통해 어플리케이션은 CSS 및 JavaScript와 같은 정적 리소스를 캐시 할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;content-type-options&quot;&gt;Content Type Options&lt;/h4&gt;
&lt;p&gt;지금까지 Internet Explorer를 포함한 브라우저는 컨텐츠 스니핑(데이터의 파일 형식을 추론하는 방법)을 사용하여 요청의 content-type을 추측하려 했다. 
이를 통해 브라우저는 content-type을 지정하지 않은 리소스의 content-type을 추측하여 사용자 경험을 개선 할 수 있었다. 
예를 들어, 브라우저가 content-type이 지정되지 않은 JavaScript파일을 발견한 경우 content-type을 추측한 다음 실행할 수 있다.&lt;/p&gt;

&lt;p&gt;컨텐츠 업로드를 허용 할 때해야 할 많은 추가 작업이 있따.(예를 들어 고유한 도메인에 문서만 표시, content-type 헤더 설정 확인, 문서 삭제 등). 
그러나 이러한 조치는 스프링 시큐리티가 제공하는 범위를 벗어난다. 컨텐츠 스니핑을 비활성화 할 때 제대로 작동하려면 content-type을 지정해야한다는 점을 지적하는것도 중요하다.&lt;/p&gt;

&lt;p&gt;컨텐츠 스니핑의 문제점은 악의적인 사용자가 다중 컨텐츠(즉, 여러 컨텐츠 유형으로 유효한 파일)를 사용하여 XSS 공격을 수행 할 수 있다는 것입니다. 
예를 들어, 일부 사이트에서는 사용자가 유효한 postscript document를 웹 사이트에 제출하고 볼 수 있도록 허용 할 수 있다. 
악의적인 사용자가 유효한 JavaScript 파일 인 postscript document를 만들어 XSS 공격을 수행 할 수 있다.
&lt;a href=&quot;https://asec.ahnlab.com/ko/1047/https://asec.ahnlab.com/ko/1047/&quot;&gt;postscript document 취약점&lt;/a&gt;을 참고.&lt;/p&gt;

&lt;p&gt;스프링 시큐리티는 HTTP 응답에 다음 헤더를 추가하여 기본적으로 컨텐츠 스니핑을 비활성화 한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;X-Content-Type-Options: nosniff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;http-strict-transport-security-hsts&quot;&gt;HTTP Strict Transport Security (HSTS)&lt;/h4&gt;
&lt;p&gt;https 프로토콜을 생략하면 중간자 공격에 잠재적으로 취약하다. 웹 사이트가 https로 리디렉션을 수행하더라도 악의적 인 사용자가 
초기 HTTP 요청을 가로 채서 응답을 조작 할 수 있다. (예 : https://악의적인 사이트.com으로 리디렉션하게 하고 자격 증명을 훔칠 수 있음)&lt;/p&gt;

&lt;p&gt;많은 사용자가 https 프로토콜을 생략하기 때문에 HTTP Strict Transport Security (HSTS)가 만들어졌다.
예를 들어 mybank.example.com이 HSTS 호스트로 추가 되면 브라우저는 mybank.example.com에 대한 모든 요청이 
https://mybank.example.com으로 해석되어야 함을 미리 알 수 있다. 이렇게 하면 중간자 공격이 발생할 가능성이 크게 줄어 든다.&lt;/p&gt;

&lt;p&gt;RFC 6797에 따라 HSTS 헤더는 HTTPS 응답에만 삽입된다. 브라우저가 헤더를 확인하려면 먼저 연결에 사용 된 SSL 인증서에 서명한 CA
(SSL 인증서 뿐만 아니라)를 신뢰해야한다.&lt;/p&gt;

&lt;p&gt;사이트를 HSTS 호스트로 표시하는 한 가지 방법은 호스트를 브라우저에 미리 로드하는 것이다. 또 다른 방법은 Strict-Transport-Security 헤더를 
응답에 추가하는 것이다. 예를 들어, Spring Security의 기본 동작은 브라우저가 도메인을 1년 동안 HSTS 호스트로 처리하도록 지시하는 다음 헤더를 추가하는 것이다.
(1 년에 약 31536000초).&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;선택 사항 인 IncludeSubDomains 지시문은 하위 도메인 (예 : secure.mybank.example.com)도 HSTS 도메인으로 처리되어야 함을 브라우저에 지시합니다.
선택적 preload 지시문은 도메인이 HSTS 도메인으로 브라우저에 사전로드 되어야 함을 브라우저에 지시합니다. 사용자가 HSTS Lists를 가지고 있지 않다면 
Web Browser는 HTTP Protocol을 사용하여 접속을 하게 되는데 이때 SSL Stripping 공격을 받을 가능성이 있기 때문에 이것을 방지하기 위해 preload를 한다.
Preloaded HSTS Lists에 포함되도록 하려면, “hstpreload.org” Site에 신청을 해야 한다. 또한 Web Browser 사용자가 직접 자신의 Web Browser에
특정 Web Site를 HSTS List에 추가할 수 있도록 기능을 제공하기도 한다(예를 들어 크롬).&lt;/p&gt;

&lt;h4 id=&quot;http-public-key-pinning-hpkp&quot;&gt;HTTP Public Key Pinning (HPKP)&lt;/h4&gt;
&lt;p&gt;패시브 상태를 유지하기 위해 스프링 시큐리티는 여전히 서블릿 환경에서 HPKP에 대한 지원을 제공하지만 위에 나열된 이유로 인해 보안팀에서 더이상 HPKP를 권장하지 않는다.
HPKP는 위조 된 인증서로 MTM(Man in the Middle) 공격을 방지하기 위해 특정 웹서버에서 사용할 공개 키를 웹 클라이언트에 지정한다.
HPKP가 올바르게 사용되면 손상된 인증서에 대한 보호를 할 수 있다. 그러나 HPKP의 복잡성으로 인해 많은 전문가들은 더 이상 사용을 권장하지 않으며 Chrome은 더 이상 지원하지 않는다.&lt;/p&gt;

&lt;h4 id=&quot;x-frame-options&quot;&gt;X-Frame-Options&lt;/h4&gt;
&lt;p&gt;웹 사이트를 프레임에 추가하는 것은 보안 문제가 될 수 있다. 예를 들어, 영리한 CSS 스타일을 사용하는 사용자는 의도하지 않은 것을 클릭하도록 속일 수 있다.
예를 들어 은행에 로그인 한 사용자가 다른 사용자에게 엑세스 권한을 부여하는 버튼을 클릭 할 수 있다. 이러한 종류의 공격을 클릭 재킹이라고 한다.
(클릭 재킹 ClickJacking이란 사용자가 인식하는것과 다른것을 클릭 하도록 사용자를 속여 잠재적으로 
기밀 정보를 노출하거나 다른 사람이 컴퓨터를 제어하도록 허용 하는 악의 적인 기술)&lt;/p&gt;

&lt;p&gt;클릭 재킹을 처리하는 또 다른 현대적인 접근 방식은 컨텐츠 보안 정책(CSP)을 사용하는 것이다.&lt;/p&gt;

&lt;p&gt;클릭 재킹 공격을 완화하는 방법에는 여러가지가 있다. 예를 들어, 기존 브라우저를 클릭 재킹 공격으로부터 보호하기 위해 프레임 브레이킹 코드를 사용할 수 있다.
완벽하지는 않지만 프레임 분리 코드는 레거시 브라우저에서 할 수 있는 최선의 방법이다.&lt;/p&gt;

&lt;p&gt;클릭 재킹을 해결하기 위한 현대적인 방법은 X-Frame-Options 헤더를 사용하는것이다. 기본적으로 Spring Security는 다음 헤더를 사용하여
iframe 내에서 페이지 렌더링을 비활성화 한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;X-Frame-Options: DENY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;x-xss-protection&quot;&gt;X-XSS-Protection&lt;/h4&gt;
&lt;p&gt;일반 브라우저는 XSS 공격을 필터링하는 기능을 내장하고 있다. 이것은 절대적으로 안전하지는 않지만 XSS 보호에 도움이 된다.
필터링은 기본적으로 활성화 되어 있으므로 헤더를 추가하면 일반적으로 활성화되도록 보장하고 XSS 공격이 탐지 될 때 브라우저에 수행할 작업을 지시한다.
예를 들어 필터는 모든 것을 렌더링하기 위해 가장 덜 침습적인 방식으로 컨텐츠를 변경하려 할 수 있다. 때떄로 이러한 유형의 교체는 그 자체로 XSS 취약점이 될 수 있다.
대신 컨텐츠를 수정하는 것보다 차단하는것이 가장 좋다. 기본적으로 Spring Security는 다음 헤더를 사용하여 컨텐츠를 차단한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;X-XSS-Protection: 1; mode=block
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;content-security-policy-csp&quot;&gt;Content Security Policy (CSP)&lt;/h4&gt;
&lt;p&gt;CSP(컨텐츠 보안 정책)은 웹 애플리케이션이 XSS와 같은 컨텐츠 주입 취약성을 완화하기 위해 활용할 수 있는 메커니즘이다. 
CSP는 웹 응용 프로그램 작성자가 웹 응용 프로그램이 리소스를 로드 할 것으로 예상하는 소스에 대해 선언하고 궁극적으로 클라이언트에게 
알리는 기능을 제공하는 선언적 정책이다.&lt;/p&gt;

&lt;p&gt;CSP는 모든 컨텐츠 삽입 취약점을 해결하기 위한 것이 아니다. 대신 CSP를 활용하여 컨텐츠 삽입 공격으로 인한 피해를 줄일 수 있다.
첫번째 방어선으로 웹 애플리케이션 작성자는 입력의 유효성을 검사하고 출력을 인코딩해야한다.&lt;/p&gt;

&lt;p&gt;웹 애플리케이션은 응답에 다음 HTTP 헤더 중 하나를 포함하여 CSP를 사용 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Security-Policy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Security-Policy-Report-Only&lt;/code&gt;
이러한 각 헤더는 클라이언트에 보안 정책을 전달하는 메커니즘으로 사용 된다. 보안 정책에는 특정 리소스 representation에 대한 제한을 
선언하는 보안 정책 지시문 집합이 포함된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 웹 애플리케이션은 응답에 다음 헤더를 포함하여 신뢰할 수 있는 특정 소스에서 스크립트를 로드 할 것으로 예상한다고 선언 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Security-Policy: script-src https://trustedscripts.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;script-src&lt;/code&gt;지시문에 선언된 것 이외의 다른 소스에서 스크립트를 로드하려는 시도는 user-agent에 의해 차단된다. 
또한 report-url 지시문이 보안 정책에 선언 된 경우 사용자 에이전트는 선언 된 URL에 위반 사항을 보고한다.&lt;/p&gt;

&lt;p&gt;예를 들어 웹 애플리케이션이 선언 된 보안 정책을 위반하는 경우 다음 응답 헤더는 정책의 report-uri 지시문에 지정된 URL로 위반 보고서를 보내도록 
user-agent에 지시한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위반 보고서는 웹 애플리케이션 자체 API 또는 https://report-uri.io/와 같이 공개적으로 호스팅 되는 CSP 위반 보고 서비스에서 캡처 할 수 있는 표준 JSON 구조이다.&lt;/p&gt;

&lt;p&gt;Content-Security-Policy-Report-Only 헤더는 웹 어플리케이션 작성자 및 관리자가 보안 정책을 시행하는 대신 모니터링 할 수 있는 기능을 제공한다. 
이 헤더는 일반적으로 사이트에 대한 보안 정책을 실험 및 개발 할 때 사용된다. 정책이 유효한 것으로 간주되면 대신 Content-Security-Policy 헤더 필드를 사용하여 적용 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사이트가 이 정책을 위반하는 경우 evil.com에서 스크립트를 로그하려고 시도하면 user-agent는 report-uri 지시문에 선언 된 URL로 위반 보고서를 보내지만
그래도 위반 리소스가 로드되도록 허용한다.&lt;/p&gt;

&lt;h4 id=&quot;referrer-policy&quot;&gt;Referrer Policy&lt;/h4&gt;
&lt;p&gt;Referrer Policy은 웹 어플리케이션이 사용자가 마지막을 방문한 페이지를 포함하는 referrer 필드를 관리하는데 활용할 수 있는 메커니즘이다.
Spring Security의 접근 방식은 다른 정책을 제공하는 Referrer-Policy 헤더를 사용하는 것이다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Referrer-Policy: same-origin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Referrer-Policy 응답 헤더는 대상이 사용자가 이전에 있었던 소스를 알도록 브라우저에 지시한다.&lt;/p&gt;

&lt;h4 id=&quot;feature-policy&quot;&gt;Feature Policy&lt;/h4&gt;
&lt;p&gt;Feature Policy은 웹 개발자가 브라우저에 특정 API 및 웹 기능의 동작을 선택적으로 활성화, 비활성화 및 수정할 수 있도록하는 메커니즘이다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Feature-Policy: geolocation 'self'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Feature Policy을 통해 개발자는 브라우저가 사이트 전체에서 사용되는 특정 기능에 적용할 ‘policies’집합을 선택할 수 있다. 
이러한 정책은 사이트가 특정 기능에 대한 브라우저의 기본 동작에 엑세스 하거나 수정할 수 있는 API를 제한한다.&lt;/p&gt;

&lt;h4 id=&quot;clear-site-data&quot;&gt;Clear Site Data&lt;/h4&gt;
&lt;p&gt;Clear Site Data는 HTTP 응답에 다음 헤더가 포함 된 경우 브라우저 측 데이터(쿠키, 로컬 저장소 등)를 제거 할 수 있는 메커니즘이다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Clear-Site-Data: &quot;cache&quot;, &quot;cookies&quot;, &quot;storage&quot;, &quot;executionContexts&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이것은 로그아웃시 수행 할 수 있는 좋은 정리 작업이다.&lt;/p&gt;

&lt;h4 id=&quot;custom-headers&quot;&gt;Custom Headers&lt;/h4&gt;
&lt;p&gt;Spring Security는 어플리케이션에 보안 헤더를 편리하게 추가 할 수 있는 메커니즘이 있다. 
그러나 사용자 지정 헤더를 추가할 수 있는 후크도 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;123-http&quot;&gt;1.2.3. HTTP&lt;/h3&gt;
&lt;p&gt;정적 리소스를 포함한 HTTP 기반 통신은 TLS를 사용하여 보호해야 한다.&lt;/p&gt;

&lt;p&gt;프레임 워크로서 Spring Security는 HTTP 연결을 처리하지 않으므로 HTTPS를 직접 지원하지 않는다. 
그러나 HTTPS 사용에 도움이 되는 여러 기능을 제공한다.&lt;/p&gt;

&lt;h4 id=&quot;redirect-to-https&quot;&gt;Redirect to HTTPS&lt;/h4&gt;
&lt;p&gt;클라이언트가 HTTP를 사용할 때 HTTPS로 리디렉션하도록 구성할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;strict-transport-security&quot;&gt;Strict Transport Security&lt;/h4&gt;
&lt;p&gt;Spring security는 Strict Transport Security에 대한 지원을 제공하며 기본적으로 활성화 한다.&lt;/p&gt;

&lt;h4 id=&quot;proxy-server-configuration&quot;&gt;Proxy Server Configuration&lt;/h4&gt;
&lt;p&gt;프록시 서버를 사용하는 경우 어플리케이션을 올바르게 구성했는지 확인 하는 것이 중요하다. 
예를 들어 많은 어플리케이션에는 적절한 구성 없이 http://192.168.1:8080에 어플리케이션 서버로 요청을 전달하여 https://example.com/ 요청에 응답하는 로드 밸런서가 있다.
어플리케이션 서버는 로드 밸런서가 존재하는지 모르고 요청을 https://192.168.1:8080이 클라이언트에서 요청한 것처럼 처리한다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하려면 RFC7239를 사용하여 로드 밸런서를 사용하도록 지정할 수 있다. 어플리케이션이 이를 인식하도록 하려면 X-Forwarded 헤더를 인식하는 어플리케이션 서버를 구성해야 한다.
예를 들어 Tomcat은 RemoteValve를 사용하고 Jetty는 FowardedRequestCustomizer를 사용한다. Spring 사용자는 ForwardedHeaderFilter를 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;Spring Boot 사용자는 server.user-forward-headers 속성을 사용하여 어플리케이션을 구성할 수 있다.&lt;/p&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="spring-security" /><category term="Web" /><category term="SpringSecurity" /><category term="Spring" /><summary type="html">참고 자료 스프링 시큐리티 레퍼런스 https://docs.spring.io/spring-security/site/docs/5.4.2/reference/html5/ 이외 자료는 내용 중 링크 추가 틀린 내용, 부족한 내용 꼭 지적 부탁드립니다! 1. 스프링 시큐리티의 기능 스프링 시큐리티는 인증, 권한 부여, 및 보호에 대한 종합적인 지원을 하며 단순하게 사용하기 위해 다른 라이브러리와의 통합을 제공한다. 1.1. 인증 (Authentication) 인증은 특정 리소스에 접근하려는 주체의 신원을 확인하는 것이다. 사용자를 인증하는 일반적인 방법은 사용자에게 이름과 비밀번호를 입력하도록 요구하는것이다. 인증이 수행되면 사용자의 신원(아이디와 비밀번호)을 알게 되며 신원을 인증 할 수 있게 된다. 스프링 시큐리티는 사용자 인증을 위한 기능을 내장하여 제공한다. 1.1.1. Authentication Support Spring Security는 사용자 인증을위한 내장 지원을 제공합니다. 1.1.2. Password Storage 스프링 시큐리티의 PasswordEncoder 인터페이스는 비밀번호를 안전하게 저장할 수 있도록 비밀번호의 단방향 변환을 수행하는데 사용된다. PasswordEncoder는 단방향 변환이므로 양방향이 필요한 경우(데이터 베이스 인증에 사용되는 자격 증명 저장)에는 사용할 수 없다. 일반적으로 PasswordEncoder는 인증시 사용자가 제공한 암호와 비교해야하는 암호를 저장하는데 사용 된다. Password Storage History 처음의 암호는 일반 텍스트로 저장되었다. 텍스트로 저장하던 때의 암호는 데이터 저장소에 저장 되었으며 이 저장소에 접근 하기위해선 자격 증명이 필요했기 때문에 개발자들은 충분히 안전하다고 생각했다. 그러나 악의적인 사용자가 SQL Injection과 같은 공격을 사용하여 대규모의 사용자 정보를 얻는 방법이 나타났고 이후부터 암호를 더 강력히 보호 해야함을 깨달았다. 이후 SHA-256과 같은 단방향 해시를 통해 암호를 저장하도록 권장되었다. 해시로 주어진 암호는 전수공격하여 계산하기에 큰 어려움이 있었기 때문에 안전하다 생각하였다(현재 하드웨어 기준으론 아님). 하지만 해시를 이용한 방법도 Rainbow Tables(해시 함수로 변환 가능한 모든 해시 값을 저장시켜 놓은 조회 테이블)로 인해 해시로 저장된 비밀번호만 있으면 원래의 비밀번호를 추출할 수 있는 문제가 생겼다. 개발자들은 이러한 Rainbow Tables의 효과를 막기 위해 개발자는 솔트된 암호를 사용하였다. 솔트된 암호란 해시 함수에 대한 입력으로 암호만 사용하는 대신 모든 사용자의 암호에 대해 임의의 바이트(솔트)가 생성 된다. 솔트와 입력된 사용자의 비밀번호는 해시 함수를 통해 고유한 해시값을 생성하게 된다. 사용자가 인증을 시도하면 사용자 입력 암호와 솔트를 이용하여 해시 함수를 통해 해시 값을 만들어낸다. 만들어진 해시 값을 저장소에 저장된 고유한 해시값과 비교하게 된다. 솔트 값은 모든 암호마다 다르기 때문에 RainbowTables를 이용하여 비밀번호를 복호화 할 수 없게 된다. 현재는 이러한 해시 함수 또한 하드웨어의 발전으로 안전하지 않게 되었다(SHA-256을 초당 백만, 천만번 씩 수행할 수 있게 됨). 개발자들은 Adaptive one-way function을 이용하여 암호를 저장하는 방식을 발전하였다. Adaptive one-way function을 사용하는 암호의 유효성 검사는 의도적으로 하드웨어 리소스를 사용하여 암호화 시간을 조절 할 수 있다. 암호화 작업 시간은 1초가 적당하다. Spring Security는 사용자가 직접 암호화 작업 시간을 정의 하도록 하였다. 스프링 시큐리티가 제공하는 Adaptive one-way function을 사용하는 암호화 방식은 bcrypt, PBKDF2, scrypt, argon2가 있다. 위에 소개한 내용으로 스프링 시큐리티가 왜 이러한 암호화 방식을 채택했는지 이해 됐을것이다. 이후엔 스프링 시큐리티가 PasswordEncoder에 대해서 알아보겠다. DelegatingPasswordEncoder 스프링 시큐리티 5.0 이전에는 기본 PasswordEncoder가 일반 텍스트 암호가 필요한 NoOpPasswordEncoder였다. 그러나 Password Storage History에 따라서 기본 PasswordEncoder는 BCryptPasswordEncoder를 사용할 수도 안할 수도 있다. 기본 PasswordEncoder가 변경됨에 따라서 3가지 큰 문제를 일으키는데 첫번째로 이전 암호 인코딩을 사용하는 많은 프로그램이 있어 쉽게 마이그레이션을 할 수 없다. 두번째, 암호 저장에 대한 모범 사례가 다시 변경 된다. 세번째 프레임 워크로서 자주 변경이 일어나면 안된다. 이 문제를 해결하기 위해 DelegatingPasswordEncoder를 도입하였고 DelegatingPasswordEncoder는 아래와 같은 기능으로 위의 문제들을 해결하였다. 첫번째로 현재 암호 저장소가 권장하는 방식을 사용하여 인코딩 되는지 확인한다. 두번째는 최신 및 레거시 형식의 암호 유효성 검사를 허용한다. 세번째는 향후 인코딩 업그레이드를 허용한다. DelegatingPasswordEncoder는 PasswordEncoderFactories를 이용하여 인스턴스를 생성할 수 있다. 기본 DelegatingPasswordEncoder를 생성하는 방법이다. PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder(); 커스텀 DelegatingPasswordEncoder를 생성하는 방법이다. String idForEncode = &quot;bcrypt&quot;; Map encoders = new HashMap&amp;lt;&amp;gt;(); encoders.put(idForEncode, new BCryptPasswordEncoder()); encoders.put(&quot;noop&quot;, NoOpPasswordEncoder.getInstance()); encoders.put(&quot;pbkdf2&quot;, new Pbkdf2PasswordEncoder()); encoders.put(&quot;scrypt&quot;, new SCryptPasswordEncoder()); encoders.put(&quot;sha256&quot;, new StandardPasswordEncoder()); PasswordEncoder passwordEncoder = new DelegatingPasswordEncoder(idForEncode, encoders); Password Storage Format {id}encodePassword id는 PasswordEncoder의 식별자이고 encodedPassword는 인코딩된 password를 뜻한다. id를 찾을 수 없으면 null로 반환된다. Password Matching 매칭은 {id} 나 생성자에서 제공된 PasswordEncoder의 ID 매핑을 기반으로 수행된다. 패스워드나 맵핑되지 않은 ID를 사용하여 match를 호출하면 IllegalArgumentException이 발생한다. 이러한 오류를 예방하기 위해서 DelegatingPasswordEncoder.setDefaultPasswordEncoderForMatches (PasswordEncoder) 을 이용하여 기본값을 지정할 수 있다. 또한 암호가 저장되는 방식을 파악하여 아래처럼 명시적으로 제공을 해주면 된다. $2a$10$dXJ3SW6G7P50lGmMkkmwe. ... =&amp;gt; {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe. ... withDefaultPasswordEncoder Example User user = User.withDefaultPasswordEncoder() .username(&quot;user&quot;) .password(&quot;password&quot;) .roles(&quot;user&quot;) .build(); System.out.println(user.getPassword()); // {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG withDefaultPasswordEncoder Reusing the Builder UserBuilder users = User.withDefaultPasswordEncoder(); User user = users .username(&quot;user&quot;) .password(&quot;password&quot;) .roles(&quot;USER&quot;) .build(); User admin = users .username(&quot;admin&quot;) .password(&quot;password&quot;) .roles(&quot;USER&quot;,&quot;ADMIN&quot;) .build(); 위 두 예제는 암호를 해시하지만 암호는 여전히 메모리와 컴파일된 소스에 노출되고 있다. 이러한 문제는 큰 보안 사고로 이어질 수 있으므로 실제 프로덕션일 경우는 암호를 외부에서 해시 하여야 한다. 외부에서 인코딩하는 방법 중 하나를 아래에 설명하겠다. Encode with Spring Boot CLI 비밀번호를 외부에서 해시하는 방법 중 쉬운 방법으로는 Spring Boot CLI를 사용한다. 아래처럼 DelegatingPasswordEncoder로 암호화할 암호를 Spring CLI에 아래와 같이 입력 후 인코딩된 암호를 생성한다. 반환 되는 암호를 프로젝트의 application.properties에 user 비밀번호에 추가해 준다. 이후 컨트롤러를 생성후 아무 API을 만들고 요청을 하면 아래와 같은 로그인 화면이 나타나고 user의 이름과 패스워드를(pas1234) 입력한다. 정상적으로 로그인이 되며 인증이 진행된걸 확인할 수 있다. 아래에 소개하는 인코더들은 암호 크래킹의 내성을 위해 의도적으로 느리게 설계되어있으며 약 1초정도 걸리도록 조정하는것이 바람직하다. 자체 시스템에서 매개 변수를 조정하여 테스트하여 1초가 걸리도록 하면 된다. 알고리즘이 궁금하다면 알아서 찾아보도록… BCryptPasswordEncoder BCryptPasswordEncoder는 bdcrypt 알고리즘을 사용하여 암호를 해시한다. BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16); String result = encoder.encode(&quot;myPassword&quot;); assertTrue(encoder.matches(&quot;myPassword&quot;, result)); Argon2PasswordEncoder Argon2PasswordEncoder는 Argon2 알고리즘을 사용하여 암호를 해시한다. Argon2PasswordEncoder encoder = new Argon2PasswordEncoder(); String result = encoder.encode(&quot;myPassword&quot;); assertTrue(encoder.matches(&quot;myPassword&quot;, result)); Pbkdf2PasswordEncoder Pbkdf2PasswordEncoder는 PBKDF2 알고리즘을 사용하여 암호를 해시한다. Pbkdf2PasswordEncoder encoder = new Pbkdf2PasswordEncoder(); String result = encoder.encode(&quot;myPassword&quot;); assertTrue(encoder.matches(&quot;myPassword&quot;, result)); SCryptPasswordEncoder SCryptPasswordEncoder SCrypt 알고리즘을 사용하여 암호를 해시한다. SCryptPasswordEncoder encoder = new SCryptPasswordEncoder(); String result = encoder.encode(&quot;myPassword&quot;); assertTrue(encoder.matches(&quot;myPassword&quot;, result)); Other PasswordEncoders 이전 버전과의 호환성을 위해 구현된 PasswordEncoder들이 있다. 더 이상 안전하지 않기 때문에 사용되지 않는다. Password Storage Configuration NoOpPasswordEncoder를 사용하기 위해선 Spring bean으로 등록하여 사용한다. @Bean public static NoOpPasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } 1.2. Protection Against Exploits (악용에 대한 보호) 스프링 시큐리티는 일반적인 악용에 대한 방어를 제공한다. 가능하면 보호 기능은 기본적으로 활성화 되어 있다. 1.2.1. Cross Site Request Forgery (CSRF) 스프링 시큐리티는 CSRF 공격을 보호하는 기능을 제공한다. What is a CSRF Attack? 은행 웹 사이트에서 현재 로그인 한 사용자의 금액을 다른 은행 계좌로 이체할 수 있는 양식을 제공한다고 가정하자. &amp;lt;form method=&quot;post&quot; action=&quot;/transfer&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;amount&quot;/&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;routingNumber&quot;/&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;account&quot;/&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Transfer&quot;/&amp;gt; &amp;lt;/form&amp;gt; HTTP 요청은 아래와 같다 POST /transfer HTTP/1.1 Host: bank.example.com Cookie: JSESSIONID=randomid Content-Type: application/x-www-form-urlencoded amount=100.00&amp;amp;routingNumber=1234&amp;amp;account=9876 다음은 은행 웹사이트에 인증한 것처럼 가장한다. 은행 사이트에서 로그아웃하지 않고 악의적인 웹사이트를 접속한다. 악의적인 웹 사이트는 아래와 같다. &amp;lt;form method=&quot;post&quot; action=&quot;https://bank.example.com/transfer&quot;&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;100.00&quot;/&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;routingNumber&quot; value=&quot;evilsRoutingNumber&quot;/&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;evilsAccountNumber&quot;/&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Win Money!&quot;/&amp;gt; &amp;lt;/form&amp;gt; 아마도 의심이 없는 사람이라면 돈을 벌기 위해 제출 버튼을 누를것이고 이 과정에서 의도하지 않은 evilsAccountNumber로 100달러를 보내게 될것이다. 이것은 악의적인 사이트가 사용자의 쿠키를 볼 수는 없지만 은행과 관련된 쿠키는 여전히 요청과 함께 전송되기 때문에 가능하게 된다. 최악의 경우 이 프로세스가 javaScript를 이용하여 자동화 되었다면 접속과 동시에 송금이 될것이다. 또한 XSS공격으로 실제 정직한 은행 사이트를 방문 할 때도 악의적인 송금을 발생시킬 수 있다. Protecting Against CSRF Attacks CSRF 공격이 가능한 이유는 피해자 웹 사이트의 HTTP 요청과 공격자 웹 사이트의 요청이 정확히 동일하기 때문이다. 즉, 악의적인 웹 사이트에서 오는 요청을 거부하고 은행 웹 사이트에서 오는 요청을 허용 할 방법이 없다. CSRF 공격으로부터 보호하려면 요청에 악의적인 사이트가 제공 할 수 없는 것이 있는지 확인하여 두 요청을 구분할 수 있어야 한다. 스프링은 CSRF 공격으로부터 보호하기 위해 아래 두가지 메커니즘을 제공한다. Synchronizer Token Pattern 쿠키에 SameSite Attribute을 지정 Safe Methods Must be Idempotent CSRF에 대한 보호가 작동하려면 어플리케이션이 safe한 메소드가 멱등성을 보장해야한다. (멱등성이란 어떠한 연산을 여러번 하더라도 결과가 달라지지 않는 성질이다.) HTTP 메서드 중 GET, HEAD, OPTIONS, TRACE를 사용하는 요청은 리소스의 상태를 변경해서는 안된다. Synchronizer Token Pattern CSRF 공격으로부터 보호하는 가장 잘알려진 방법은 Synchronizer Token을 사용하는 것이다. 이 방법은 각 HTTP 요청에 세션 쿠키 외 CSRF 토큰이라는 임의 생성 값을 넣어 보내는 것이다. HTTP 요청이 제출되면 서버는 예상되는 CSRF 토큰을 찾아 HTTP 요청의 CSRF 토큰과 비교한다. 값이 일치하지 않으면 해당 요청을 거부한다. Synchronizer Token 방법의 핵심은 CSRF 토큰이 브라우저에 의해 자동으로 포함되지 않는 HTTP 요청의 일부에 있어야한다는 것이다(쿠키에 CSRF 토큰이 있으면 안됨 이후 설명). 예를 들어 HTTP 매개변수 또는 HTTP 헤더에 실제 CSRF 토큰을 요구하면 CSRF 공격으로부터 보호된다. 쿠키는 브라우저의 HTTP 요청에 자동으로 포함되므로 쿠키에 CSRF 토큰을 요구하는 것은 동작하지 않는다. 리소스 상태를 업데이트하는 HTTP 요청에 대해 CSRF 토큰만 필요하도록 할 수 있다. 이것이 동작하려면 우리는 HTTP 메소드가 멱등성을 보장해야한다. 이는 외부 사이트의 링크를 사용하여 당사 웹사이트로의 링크를 허용하기 때문에 사용성을 향상 시킨다. 또한 토큰이 유출 될 수 있으므로 HTTP GET에 토큰을 포함하지 않아야 한다. Synchronizer Token Pattern을 사용하는 예제를 확인해보자 &amp;lt;form method=&quot;post&quot; action=&quot;/transfer&quot;&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;4bfd1575-3ad1-4d21-96c7-4ef2d9f86721&quot;/&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;amount&quot;/&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;routingNumber&quot;/&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;account&quot;/&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Transfer&quot;/&amp;gt; &amp;lt;/form&amp;gt; 양식에 CSRF 토큰값이 숨겨져 있다. Same Origin Policy이 악의적 사이트가 응답을 읽을 수 없도록 보장하기 떄문에 외부 사이트는 CSRF 토큰을 읽을 수 없다. POST /transfer HTTP/1.1 Host: bank.example.com Cookie: JSESSIONID=randomid Content-Type: application/x-www-form-urlencoded amount=100.00&amp;amp;routingNumber=1234&amp;amp;account=9876&amp;amp;_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721 HTTP 요청서에 _csrf 매개 변수가 포함되어 있는것을 확인할 수 있다. 악의적인 웹사이트는 _csrf 매개변수에 대한 올바른 값을 제공 할 수 없으며 서버가 CSRF 토큰을 예상 된 CSRF 토큰과 비교할 때 전송이 실패한다. SameSite Attribute CSRF 공격으로 부터 보호하는 새로운 방법은 쿠키에 SameSite 속성을 지정하는 것이다. 서버는 쿠키를 설정할 때 SameSite 속성을 지정하여 외부 사이트에서 올 때 쿠키를 보내지 않아야 함을 나타낼 수 있다. 스프링 시큐리티는 세션 쿠키 생성을 직접 제어하지 않으므로 SameSite 속성에 대한 지원을 제공하지 않는다. 스프링 세션은 서블릿 기반 어플리케이션에서 SameSite 속성에 대한 지원을 제공한다. SameSite 속성이 있는 HTTP 응답 헤더를 보자 Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax SameSite 속성의 값은 아래와 같다. Strict - 지정된 경우 동일한 사이트에서 들어오는 모든 요청에 쿠키가 포함된다. 동일한 사이트가 아니라면 쿠키가 HTTP 요청에 포함되지 않는다 Lax - 동일한 사이트거나 요청이 최상위 수준 탐색에서 오고 메서드가 멱등성인 경우 지정된 쿠키가 전송된다. 그렇지 않으면 쿠키가 HTTP 요청에 포함되지 않는다. , , &amp;lt;form method=get&amp;gt;은 예외 나머지는 Strict와 동일. SameSite 속성을 사용하여 은행 송금 예제를 보호하는 방법을 알아보자. 은행 어플리케이션은 세션 쿠키에 SameSite 속성을 지정하여 CSRF로 부터 보호 할 수 있다. 세션 쿠키에 SameSite 속성이 설정되어 있으면 브라우저는 은행 웹 사이트에서 오는 요청과 함께 JSESSIONID 쿠키를 계속 보낸다. 그러나 악의적인 웹 사이트에서 들어오는 전송 요청은 JSESSIONID 쿠키를 보내지 않는다. 세션이 더 이상 악의적인 웹사이트에서 오는 전송 요청에 존재하지 않으므로 애플리케이션은 CSRF 공격으로부터 보호된다. SameSite 속성을 Strict로 설정하면 더 강력한 방어가 제공되지만 사용자에게 혼란을 줄 수 있다. https://social.example.com에서 호스팅 되는 소셜 미디어 사이트에 로그인 되어 있는 사용자를 생각해보자. 사용자는 https://email.example.org에서 소셜 미디어 사이트에 대한 링크가 포함된 이메일을 받는다. 사용자가 링크를 클릭하면 소셜 미디어 사이트에 대한 인증을 받을 것으로 기대한다. 하지만 SameSite 속성이 Strict이면 쿠키가 전송되지 않으므로 사용자가 인증되지 않는다. 또 다른 고려 사항은 SameSite 속성이 사용자를 보호하려면 브라우저가 SameSite 속성을 지원해야한다. 이러한 이유로 CSRF 공격에 대한 보호로 유일한 방법을 사용하는것보다 여러 방법을 사용하는것이 권장된다. When to use CSRF protection 일반 사용자가 브라우저에서 처리할 수 있는 모든 요청에 대해 CSRF 보호가 되야 한다. 브라우저가 아닌 클라이언트에서 사용하는 서비스만 만드는 경우 CSRF 보호를 비활성화 할 수 있다. (세션을 사용하지 않거나 브라우저를 사용하지 않으면 쿠키를 사용할 일이 없기 때문.) CSRF protection and JSON JSON 요청에 영향을 줄 수 있는 CSRF 위협이 있으므로 주의해야한다. 예를 들어 악의적인 사용자는 아래와 같이 CSRF를 만들 수 있다. &amp;lt;form action=&quot;https://bank.example.com/transfer&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot;&amp;gt; &amp;lt;input name='{&quot;amount&quot;:100,&quot;routingNumber&quot;:&quot;evilsRoutingNumber&quot;,&quot;account&quot;:&quot;evilsAccountNumber&quot;, &quot;ignore_me&quot;:&quot;' value='test&quot;}' type='hidden'&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Win Money!&quot;/&amp;gt; &amp;lt;/form&amp;gt; 위처럼 name에 json을 양식을 작성하고 value값과 연결되는 =을 없애기 위해 &quot;ignore_me&quot;:&quot;' value='test&quot;}'이런식으로 끝나도록 &amp;lt;input &amp;gt;을 작성한다. 결과 값은 아래와 같은 JSON 구조가 된다. { &quot;amount&quot;: 100, &quot;routingNumber&quot;: &quot;evilsRoutingNumber&quot;, &quot;account&quot;: &quot;evilsAccountNumber&quot;, &quot;ignore_me&quot;: &quot;=test&quot;} 어플리케이션이 Content-Type의 유효성을 검사하지 않으면 이 악용에 노출된다. 설정에 따라 Content-Type을 검증하는 Spring MVC 프로그램은 아래와 같이 .json으로 끝나도록 URL 접미사를 업데이트하여 악용할 수 있다. &amp;lt;form action=&quot;https://bank.example.com/transfer.json&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot;&amp;gt; &amp;lt;input name='{&quot;amount&quot;:100,&quot;routingNumber&quot;:&quot;evilsRoutingNumber&quot;,&quot;account&quot;:&quot;evilsAccountNumber&quot;, &quot;ignore_me&quot;:&quot;' value='test&quot;}' type='hidden'&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Win Money!&quot;/&amp;gt; &amp;lt;/form&amp;gt; CSRF and Stateless Browser Applications 어플리케이션이 stateless 하더라도 CSRF의 공격에 대해 안전한것은 아니다. 실제로 사용자가 특정 요청에 대해 웹브라우저에서 어떠한 작업도(SameSite 쿠키를 이용한다거나 Synchronizer Token과 같은 작업) 수행할 필요가 없다면 CSRF 공격에 여전히 취약 할 수 있다. 예를 들어 JSESSIONID 대신 인증을 위해 모든 상태를 포함하는 사용자 지정 쿠키를 사용하는 어플리케이션이 있다. CSRF 공격이 발생하면 이전 예제에서 JSESSIONID 쿠키가 전송 된 것과 동일한 방식으로 사용자 지정 쿠키가 요청과 함께 전송된다. 이런 어플리케이션은 CSRF 공격에 취약하다. CSRF Considerations CSRF 공격에 대한 보호를 구현할 때 고려해야 할 몇 가지 특별한 고려사항이 있다. Logging In 위조 된 로그인 요청으로부터 보호하려면 로그인 HTTP 요청을 CSRF 공격으로부터 보호해야한다. 위조 로그인 요청으로부터 보호하여 악의적 인 사용자가 피해자의 민감한 정보를 읽을 수 없도록 해야한다. 로그인시 공격은 아래와 같은 방식으로 이루어진다. 악의적인 사용자는 악의적인 사용자의 자격 증명을 사용하여 CSRF 로그인을 수행한다. 피해자는 이제 악의적인 사용자로 인증된다.(로그인을 위해 필요한 자격 증명을 악의적인 사용자의 것을 이용한다는 것이다. 여기서 설명하는 자격 증명은 csrf토큰이나 쿠키의 samesite 속성과 같이 HTTP 요청이 올바른 곳에서 요청 됐다는것을 나타낼수 있는 정보를 나타내는것 같다.) 이후 악의적인 사용자가 피해자를 속여 악의적인 웹 사이트를 방문하도록 하고 민감한 정보를 입력하도록 한다. 정보는 악의적인 사용자의 계정과 연결되어 있으므로 악의적인 사용자는 자신의 자격 증명으로 로그인하여 피해자의 민감한 정보를 볼 수 있다. (악의적인 사용자의 자격 증명으로 인해 악의적인 사이트에서도 로그인 요청이 가능하게 됨.) 로그인 HTTP 요청이 CSRF 공격으로부터 보호되도록 하는데 발생할 수 있는 문제는 세션 타임 아웃 때문에 사용자가 요청이 거부되는 경험을 할 수 있다. 세션 타임아웃은 로그인하기 위해 세션이 필요하지 않을것으로 예상하는 사용자들을 놀랍게 한다. Logging Out 위조된 로그아웃 요청으로부터 보호하려면 로그아웃 HTTP 요청을 CSRF 공격으로부터 보호해야한다. 악의적인 사용자가 피해자의 민감한 정보를 읽을 수 없도록 위조 로그아웃 요청으로부터 보호해야한다. 공격에 대한 내용은 아래와 같은 방식으로 이루어진다. ApplicationX는 login/logout CSRF를 가진 OAUTH 제공자라고 가정한다. ApplicationY는 ApplicationX와의 연결을 구현했다. 연결되어있는 ApplicationX의 계정을 ApplicationY의 권한 인증하는데 사용할 것이다. 공격자 CSRF가 ApplicationX로 부터 피해자를 로그아웃한다. 공격자 CSRF가 ApplicationX에 피해자를 로그인한다. (피해자는 이제 ApplicationX에서 공격자로 로그인 되었다) 공격자는 피해자에게 ApplicationX 연결 기능을 보낸다 공격자의 ApplicationX 계정을 피해자의 ApplicationY 계정으로 연결한다. 공격자는 ApplicationX 로그인을 사용하여 ApplicationY에서 피해자로 인증을 한다. 이외 추가적인 내용은 여기를 참고 로그아웃 HTTP 요청이 CSRF 공격으로부터 보호되도록 하기 위해 발생할 수 있는 문제는 세션 타임 아웃 때문에 사용자가 요청이 거부되는 경험을 할 수 있다. 세션 타임아웃은 로그아웃하기 위해 세션이 필요하지 않을 것으로 예상하는 사용자들을 놀랍게 한다. CSRF and Session Timeouts 서버에서는 CSRF 토큰이 세션에 저장 된다. 이는 세션이 만료되면 서버가 해당하는 CSRF 토큰을 찾지 못하고 HTTP 요청을 거부 한다. 타임 아웃을 해결하는 데는 여러가지 옵션이 있으며 각 옵션 마다 장단점이 존재한다. 타임 아웃을 완화하는 가장 좋은 방법은 JavaScript를 사용하여 양식 제출시 CSRF 토큰을 요청하는것이다. 그런다음 양식이 CSRF 토큰으로 업데이트 되고 제출 된다. 다른 옵션은 사용자에게 세션이 만료 될 예정임을 알리는 JavaScript를 사용하는 것이다. 사용자는 버튼을 클릭하여 세션을 지속하거나 재부여할 수 있다. 마지막으로 CSRF 토큰을 쿠키에 저장할 수 있다. 이를 통해 CSRF 토큰이 세션보다 오래 지속될 수 있다. CSRF 토큰이 기본적으로 쿠키에 저장되지 않는 이유를 물을 수 있다. 다른 도메인에서 헤더(쿠키 지정)를 설정할 수 있는 알려진 공격이 있다. 이는 Ruby on Rails가 헤더 X-Requested-With가있을 때 더 이상 CSRF 검사를 건너 뛰지 않는 이유와 같다. 또 다른 단점은 상태 (즉, 시간 제한)를 제거하면 토큰이 손상된 경우 강제로 무효화 할 수있는 기능이 없다. Multipart (file upload) CSRF 공격이 발생하지 않도록 하려면 CSRF 토큰을 얻기 위해 HTTP 요청 본문을 읽어야한다. 그러나 본문을 읽는다는 것은 파일이 업로드 된다는 것을 의미하므로 외부 사이트에서 파일을 업로드 할 수 있다. 이렇기 때문에 MUltipart/form-data에서 CSRF 보호를 사용하는 두가지 옵션이 존재한다. Place CSRF Token in the Body 첫번째 옵션은 요청 본문에서 실제 CSRF 토큰을 포함하는 것이다. CSRF 토큰을 본문에 배치하면 권한이 수행되기 전에 본문을 읽게 된다. 즉, 누구나 서버에 임시 파일을 저장할 수 있다. 그러나 승인 된 사용자의 요청만 파일을 제출할 수 있다. 일반적으로 임시 파일 업로드는 대부분의 서버에 거의 영향을 미치지 않기 때문에 권장되는 접근 방식이다. Include CSRF Token in URL 권한이 없는 사용자가 임시 파일을 업로드 하도록 허용하는 것이 허용되지 않는 경우, 대안은 서버의 CSRF 토큰을 form 속성에 쿼리 매개변수로 포함하는 것이다. 이 방식의 단점은 쿼리 매개 변수가 유출 될 수 있다는 것이다. 일반적으로 중요한 데이터는 유출되지 않도록 본문 또는 헤더 내에 배치하는 것이 모범 사례이다. HiddenHttpMethodFilter 일부 어플리케이션에서는 form 매개 변수를 사용하여 HTTP 메서드를 재정의 할 수 있다. 예를 들어 아래처럼 HTTP 메서드를 POST가 아닌 DELETE로 처리할 수 있다 &amp;lt;form action=&quot;/process&quot; method=&quot;post&quot;&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&amp;gt; &amp;lt;/form&amp;gt; HTTP 메서드 오버라이딩은 필터에서 발생한다. 해당 필터는 Spring Security 이전에 배치 되어야 한다. 오버라이딩은 POST에서만 발생하므로 실제로 문제가 발생하지 않을 가능성이 있다. 그러나 Spring Security의 필터 앞에 배치 되도록 하는것이 모범 사례이다. 1.2.2. Security HTTP Response Headers 웹 어플리케이션의 보안을 강화하는데 사용할 수 있는 많은 HTTP 응답 헤더가 있다. Spring Security가 명시적으로 지원하는 다양한 HTTP 응답 헤더를 설명한다. 필요한 경우 사용자 지정 헤더를 제공하도록 Spring Security를 구성할 수 있다. Default Security Headers 스프링 시큐리티는 기본적인 보안 값을 제공하기 위해 보안 관련 HTTP 응답 헤더의 기본 집합을 제공한다. 스프링 시큐리티의 기본값은 다음 헤더를 포한한다. Cache-Control: no-cache, no-store, max-age=0, must-revalidate Pragma: no-cache Expires: 0 X-Content-Type-Options: nosniff Strict-Transport-Security: max-age=31536000 ; includeSubDomains // Strict-Transport-Security는 HTTPS 요청에만 추가됩니다. X-Frame-Options: DENY X-XSS-Protection: 1; mode=block 기본값이 요구 사항을 충족하지 않는 경우 이러한 기본값에서 헤더를 쉽게 제거, 수정 또는 추가 할 수 있다. Cache Control 스프링 시큐리티의 기본값은 사용자 컨텐츠를 보호하기 위해 캐싱을 비활성화 하는 것이다. 사용자가 민감한 정보를 보기 위해 인증한 다음 로그아웃하는 경우 악의적인 사용자가 뒤로 버튼을 클릭하여 민감한 정보를 볼 수 없도록 한다. 기본적으로 전송되는 캐시 제어 헤더는 다음과 같다. Cache-Control: no-cache, no-store, max-age=0, must-revalidate Pragma: no-cache Expires: 0 기본적인 보안을 유지하기 위해 스프링 시큐리티는 기본적으로 헤더를 추가한다. 그러나 응용 프로그램이 자체 캐시 제어 헤더를 제공하는 경우 스프링 시큐리티는 중단된다. 이를 통해 어플리케이션은 CSS 및 JavaScript와 같은 정적 리소스를 캐시 할 수 있다. Content Type Options 지금까지 Internet Explorer를 포함한 브라우저는 컨텐츠 스니핑(데이터의 파일 형식을 추론하는 방법)을 사용하여 요청의 content-type을 추측하려 했다. 이를 통해 브라우저는 content-type을 지정하지 않은 리소스의 content-type을 추측하여 사용자 경험을 개선 할 수 있었다. 예를 들어, 브라우저가 content-type이 지정되지 않은 JavaScript파일을 발견한 경우 content-type을 추측한 다음 실행할 수 있다. 컨텐츠 업로드를 허용 할 때해야 할 많은 추가 작업이 있따.(예를 들어 고유한 도메인에 문서만 표시, content-type 헤더 설정 확인, 문서 삭제 등). 그러나 이러한 조치는 스프링 시큐리티가 제공하는 범위를 벗어난다. 컨텐츠 스니핑을 비활성화 할 때 제대로 작동하려면 content-type을 지정해야한다는 점을 지적하는것도 중요하다. 컨텐츠 스니핑의 문제점은 악의적인 사용자가 다중 컨텐츠(즉, 여러 컨텐츠 유형으로 유효한 파일)를 사용하여 XSS 공격을 수행 할 수 있다는 것입니다. 예를 들어, 일부 사이트에서는 사용자가 유효한 postscript document를 웹 사이트에 제출하고 볼 수 있도록 허용 할 수 있다. 악의적인 사용자가 유효한 JavaScript 파일 인 postscript document를 만들어 XSS 공격을 수행 할 수 있다. postscript document 취약점을 참고. 스프링 시큐리티는 HTTP 응답에 다음 헤더를 추가하여 기본적으로 컨텐츠 스니핑을 비활성화 한다. X-Content-Type-Options: nosniff HTTP Strict Transport Security (HSTS) https 프로토콜을 생략하면 중간자 공격에 잠재적으로 취약하다. 웹 사이트가 https로 리디렉션을 수행하더라도 악의적 인 사용자가 초기 HTTP 요청을 가로 채서 응답을 조작 할 수 있다. (예 : https://악의적인 사이트.com으로 리디렉션하게 하고 자격 증명을 훔칠 수 있음) 많은 사용자가 https 프로토콜을 생략하기 때문에 HTTP Strict Transport Security (HSTS)가 만들어졌다. 예를 들어 mybank.example.com이 HSTS 호스트로 추가 되면 브라우저는 mybank.example.com에 대한 모든 요청이 https://mybank.example.com으로 해석되어야 함을 미리 알 수 있다. 이렇게 하면 중간자 공격이 발생할 가능성이 크게 줄어 든다. RFC 6797에 따라 HSTS 헤더는 HTTPS 응답에만 삽입된다. 브라우저가 헤더를 확인하려면 먼저 연결에 사용 된 SSL 인증서에 서명한 CA (SSL 인증서 뿐만 아니라)를 신뢰해야한다. 사이트를 HSTS 호스트로 표시하는 한 가지 방법은 호스트를 브라우저에 미리 로드하는 것이다. 또 다른 방법은 Strict-Transport-Security 헤더를 응답에 추가하는 것이다. 예를 들어, Spring Security의 기본 동작은 브라우저가 도메인을 1년 동안 HSTS 호스트로 처리하도록 지시하는 다음 헤더를 추가하는 것이다. (1 년에 약 31536000초). Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload 선택 사항 인 IncludeSubDomains 지시문은 하위 도메인 (예 : secure.mybank.example.com)도 HSTS 도메인으로 처리되어야 함을 브라우저에 지시합니다. 선택적 preload 지시문은 도메인이 HSTS 도메인으로 브라우저에 사전로드 되어야 함을 브라우저에 지시합니다. 사용자가 HSTS Lists를 가지고 있지 않다면 Web Browser는 HTTP Protocol을 사용하여 접속을 하게 되는데 이때 SSL Stripping 공격을 받을 가능성이 있기 때문에 이것을 방지하기 위해 preload를 한다. Preloaded HSTS Lists에 포함되도록 하려면, “hstpreload.org” Site에 신청을 해야 한다. 또한 Web Browser 사용자가 직접 자신의 Web Browser에 특정 Web Site를 HSTS List에 추가할 수 있도록 기능을 제공하기도 한다(예를 들어 크롬). HTTP Public Key Pinning (HPKP) 패시브 상태를 유지하기 위해 스프링 시큐리티는 여전히 서블릿 환경에서 HPKP에 대한 지원을 제공하지만 위에 나열된 이유로 인해 보안팀에서 더이상 HPKP를 권장하지 않는다. HPKP는 위조 된 인증서로 MTM(Man in the Middle) 공격을 방지하기 위해 특정 웹서버에서 사용할 공개 키를 웹 클라이언트에 지정한다. HPKP가 올바르게 사용되면 손상된 인증서에 대한 보호를 할 수 있다. 그러나 HPKP의 복잡성으로 인해 많은 전문가들은 더 이상 사용을 권장하지 않으며 Chrome은 더 이상 지원하지 않는다. X-Frame-Options 웹 사이트를 프레임에 추가하는 것은 보안 문제가 될 수 있다. 예를 들어, 영리한 CSS 스타일을 사용하는 사용자는 의도하지 않은 것을 클릭하도록 속일 수 있다. 예를 들어 은행에 로그인 한 사용자가 다른 사용자에게 엑세스 권한을 부여하는 버튼을 클릭 할 수 있다. 이러한 종류의 공격을 클릭 재킹이라고 한다. (클릭 재킹 ClickJacking이란 사용자가 인식하는것과 다른것을 클릭 하도록 사용자를 속여 잠재적으로 기밀 정보를 노출하거나 다른 사람이 컴퓨터를 제어하도록 허용 하는 악의 적인 기술) 클릭 재킹을 처리하는 또 다른 현대적인 접근 방식은 컨텐츠 보안 정책(CSP)을 사용하는 것이다. 클릭 재킹 공격을 완화하는 방법에는 여러가지가 있다. 예를 들어, 기존 브라우저를 클릭 재킹 공격으로부터 보호하기 위해 프레임 브레이킹 코드를 사용할 수 있다. 완벽하지는 않지만 프레임 분리 코드는 레거시 브라우저에서 할 수 있는 최선의 방법이다. 클릭 재킹을 해결하기 위한 현대적인 방법은 X-Frame-Options 헤더를 사용하는것이다. 기본적으로 Spring Security는 다음 헤더를 사용하여 iframe 내에서 페이지 렌더링을 비활성화 한다. X-Frame-Options: DENY X-XSS-Protection 일반 브라우저는 XSS 공격을 필터링하는 기능을 내장하고 있다. 이것은 절대적으로 안전하지는 않지만 XSS 보호에 도움이 된다. 필터링은 기본적으로 활성화 되어 있으므로 헤더를 추가하면 일반적으로 활성화되도록 보장하고 XSS 공격이 탐지 될 때 브라우저에 수행할 작업을 지시한다. 예를 들어 필터는 모든 것을 렌더링하기 위해 가장 덜 침습적인 방식으로 컨텐츠를 변경하려 할 수 있다. 때떄로 이러한 유형의 교체는 그 자체로 XSS 취약점이 될 수 있다. 대신 컨텐츠를 수정하는 것보다 차단하는것이 가장 좋다. 기본적으로 Spring Security는 다음 헤더를 사용하여 컨텐츠를 차단한다. X-XSS-Protection: 1; mode=block Content Security Policy (CSP) CSP(컨텐츠 보안 정책)은 웹 애플리케이션이 XSS와 같은 컨텐츠 주입 취약성을 완화하기 위해 활용할 수 있는 메커니즘이다. CSP는 웹 응용 프로그램 작성자가 웹 응용 프로그램이 리소스를 로드 할 것으로 예상하는 소스에 대해 선언하고 궁극적으로 클라이언트에게 알리는 기능을 제공하는 선언적 정책이다. CSP는 모든 컨텐츠 삽입 취약점을 해결하기 위한 것이 아니다. 대신 CSP를 활용하여 컨텐츠 삽입 공격으로 인한 피해를 줄일 수 있다. 첫번째 방어선으로 웹 애플리케이션 작성자는 입력의 유효성을 검사하고 출력을 인코딩해야한다. 웹 애플리케이션은 응답에 다음 HTTP 헤더 중 하나를 포함하여 CSP를 사용 할 수 있다. Content-Security-Policy Content-Security-Policy-Report-Only 이러한 각 헤더는 클라이언트에 보안 정책을 전달하는 메커니즘으로 사용 된다. 보안 정책에는 특정 리소스 representation에 대한 제한을 선언하는 보안 정책 지시문 집합이 포함된다. 예를 들어 웹 애플리케이션은 응답에 다음 헤더를 포함하여 신뢰할 수 있는 특정 소스에서 스크립트를 로드 할 것으로 예상한다고 선언 할 수 있다. Content-Security-Policy: script-src https://trustedscripts.example.com script-src지시문에 선언된 것 이외의 다른 소스에서 스크립트를 로드하려는 시도는 user-agent에 의해 차단된다. 또한 report-url 지시문이 보안 정책에 선언 된 경우 사용자 에이전트는 선언 된 URL에 위반 사항을 보고한다. 예를 들어 웹 애플리케이션이 선언 된 보안 정책을 위반하는 경우 다음 응답 헤더는 정책의 report-uri 지시문에 지정된 URL로 위반 보고서를 보내도록 user-agent에 지시한다. Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/ 위반 보고서는 웹 애플리케이션 자체 API 또는 https://report-uri.io/와 같이 공개적으로 호스팅 되는 CSP 위반 보고 서비스에서 캡처 할 수 있는 표준 JSON 구조이다. Content-Security-Policy-Report-Only 헤더는 웹 어플리케이션 작성자 및 관리자가 보안 정책을 시행하는 대신 모니터링 할 수 있는 기능을 제공한다. 이 헤더는 일반적으로 사이트에 대한 보안 정책을 실험 및 개발 할 때 사용된다. 정책이 유효한 것으로 간주되면 대신 Content-Security-Policy 헤더 필드를 사용하여 적용 할 수 있다. Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/ 사이트가 이 정책을 위반하는 경우 evil.com에서 스크립트를 로그하려고 시도하면 user-agent는 report-uri 지시문에 선언 된 URL로 위반 보고서를 보내지만 그래도 위반 리소스가 로드되도록 허용한다. Referrer Policy Referrer Policy은 웹 어플리케이션이 사용자가 마지막을 방문한 페이지를 포함하는 referrer 필드를 관리하는데 활용할 수 있는 메커니즘이다. Spring Security의 접근 방식은 다른 정책을 제공하는 Referrer-Policy 헤더를 사용하는 것이다. Referrer-Policy: same-origin Referrer-Policy 응답 헤더는 대상이 사용자가 이전에 있었던 소스를 알도록 브라우저에 지시한다. Feature Policy Feature Policy은 웹 개발자가 브라우저에 특정 API 및 웹 기능의 동작을 선택적으로 활성화, 비활성화 및 수정할 수 있도록하는 메커니즘이다. Feature-Policy: geolocation 'self' Feature Policy을 통해 개발자는 브라우저가 사이트 전체에서 사용되는 특정 기능에 적용할 ‘policies’집합을 선택할 수 있다. 이러한 정책은 사이트가 특정 기능에 대한 브라우저의 기본 동작에 엑세스 하거나 수정할 수 있는 API를 제한한다. Clear Site Data Clear Site Data는 HTTP 응답에 다음 헤더가 포함 된 경우 브라우저 측 데이터(쿠키, 로컬 저장소 등)를 제거 할 수 있는 메커니즘이다. Clear-Site-Data: &quot;cache&quot;, &quot;cookies&quot;, &quot;storage&quot;, &quot;executionContexts&quot; 이것은 로그아웃시 수행 할 수 있는 좋은 정리 작업이다. Custom Headers Spring Security는 어플리케이션에 보안 헤더를 편리하게 추가 할 수 있는 메커니즘이 있다. 그러나 사용자 지정 헤더를 추가할 수 있는 후크도 제공한다. 1.2.3. HTTP 정적 리소스를 포함한 HTTP 기반 통신은 TLS를 사용하여 보호해야 한다. 프레임 워크로서 Spring Security는 HTTP 연결을 처리하지 않으므로 HTTPS를 직접 지원하지 않는다. 그러나 HTTPS 사용에 도움이 되는 여러 기능을 제공한다. Redirect to HTTPS 클라이언트가 HTTP를 사용할 때 HTTPS로 리디렉션하도록 구성할 수 있다. Strict Transport Security Spring security는 Strict Transport Security에 대한 지원을 제공하며 기본적으로 활성화 한다. Proxy Server Configuration 프록시 서버를 사용하는 경우 어플리케이션을 올바르게 구성했는지 확인 하는 것이 중요하다. 예를 들어 많은 어플리케이션에는 적절한 구성 없이 http://192.168.1:8080에 어플리케이션 서버로 요청을 전달하여 https://example.com/ 요청에 응답하는 로드 밸런서가 있다. 어플리케이션 서버는 로드 밸런서가 존재하는지 모르고 요청을 https://192.168.1:8080이 클라이언트에서 요청한 것처럼 처리한다. 이 문제를 해결하려면 RFC7239를 사용하여 로드 밸런서를 사용하도록 지정할 수 있다. 어플리케이션이 이를 인식하도록 하려면 X-Forwarded 헤더를 인식하는 어플리케이션 서버를 구성해야 한다. 예를 들어 Tomcat은 RemoteValve를 사용하고 Jetty는 FowardedRequestCustomizer를 사용한다. Spring 사용자는 ForwardedHeaderFilter를 활용할 수 있다. Spring Boot 사용자는 server.user-forward-headers 속성을 사용하여 어플리케이션을 구성할 수 있다.</summary></entry><entry><title type="html">HTTP 1.1 Reference - Semantics and Content (1) (최종 수정 날짜 : 2021-02-06)</title><link href="https://lcy960729.github.io/http/2021/02/06/HTTP1-1-Semantics-And-Content(1).html" rel="alternate" type="text/html" title="HTTP 1.1 Reference - Semantics and Content (1) (최종 수정 날짜 : 2021-02-06)" /><published>2021-02-06T00:00:00+09:00</published><updated>2021-02-06T00:00:00+09:00</updated><id>https://lcy960729.github.io/http/2021/02/06/HTTP1-1-Semantics-And-Content(1)</id><content type="html" xml:base="https://lcy960729.github.io/http/2021/02/06/HTTP1-1-Semantics-And-Content(1).html">&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본&lt;br /&gt;
&lt;a href=&quot;https://roka88.dev/106&quot;&gt;https://roka88.dev/106&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MDN Web Docs&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP&quot;&gt;https://developer.mozilla.org/ko/docs/Web/HTTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외 자료는 내용 중 링크 추가&lt;/p&gt;
&lt;h5 id=&quot;틀린-내용-부족한-내용-꼭-지적-부탁드립니다&quot;&gt;틀린 내용, 부족한 내용 꼭 지적 부탁드립니다!&lt;/h5&gt;

&lt;h1 id=&quot;http-11-reference---semantics-and-content&quot;&gt;HTTP 1.1 Reference - Semantics and Content&lt;/h1&gt;
&lt;h1 id=&quot;1-간단한-설명&quot;&gt;1. 간단한 설명&lt;/h1&gt;

&lt;p&gt;HTTP 메시지는 요청 또는 응답을 나타낸다.&lt;/p&gt;

&lt;p&gt;서버는 클라이언트에게 요청을 받고 수신된 메시지를 해석 후 허락된 클라이언트에게 하나 이상의 응답 메시지를 반환한다. (서버가 먼저 클라이언트에게 요청할 수 는 없다. 웹소켓 제외)&lt;/p&gt;

&lt;p&gt;클라이언트는 특정한 의도를 나타내는 요청 메시지를 서버에게 보낸후 수신된 응답을 확인하여 (상태 코드 확인) 의도대로 수행되었는지 확인 후 응답 메세지를 결과를 확인한다(Response Body의 내용을 확인).&lt;/p&gt;

&lt;h1 id=&quot;2-resources&quot;&gt;2. Resources&lt;/h1&gt;

&lt;p&gt;HTTP의 요청 대상을 resource라고 부른다. HTTP는 리소스와 상호 작용을 할 수 있는 인터페이스(아마 HTTP가 요청과 응답하는 구조의 내용일듯)를 정의하고 리소스는 URI로 식별된다.&lt;/p&gt;

&lt;p&gt;HTTP의 설계 목표 중 하나는 요청의 의미론에서 리소스 식별을 분리 하는것이다. 예를 들어 URI는 리소스를 처리할 행위 모두를 나타내는것이 아니라 URI는 리소스를 식별하는 역할만 하는것이고 메소드나 다른 헤더를 통해 어떠한 역할을 수행해야하는지를 식별하도록 하는것이다. 그렇기 때문에 URI는 겹칠 수 있지만 메소드가 다를 경우 다른 동작을 하게 되는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST http://localhost/get_user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에 내용을 보충 해보면 조금 극단적인 예라 생각 하지만 위 요청처럼 URI에 리소스에 대한 행위를 담는것이 아니라 아래처럼 메소드나 부가적인 헤더를 이용하여 행위를 나타내는것이 HTTP 설계 목표이다. (라고 이해했다 나는…)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET http://localhost/user
POST http://localhost/user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-representations&quot;&gt;3. Representations&lt;/h1&gt;

&lt;p&gt;참고자료 (&lt;a href=&quot;https://blog.npcode.com/2017/04/03/rest%EC%9D%98-representation%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/&quot;&gt;https://blog.npcode.com/2017/04/03/rest의-representation이란-무엇인가/&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;리소스는 무엇이든 될 수 있으며 해당 행위들은 여러가지가 될 수 있다. 이러한 점에서 우리는 서버에 원하는 요청(상태)를 나타내기위한 추상화가 필요한데 그 추상화를 우리는 REST라고 부른다.&lt;/p&gt;

&lt;p&gt;HTTP의 목적 상 Representations는 주어진 리소스의 상태(과거, 현재, 또는 원하는 상태)를 프로토콜을 통해 쉽게 전달할 수 있는 형식으로 반영하기 위한 정보이다. 표현 데이터는 데이터 스트림으로 구성된다.&lt;/p&gt;

&lt;p&gt;Representations의 예를 들어보면 아래의 요청에 대해 아래와 같은 응답들을 볼 수 있다. 이러한 응답들을 representation이라고 한다. 첫번째는 사용자1이라는 리소스를 한글 사용자들을 위한 상태로 반환 한것이다. 두번째는 영문 사용자, 세번째는 html로, 네번째는 json의 형태로 반환 한것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET http://localhost/user
Content-Type: text/plain
Content-Language: ko

응답 : 사용자1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET http://localhost/user
Content-Type: text/plain
Content-Language: en

응답 : user1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET http://localhost/user
Content-Type: text/html

응답 : &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;사용자1&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET http://localhost/user
Content-Type: application/json
응답 : {'name' : 'user1'}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;31-representation-metadata&quot;&gt;3.1. Representation Metadata&lt;/h2&gt;

&lt;p&gt;Representation 헤더 필드는 Representation에 대한 메타 데이터를 제공한다. 메시지에 페이로드 본문이 포함된 경우 Representation header 필드에는 본문에 포함된 Representation 데이터를 해석하는 방법을 나타낸다.&lt;/p&gt;

&lt;h3 id=&quot;311-processing-representation-data&quot;&gt;3.1.1. Processing Representation Data&lt;/h3&gt;

&lt;h4 id=&quot;3111-media-type&quot;&gt;3.1.1.1. Media Type&lt;/h4&gt;

&lt;p&gt;HTTP는 유연한 데이터 입력과 반환을 위해 Content-Type과 Accept헤더 필드를 사용한다. 미디어 타입은 데이터 형식과 다양한 처리 모델을 정의 할 수 있다. 결론적으로 미디어 타입은 데이터가 어떤 모양으로 수신 됐으며 어떤 모양으로 반환을 해야한다는 정보를 명시해주는 것이다.&lt;/p&gt;

&lt;p&gt;media-type = type / subtype 형태를 이룬다. 다들 알다 시피 text/html이나 application/json등 이러한 형태이다. type과 subtype는 대소문자를 구분하지 않는다. 이후 type / subtype; parameter=token과 같은 형태가 있으며 이때 parameter의 값인 token은 parameter에 따라 대소문자를 구분하거나 구분하지 않을 수 있다. 또한 = 앞과 뒤에는 공백을 허용하지 않는다. 예를 들면 text/html;charset=utf8과 같은 형태이다. 뒤에 붙는 매개 변수의 존재나 부재는 미디어 타입 레지스트리 내의 정의에 따라 미디어 타입 처리에 중요할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;3112-charset&quot;&gt;3.1.1.2. Charset&lt;/h4&gt;

&lt;p&gt;Charset는 HTTP의 문자 인코딩 방식을 표현할때 사용한다. Charset는 대소문자를 구분하지 않는다.&lt;/p&gt;

&lt;h4 id=&quot;3113-canonicalization-and-text-defaults-정규화-및-텍스트-기본-값&quot;&gt;3.1.1.3. Canonicalization and Text Defaults (정규화 및 텍스트 기본 값)&lt;/h4&gt;

&lt;p&gt;text 타입의 미디어 하위 타입이 텍스트 줄바꿈을 할땐 CRLF를 사용하여야 한다. HTTP는 이러한 줄 바꿈이 전체 표현에 일관 될 때, 줄 바꿈을 나태는것을 CR 또는 LF만으로 텍스트를 전송할 수 있다. 줄바꿈과 관련됨 내용은 ‘text’ 미디어 타입이 할당 된 Representation 내 텍스트에만 적용 된다.&lt;/p&gt;

&lt;h4 id=&quot;3114-multipart-types--참고-내용--httpsqssdevtistorycom47&quot;&gt;3.1.1.4. Multipart Types ( 참고 내용 : &lt;a href=&quot;https://qssdev.tistory.com/47&quot;&gt;https://qssdev.tistory.com/47&lt;/a&gt;)&lt;/h4&gt;

&lt;p&gt;단일 메시지 본문 내에서 하나 이상의 표현을 캡슐화한 여려 “multipart” 타입을 제공한다. 대부분 데이터 전송 ‘multipart/form-data’ 타입을 사용하는 경우가 많다. 멀티파트 타입은 미디어 타입 값의 일부로 경계 매개변수를 포함한다. 경계 매개 변수를 예를 들어 보면  아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost/images&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;enctype = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;multipart/form-data&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;method = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;imageName&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;br&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;file&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;br&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name = &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;upload&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;br&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 처럼 폼을 만들어주고 Request 구문을 생성한것이 아래와 같다. 바운더리 변수가 만들어지고 form data의 타입마다 경계를 주어 구문을 분석한다. 메시지 본문은 그 자체로 프로토콜 요소이며 발신자는 본문 부분 사이의 줄 바꿈을 나타내기위해 CRLF만 생성해야한다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /images HTTP/1.1
Host: localhost
Content-Length: 228
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;imageName&quot;

image
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;file&quot;

123412341234
----WebKitFormBoundary7MA4YWxkTrZu0gW
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3115-content-type&quot;&gt;3.1.1.5. Content-Type&lt;/h4&gt;

&lt;p&gt;Content-Type 헤더 필드는 메시지에 포함된 페이로드(메시지 본문(body)이라고 생각)의 미디어 타입을 나타낸다. 미디어 타입은 representations을 디코딩과 인코딩 하는 정보를 제공한다. representation을 발신자가 알 수 없는 경우가 아니라면 Content-Type 헤더 필드를 생성해야 한다. 만약 없는 경우 수신자는  application/optet- stream라는 미디어 타입을 가정하거나 데이터를 검토하여 타입을 결정할 수 있다. 리소스 소유자가 올바른 Content-Type을 제공하도록 구성하지 않으면 클라이언트가 메시지의 본문을 콘텐츠 검사하고 지정된 타입을 재정의 한다. 잘못된 타입으로 정의할 수 있으며 보안 위험(예를 들면 privilege escalation,(&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B6%8C%ED%95%9C_%ED%99%95%EB%8C%80&quot;&gt;https://ko.wikipedia.org/wiki/권한_확대&lt;/a&gt;) 권한 확대라는 보안 위험인데… 잘 모르겠다.)이 생길 수 있다. 구현자는 content sniffing을 방지할 수 있는 수단을 제공해야한다. (&lt;a href=&quot;https://en.wikipedia.org/wiki/Content_sniffing&quot;&gt;https://en.wikipedia.org/wiki/Content_sniffing&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;312-encoding-for-compression-or-integrity-압축-또는-무결성을-위한-인코딩&quot;&gt;3.1.2. Encoding for Compression or Integrity (압축 또는 무결성을 위한 인코딩)&lt;/h3&gt;

&lt;h4 id=&quot;3121-content-codings&quot;&gt;3.1.2.1. Content Codings&lt;/h4&gt;
&lt;p&gt;Content Coding은 주로 representations을 압축하거나 다른 용도로 사용할 수 있도록 하기 위해 사용되며 기본적인 미디어 타입의 정체성을 상실하지 않고 정보의 손실 없이 사용된다. representations은 코드화된 형태로 저장되고, 직접 전송되며, 최종 수신자에 의해서만 해독 된다. 모든 컨텐츠 코딩 값은 대소문자를 구분하지 않으며 HTTP Content Coding Registry에 등록해야한다. Accept-Encoding 및 Content-Encoding 헤더 필드에 사용된다. 정의되는 콘텐츠 코딩 값은 Compress Coding, Deflate Coding, Gzip Coding가 있다.&lt;/p&gt;

&lt;h4 id=&quot;3122-content-encoding&quot;&gt;3.1.2.2. Content-Encoding&lt;/h4&gt;
&lt;p&gt;Content Encoding 헤더 필드는 미디어 타입의 정체성을 잃지 않고 압축될 수 있도록 하기 위해 사용한다. 하나 이상의 인코딩이 representations에 적용된 경우, 인코딩을 적용한 발신자는 해당 인코딩이 적용된 순서대로 Content-Encoding 헤더 필드를 생성해야한다. Content-Encoding 헤더는 Content-Type 헤더에 의해 참조되는 미디어 타입을 얻도록 디코드하는 방법을 클라이언트에게 알려준다. 서버에서는 요청 메시지의 표현에 허용되지 않는 콘텐츠 코딩이 있는 경우 415(Unsupported Media Type)상태 코드를 반환 한다.&lt;/p&gt;

&lt;h3 id=&quot;313-audience-language&quot;&gt;3.1.3. Audience Language&lt;/h3&gt;
&lt;h4 id=&quot;3131-language-tags&quot;&gt;3.1.3.1. Language Tags&lt;/h4&gt;
&lt;p&gt;Language Tags는 다른 사람에게 정보 전달을 위해 사용된 자연 언어를 식별한다. 컴퓨터 언어는 제외된다.&lt;/p&gt;

&lt;p&gt;HTTP는 Accept-Language 및 Content-Language 헤더 필드 내에서 언어 태그를 사용한다. Accept-Language는 Language-range 문법을 사용하고, Content-Language에서는 Language-tag 문법을 사용한다.&lt;/p&gt;

&lt;p&gt;Language Tag는 대소문자를 구분하지 않으며, 다중 Language Tag는 쉼표로 구분한다. 그리고 각 Language-tag는 -문자로 구분되는 한개 이상의 서브태그의 연속이다. Language-tag 내에서 공백은 허용되지 않는다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Language: ko        // 단일 Language Tag
Content-Language: en-US     // -로 구분되는 서브태그의 연속
Content-Language: en-US, ko // 다중 Language Tag
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;3132-content-language&quot;&gt;3.1.3.2. Content-Language&lt;/h4&gt;
&lt;p&gt;Content-Language 헤더 필드는 Represtation이 어떤 언어로 나타내는지 설명한다. Content-Language가 지정되지 않은 경우에는 Represtation이 모든 언어의 대상이라는것을 나타내기도 하지만 어떤 언어를 의도하는지를 모른다는 의미도 가질 수 있다. 그리고 모든 내용이 Language-tag의 대상 언어로만 작성되어 있지 않다는것을 알아야 한다.
그렇기 때문에 Represtation내에 다국어가 존재한다고 해서 다국어 사용자들을 위한것이 아니다. 우리는 아래의 예제 Represtation을 한국인 대상으로 제공하는것으로 가정하자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;안녕하세요 (Hello)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 Represtation이 있을때 한국어와 영어가 함께 있다고 해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Language : en, ko&lt;/code&gt;라고 작성하는 것이 아니다. 
우리는 한국인을 대상으로 제공하는 Represtation이므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Language : ko&lt;/code&gt;라고 작성하는것이 옳은 방법이다.&lt;/p&gt;

&lt;p&gt;Content-Language는 모든 Media Type에 적용될 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;314-identification&quot;&gt;3.1.4. Identification&lt;/h3&gt;
&lt;h4 id=&quot;3141-identifying-a-representation&quot;&gt;3.1.4.1 Identifying a Representation&lt;/h4&gt;
&lt;p&gt;완전한 또는 부분적인 Represtation을 메시지 페이로드(요청이나 응답의 바디)로 전송할 때, 발신자는 그 표현에 해당하는 리소스의 식별자를 제공하거나 또는 수신자가 결정하는것이 바람직하다.&lt;/p&gt;

&lt;h5 id=&quot;request-message&quot;&gt;Request Message&lt;/h5&gt;
&lt;p&gt;요청에 Content-Location 헤더 필드가 있는 경우, Content-Location 헤더의 값에 의해 식별된 리소스라고 주장된다. 이러한 주장은 다른 방법으로 검증될 수 있는 경우가 아니면 신뢰할 수 없다. (당연히 요청하는 쪽에서 리소스가 식별되어있다고 주장하니깐 검증되지 않은 경우라면 신뢰할 수 없음) 이 정보는 수정된 내역 링크(리소스가 수정 되기 이전의 내용을 가진 link라고 생각하는데… 현재 내가 요청하는 URI가 이전에는 이러한 Link를 가졌었다고 보내면서 해당 리소스가 식별이 됐었다라는것을 표현하고 싶은건가??)를 나타낼때는 유용할 수 있다.&lt;/p&gt;

&lt;p&gt;이외에는 Content-Location 헤더가 없다면 페이로드는 식별되지 않는다.&lt;/p&gt;

&lt;h5 id=&quot;response-message&quot;&gt;Response Message&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;요청 메소드가 GET 또는 HEAD이고 응답 상태가 200(OK), 204(No Content), 206(Partial Content), 304(Not Modified)인 경우는 요청 URI는 식별된 유효한 리소스임을 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;요청 메소드가 GET 또는 HEAD이고 응답 상태 코드가 203(Non-Authoriative Information)인 경우 서버와 클라이언트 사이에 있는 HTTP 프록시가 클라이언트에 도달하기 전에 응답을 변경하거나 추가 했다는것을 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Response에서 Content-Location 헤더 필드가 있고 헤더 값이 유효한 요청 URI와 동일한 URI인 경우 페이로드는 유효한 요청 URI에 의해 식별된 리소스이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Response에서 Content-Location 헤더 필드가 있고 헤더 값이 유효한 요청 URI와 다른 URI인 경우 발신자는 페이로드가 Content-Location 값으로 식별된 리소스의 표현이라고 단언한다. 이러한 주장은 다른 방법으로 검증될 수 있는 경우가 아니면 신뢰할 수 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이외는 페이로드가 식별되지 않는다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;3142-content-location&quot;&gt;3.1.4.2. Content-Location&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Location&lt;/code&gt; 헤더 필드는 메시지의 페이로드에 해당하는 특정 리소스의 식별자로 사용할 수 있는 URI를 참조한다. 메시지가 생성될때 이 URI에 대해 GET 요청을 수행한다면 200(OK) 응답은 메세지의 페이로드에 포함된 representation을 담고 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Content-Location = absolute-URI / partial-URI
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Content-Location 값은 유효한 Request URI의 대체 값이 아니라 메타데이터를 표현한다.
Content-Location이 2xx(Successful) 응답 메시지에 포함되고 그 값이 유효한 요청 URI와 동일한 URI를 가리킨다면 수신자는 페이로드를 메시지 작성 날짜로 표시된 시점의 해당 리소스의 현재 representation으로 간주할 수 있다.&lt;br /&gt;
(그냥 요청했을때의 representation으로 생각하면 됨).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GET 또는 HEAD 요청의 경우, 이것은 서버가 Content-Location을 제공하지 않을 때의 기본 의미와 동일하다(제공하지 않다고 하더라도 URI를 GET 요청 후 2xx의 상태를 반환 한다는것은 리소스가 식별되었다는 뜻이니까?).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PUT 또는 POST와 같은 상태 변화 요청의 경우, 서버의 응답에 해당 리소스의 새로운 representation이 포함됨을 의미하며, 따라서 Content-Location을 제공하지 않고 해당 동작이 수행됐다 라는 representation (body와 상태코드로만 200, “It worked!”라고 응답한것)과는 구별이 된다.&lt;/p&gt;

    &lt;p&gt;이를 통해 어플리케이션은 후속 GET 요청 없이 로컬에 저장된 내용으로 업데이트할 수 있다.
예를 들어 내가 아래와 같은 form으로 송금하도록 한다.&lt;/p&gt;
    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/send-payment&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;label&amp;gt;&lt;/span&gt;Who do you want to send the money to?
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;recipient&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/label&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;label&amp;gt;&lt;/span&gt;How much?
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;number&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;amount&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/label&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Send Money&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;양식이 제출되면 사이트에서는 거래 영수증을 생성 후 서버는 향후 영수증 접근을 위해 Content-Location에 영수증 URL을 표시할 수 있다.&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Content-Location: /my-receipts/38

&amp;lt;!doctype html&amp;gt;
(Lots of HTML…)

&amp;lt;p&amp;gt;You sent $38.00 to ExampleUser.&amp;lt;/p&amp;gt;

(Lots more HTML…)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;외외 메서드에서 Content-Location은 페이로드가 요청된 행동의 상태에 대한 표현을 보고하는 것을 나타내며, 주어진 URI에서 동일한 보고를 사용할 수 있음을 나타낸다 (GET을 사용한 향후 접근)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;요청 메시지로 Content-Location을 전송하는 사용자는 헤더에 보낼 값인 URI는 사용자가 이전에 Representation의 내용을 획득한 곳을 의미한다. 즉 사용자는 원래 Representation의 리소스에 대한 이전 링크를 제공하는 것이다.&lt;/p&gt;

&lt;p&gt;요청 메시지에서 Content-Location 필드를 수신하는 서버는 정보를 Representation의 일부로 저장하기 위한 메타 데이터가 아닌 임시 요청 컨텍스트로 취급해야한다. 서버는 요청 처리를 안내하거나 소스 링크 또는 버전 메타데이터 내의 다른 용도로 저장하기 위해 이 컨텍스트를 사용할 수 있다. 단 서버는 요청 의미를 변경하기 위해 이러한 컨텍스트 정보를 사용해서는 안된다.
예를 들어 클라이언트가 협상된 리소스에 대해 PUT (리디렉션 x) 요청을 하고 서버가 PUT 요청을 수락하는 경우, 해당 리소스의 새로운 상태는 해당 PUT에 제공된 하나의 Representation과 일치할 것으로 예상된다. Content-Location은 협상된 표현 중 하나만 업데이트할 수 있는 역방향 컨텐츠 선택 식별자의 형태로 사용될 수 없다.
사용자가 후자의 의미를 원했다면 PUT을 Content-Location URI에 직접 적용했을것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;솔직히 Content-Location 헤더의 역할과 의미가 잘 이해가 되지 않는다. 사용되는 예제도 잘 보이지 않을 뿐더러… 일단은 넘기는 걸로 (2021-02-06)
다시 생각해보니 PUT /URL 요청시 Content-Location은 변경되는 리소스를 가르키는 /URL이 되어야한다는 의미인거같다. 만약 PUT /URL 요청시 Content-Location을 /URLe 라는 하나의 표현에 대한 업데이트를 한다는것은 말이 안되기 때문이다. Representation이라는 것은 리소스를 여러 모습으로 표현한것이지 변경되는것은 해당하는 표현이 아니라 리소스이기 때문이다. (라고 이해 했지만 아직 잘 …)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;32-representation-data&quot;&gt;3.2. Representation Data&lt;/h2&gt;
&lt;p&gt;HTTP 메시지와 관련된 표현 데이터는 메시지의 페이로드 본문으로 제공되거나 메시지 의미 및 유효한 요청 URI에 의해 참조 된다. representation data는 representation metadata 헤더 필드에서 정의한 형식과 인코딩이다.&lt;/p&gt;

&lt;p&gt;representation data의 데이터 타입은 헤더필드 Content-Type 및 Content-Encoding을 통해 결정 된다. 순서가 지정된 2계층 인코딩 모델을 정의한다.&lt;/p&gt;

&lt;p&gt;representation-data := Content-Encoding( Content-Type( bits ) )
컨텐츠 타입으로 지정된 데이터를 인코딩한것이 Representation Data가 되는것이다.&lt;/p&gt;

&lt;h2 id=&quot;33-payload-semantics&quot;&gt;3.3. Payload Semantics&lt;/h2&gt;
&lt;p&gt;일부 HTTP 메시지는 payload 메시지로 전체 또는 부분 representation을 전송한다. 경우에 따라 페이로드에 관련 표현의 헤더필드(HEAD 메서드의 응답) 또는 representation data의 일부(206 (partial Content) 상태코드)만 포함될 수 있다.&lt;/p&gt;

&lt;p&gt;요청에서 페이로드의 목적은 메서드 의미론에 의해 정의된다. 예를 들어 PUT 요청의 페이로드에 있는 representation은 요청이 성공적으로 적용될 경우 대상 리소스의 원하는 상태를 나타낸다.
(예를 들어 서버에 저장된 1번 user의 name이 user1이고 우리는 그 유저의 이름을 user2로 변경하고 싶다. 이때 put 요청을 아래처럼 나타 낼 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT http://localhost/users/1 
body : { 'name' : 'user2' }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;성공적으로 응답 결과가 왔을 경우에는 1번 유저의 이름이 user2로 바뀌게 됨으로 요청에서 페이로드에 있는 representation은 리소스의 원하는 상태를 나타낸것임을 알수 있다.)&lt;/p&gt;

&lt;p&gt;POST 요청의 페이로드에 있는 representation은 대상 리소스가 처리할 정보를 나타낸다.
(예를 들어 서버에 새로운 user를 만드는 요청을 보내 보자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST http://localhost/users 
body : { 'name' : 'newUser' }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;성공적으로 응답 결과가 왔을 경우 유저가 생성이 되었다는 의미이므로 요청에서 페이로드에 있는 representation은 리소스가 처리할 정보를 나타낸것임을 알 수 있다.)&lt;/p&gt;

&lt;p&gt;이에 대해 페이로드의 목적은 요청 메소드와 응답 상태 코드에 의해 모두 정의된다. GET에 대한 200(OK) 응답의 페이로드는 메시지 시작일에 리소스의 현재 상태는 나타낸다. POST에 대한 응답에서 200(OK) 응답의 페이로드는 처리 결과 또는 처리 적용 후 대상 리소스의 새 상태를 나타낼 수 있다. 오류 상태로 반환되는 경우 응답 메시지에 오류 상태와 오류 해결을 위한 제안되는 다음 단계를 설명하는 것과 같은 오류 조건을 나타내는 페이로드가 포함되어 있다.&lt;/p&gt;

&lt;p&gt;연관된 representation보다 페이로드를 구체적으로 기술하는 헤더 필드를 payload header fields라고 한다. 페이로드 헤더 필드는 메시지 구문 분석에 대한 영향 때문에 이 명세의 다른 부분에 정의되어 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Header Field Name&lt;/li&gt;
  &lt;li&gt;Content-Length&lt;/li&gt;
  &lt;li&gt;Content-Range&lt;/li&gt;
  &lt;li&gt;Trailer&lt;/li&gt;
  &lt;li&gt;Transfer-Encoding&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;34-content-negotiation&quot;&gt;3.4. Content Negotiation&lt;/h2&gt;
&lt;p&gt;응답이 성공이던 오류이던 페이로드 정보를 전달할 때, 서버는 다른 형식, 언어, 인코딩과 같은 정보를 표시하는 방법이 있다. 여러 사용자마다 어떤 representation을 가장 잘 전달하는지에 영향을 미칠 수 있는 능력, 특성, 선호도가 다를 수 있다. 이러한 이유로 HTTP는 콘텐츠 협상의 메커니즘을 제공한다.&lt;/p&gt;

&lt;p&gt;이 명세는 프로토콜 내에서 가시화할 수 있는 콘텐츠 협상의 2가지 패턴을 정의한다.
서버가 사용자의 명시적 선호도에 따라 표현을 선택하는 proactive (사전)협상과, 서버가 사용자 에이전트가 선택할 수 있는 표현 목록을 제공하는 reactive(대응)협상이 있다. 그외 콘텐츠 협상 패턴으로는 사용자 매개변수에 따라 선택적으로 렌더링 되는 여러 부분으로 구성된 contitional contet, 사용자 특성에 따라 추가(더 구체적인) 요청을 하는 스크립트가 포함된 active content, Transparent Content Negotiation등이 있다. 여기서 콘텐츠 선택은 중개자가 수행한다. 이러한 패턴은 상호 배타적이지 않으며, 적용성과 실용성에서 각각 절충점을 가진다.&lt;/p&gt;

&lt;p&gt;모든 경우에서 HTTP는 리소스 의미론을 인식하지 못한다. 시간이 지남에 따라, 그리고 시간에 따라, 그리고 콘텐츠 협상의 다양한 차원에 걸쳐, 그리고 시간에 따른 리소스의 관찰된 표현의 sameness에 대해 서버가 요청하는 응답하는 일관성은 전적으로 어떤 항목이나 알고리즘이 그러한 응답을 선택하거나 생성하는가에 의해 결정된다 HTTP는 커튼 위에 있는 사람에게 관심을 두지 않는다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;그냥 우리가 요청하는 헤더와 메서드와 리소스의 의미를 HTTP는 모른다는 말로, 개발자는 요청하는 의미대로 동작하게 만들어야한다는 뜻&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;두 콘텐츠 협상과 관련된 내용은 MDN에서 설명된 내용을 가져왔다. 가장 깔끔하게 쓰여졌다고 생각한다.&lt;/p&gt;
&lt;h3 id=&quot;341-proactive-negotiation-mdn-내용-참고&quot;&gt;3.4.1. Proactive Negotiation (MDN 내용 참고)&lt;/h3&gt;
&lt;p&gt;서버 주도 컨텐츠 협상 혹은 주도적인 협상에 있어서, 브라우저(혹은 사용자 에이전트라면 어떤 다른 종류든지)는 URL을 이용해 몇 개의 HTTP 헤더를 전송합니다. 이런 헤더들은 사용자의 우선적인 선택을 나타냅니다. 서버는 그것들을 힌트로써 사용하며 내부 알고리즘은 클라이언트로 서브하기 위한 최선의 컨텐츠를 선택하게 됩니다. 이 알고리즘은 서버 특유의 것이며 표준으로 정의된 것은 아닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/http1-1SemanticsAndContent/ProactiveNegotiation.png&quot; alt=&quot;ProactiveNegotiation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTP/1.1 표준은 서버 주도 협상을 시작하는 표준 헤더 목록(Accept, Accept-Charset, Accept-Encoding, Accept-Language)을 정의하고 있습니다. 엄밀히 말하자면 User-Agent이 리스트 내에 없긴 하지만, 해당 헤더는, 좋은 관례가 아니라고 판단될지라도, 때때로 요청된 리소스의 특정 프레젠테이션을 전송하는데 사용되기도 합니다. 서버는 실제로 컨텐츠 협상에 있어 어떤 헤더가 사용될 지 (더 엄밀히 말하자면 연관된 응답 헤더) 가리키기 위해 Vary 헤더를 사용하므로 캐시는 최적으로 동작하게 됩니다.&lt;/p&gt;

&lt;p&gt;이것과 더불어, 클라이언트 힌트라고 부르는 헤더들을 이용 가능한 헤더 목록에 추가하려는 실험적인 제안도 존재합니다. 클라이언트 힌트는 사용자 에이전트가 실행 중인 기기의 종류가 무엇인지를 알려줍니다(예를 들어, 데스크톱 컴퓨터인지 모바일 기기인지)&lt;/p&gt;

&lt;p&gt;서버 주도 컨텐츠 협상이 리소스의 특정 프레젠테이션에 동의하기 위한 가장 일반적인 방법이긴 하지만, 몇 가지 결점을 가지고 있습니다:&lt;/p&gt;

&lt;p&gt;서버는 브라우저에 대한 전체적인 지식을 가지고 있지 않습니다. 클라이언트 힌트 확장이 있더라도, 서버는 브라우저의 수용 능력에 대한 완벽한 정보를 가지고 있진 않습니다. 클라이언트가 선택하는 리액티브 컨텐츠 협상과는 다르게, 서버 선택은 항상 다소 임의적입니다.
클라이언트에 의한 정보는 상당히 장황하며(HTTP/2 헤더 압축은 이런 문제를 완화시킵니다) 사생활 침해에 대한 위협을 가지고 있습니다(HTTP 핑거프린팅).
주어진 리소스의 몇몇 프레젠테이션이 전송되므로, 샤드된 캐시들은 덜 효율적이며 서버 구현은 좀 더 복잡해집니다.&lt;/p&gt;

&lt;h3 id=&quot;342-reactive-negotiation-mdn-내용-참고&quot;&gt;3.4.2. Reactive Negotiation (MDN 내용 참고)&lt;/h3&gt;
&lt;p&gt;서버 주도 협상은 몇 가지 불리한 점 때문에 고통을 줍니다: 그것은 확장하기가 용이하지 않습니다. 협상 내에서 사용하는 기능 당 한 가지 헤더가 존재해야 합니다. 만약 스크린 크기, 해상도 혹은 또 다른 치수를 사용하고자 한다면, 새로운 HTTP 헤더가 반드시 만들어져야 합니다. 헤더의 전송은 반드시 모든 요청 상에서 이루어져야 합니다. 이것은 몇몇 헤더들에 있어서는 그리 문제될 것은 아니지만, 그런 헤더들이 결국 증가하여, 메시지 사이즈가 성능에 악영향이 끼치는 상황이 올 수도 있습니다. 정확한 헤더가 전송되면 전송될수록, 불확실성도 더욱 더 전송되어, 좀 더 많은 HTTP 흔적과 그와 관련된 개인정보들이 남게 됩니다.&lt;/p&gt;

&lt;p&gt;HTTP의 초창기부터, 프로토콜은 또 다른 협상 유형을 허용했습니다: 에이전트 주도 협상 혹은 리액티브 협상. 이 협상에서, 애매모호한 요청과 맞닥뜨렸을 경우, 서버는 사용 가능한 대체 리소스들에 대한 링크를 포함하고 있는 페이지를 회신하게 됩니다. 사용자는 해당 리소스들을 표시하고 사용하려는 리소스를 선택하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/http1-1SemanticsAndContent/ReactiveNegotiation.png&quot; alt=&quot;Reactive Negotiation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;불행하게도, HTTP 표준은 그 과정을 쉽게 자동화하는 것을 지원하지 않고, 사용 가능한 리소스 중에서 선택하도록 허용하는 페이지의 형식을 명시하지 않고 있습니다. 게다가 서버 주도 협상으로의 회귀로, 이 방법은 스크립팅, 특히 자바스크립트 리다이렉션과 함께 거의 항상 사용됩니다: 협상 기준을 점검하고 난 뒤에, 스크립트는 리다이렉션을 실행합니다. 두번째 문제는 실제 리소스를 가져오는데 한 개 이상의 요청이 필요로 해서, 사용자에 대한 리소스 효용성이 떨어진다는 것입니다.&lt;/p&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="http" /><category term="Web" /><category term="HTTP1.1" /><summary type="html">참고 자료 이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본 https://roka88.dev/106 MDN Web Docs https://developer.mozilla.org/ko/docs/Web/HTTP 이외 자료는 내용 중 링크 추가 틀린 내용, 부족한 내용 꼭 지적 부탁드립니다! HTTP 1.1 Reference - Semantics and Content 1. 간단한 설명 HTTP 메시지는 요청 또는 응답을 나타낸다. 서버는 클라이언트에게 요청을 받고 수신된 메시지를 해석 후 허락된 클라이언트에게 하나 이상의 응답 메시지를 반환한다. (서버가 먼저 클라이언트에게 요청할 수 는 없다. 웹소켓 제외) 클라이언트는 특정한 의도를 나타내는 요청 메시지를 서버에게 보낸후 수신된 응답을 확인하여 (상태 코드 확인) 의도대로 수행되었는지 확인 후 응답 메세지를 결과를 확인한다(Response Body의 내용을 확인). 2. Resources HTTP의 요청 대상을 resource라고 부른다. HTTP는 리소스와 상호 작용을 할 수 있는 인터페이스(아마 HTTP가 요청과 응답하는 구조의 내용일듯)를 정의하고 리소스는 URI로 식별된다. HTTP의 설계 목표 중 하나는 요청의 의미론에서 리소스 식별을 분리 하는것이다. 예를 들어 URI는 리소스를 처리할 행위 모두를 나타내는것이 아니라 URI는 리소스를 식별하는 역할만 하는것이고 메소드나 다른 헤더를 통해 어떠한 역할을 수행해야하는지를 식별하도록 하는것이다. 그렇기 때문에 URI는 겹칠 수 있지만 메소드가 다를 경우 다른 동작을 하게 되는 것이다. POST http://localhost/get_user 위에 내용을 보충 해보면 조금 극단적인 예라 생각 하지만 위 요청처럼 URI에 리소스에 대한 행위를 담는것이 아니라 아래처럼 메소드나 부가적인 헤더를 이용하여 행위를 나타내는것이 HTTP 설계 목표이다. (라고 이해했다 나는…) GET http://localhost/user POST http://localhost/user 3. Representations 참고자료 (https://blog.npcode.com/2017/04/03/rest의-representation이란-무엇인가/) 리소스는 무엇이든 될 수 있으며 해당 행위들은 여러가지가 될 수 있다. 이러한 점에서 우리는 서버에 원하는 요청(상태)를 나타내기위한 추상화가 필요한데 그 추상화를 우리는 REST라고 부른다. HTTP의 목적 상 Representations는 주어진 리소스의 상태(과거, 현재, 또는 원하는 상태)를 프로토콜을 통해 쉽게 전달할 수 있는 형식으로 반영하기 위한 정보이다. 표현 데이터는 데이터 스트림으로 구성된다. Representations의 예를 들어보면 아래의 요청에 대해 아래와 같은 응답들을 볼 수 있다. 이러한 응답들을 representation이라고 한다. 첫번째는 사용자1이라는 리소스를 한글 사용자들을 위한 상태로 반환 한것이다. 두번째는 영문 사용자, 세번째는 html로, 네번째는 json의 형태로 반환 한것이다. GET http://localhost/user Content-Type: text/plain Content-Language: ko 응답 : 사용자1 GET http://localhost/user Content-Type: text/plain Content-Language: en 응답 : user1 GET http://localhost/user Content-Type: text/html 응답 : &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;사용자1&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; GET http://localhost/user Content-Type: application/json 응답 : {'name' : 'user1'} 3.1. Representation Metadata Representation 헤더 필드는 Representation에 대한 메타 데이터를 제공한다. 메시지에 페이로드 본문이 포함된 경우 Representation header 필드에는 본문에 포함된 Representation 데이터를 해석하는 방법을 나타낸다. 3.1.1. Processing Representation Data 3.1.1.1. Media Type HTTP는 유연한 데이터 입력과 반환을 위해 Content-Type과 Accept헤더 필드를 사용한다. 미디어 타입은 데이터 형식과 다양한 처리 모델을 정의 할 수 있다. 결론적으로 미디어 타입은 데이터가 어떤 모양으로 수신 됐으며 어떤 모양으로 반환을 해야한다는 정보를 명시해주는 것이다. media-type = type / subtype 형태를 이룬다. 다들 알다 시피 text/html이나 application/json등 이러한 형태이다. type과 subtype는 대소문자를 구분하지 않는다. 이후 type / subtype; parameter=token과 같은 형태가 있으며 이때 parameter의 값인 token은 parameter에 따라 대소문자를 구분하거나 구분하지 않을 수 있다. 또한 = 앞과 뒤에는 공백을 허용하지 않는다. 예를 들면 text/html;charset=utf8과 같은 형태이다. 뒤에 붙는 매개 변수의 존재나 부재는 미디어 타입 레지스트리 내의 정의에 따라 미디어 타입 처리에 중요할 수 있다. 3.1.1.2. Charset Charset는 HTTP의 문자 인코딩 방식을 표현할때 사용한다. Charset는 대소문자를 구분하지 않는다. 3.1.1.3. Canonicalization and Text Defaults (정규화 및 텍스트 기본 값) text 타입의 미디어 하위 타입이 텍스트 줄바꿈을 할땐 CRLF를 사용하여야 한다. HTTP는 이러한 줄 바꿈이 전체 표현에 일관 될 때, 줄 바꿈을 나태는것을 CR 또는 LF만으로 텍스트를 전송할 수 있다. 줄바꿈과 관련됨 내용은 ‘text’ 미디어 타입이 할당 된 Representation 내 텍스트에만 적용 된다. 3.1.1.4. Multipart Types ( 참고 내용 : https://qssdev.tistory.com/47) 단일 메시지 본문 내에서 하나 이상의 표현을 캡슐화한 여려 “multipart” 타입을 제공한다. 대부분 데이터 전송 ‘multipart/form-data’ 타입을 사용하는 경우가 많다. 멀티파트 타입은 미디어 타입 값의 일부로 경계 매개변수를 포함한다. 경계 매개 변수를 예를 들어 보면 아래와 같다. &amp;lt;form action = &quot;http://localhost/images&quot; enctype = &quot;multipart/form-data&quot; method = &quot;post&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; name = &quot;imageName&quot;&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&quot;file&quot; name = &quot;image&quot;&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&quot;submit&quot; name = &quot;upload&quot;&amp;gt;&amp;lt;br&amp;gt; &amp;lt;/form&amp;gt; 위 처럼 폼을 만들어주고 Request 구문을 생성한것이 아래와 같다. 바운더리 변수가 만들어지고 form data의 타입마다 경계를 주어 구문을 분석한다. 메시지 본문은 그 자체로 프로토콜 요소이며 발신자는 본문 부분 사이의 줄 바꿈을 나타내기위해 CRLF만 생성해야한다. POST /images HTTP/1.1 Host: localhost Content-Length: 228 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW ----WebKitFormBoundary7MA4YWxkTrZu0gW Content-Disposition: form-data; name=&quot;imageName&quot; image ----WebKitFormBoundary7MA4YWxkTrZu0gW Content-Disposition: form-data; name=&quot;file&quot; 123412341234 ----WebKitFormBoundary7MA4YWxkTrZu0gW 3.1.1.5. Content-Type Content-Type 헤더 필드는 메시지에 포함된 페이로드(메시지 본문(body)이라고 생각)의 미디어 타입을 나타낸다. 미디어 타입은 representations을 디코딩과 인코딩 하는 정보를 제공한다. representation을 발신자가 알 수 없는 경우가 아니라면 Content-Type 헤더 필드를 생성해야 한다. 만약 없는 경우 수신자는 application/optet- stream라는 미디어 타입을 가정하거나 데이터를 검토하여 타입을 결정할 수 있다. 리소스 소유자가 올바른 Content-Type을 제공하도록 구성하지 않으면 클라이언트가 메시지의 본문을 콘텐츠 검사하고 지정된 타입을 재정의 한다. 잘못된 타입으로 정의할 수 있으며 보안 위험(예를 들면 privilege escalation,(https://ko.wikipedia.org/wiki/권한_확대) 권한 확대라는 보안 위험인데… 잘 모르겠다.)이 생길 수 있다. 구현자는 content sniffing을 방지할 수 있는 수단을 제공해야한다. (https://en.wikipedia.org/wiki/Content_sniffing) 3.1.2. Encoding for Compression or Integrity (압축 또는 무결성을 위한 인코딩) 3.1.2.1. Content Codings Content Coding은 주로 representations을 압축하거나 다른 용도로 사용할 수 있도록 하기 위해 사용되며 기본적인 미디어 타입의 정체성을 상실하지 않고 정보의 손실 없이 사용된다. representations은 코드화된 형태로 저장되고, 직접 전송되며, 최종 수신자에 의해서만 해독 된다. 모든 컨텐츠 코딩 값은 대소문자를 구분하지 않으며 HTTP Content Coding Registry에 등록해야한다. Accept-Encoding 및 Content-Encoding 헤더 필드에 사용된다. 정의되는 콘텐츠 코딩 값은 Compress Coding, Deflate Coding, Gzip Coding가 있다. 3.1.2.2. Content-Encoding Content Encoding 헤더 필드는 미디어 타입의 정체성을 잃지 않고 압축될 수 있도록 하기 위해 사용한다. 하나 이상의 인코딩이 representations에 적용된 경우, 인코딩을 적용한 발신자는 해당 인코딩이 적용된 순서대로 Content-Encoding 헤더 필드를 생성해야한다. Content-Encoding 헤더는 Content-Type 헤더에 의해 참조되는 미디어 타입을 얻도록 디코드하는 방법을 클라이언트에게 알려준다. 서버에서는 요청 메시지의 표현에 허용되지 않는 콘텐츠 코딩이 있는 경우 415(Unsupported Media Type)상태 코드를 반환 한다. 3.1.3. Audience Language 3.1.3.1. Language Tags Language Tags는 다른 사람에게 정보 전달을 위해 사용된 자연 언어를 식별한다. 컴퓨터 언어는 제외된다. HTTP는 Accept-Language 및 Content-Language 헤더 필드 내에서 언어 태그를 사용한다. Accept-Language는 Language-range 문법을 사용하고, Content-Language에서는 Language-tag 문법을 사용한다. Language Tag는 대소문자를 구분하지 않으며, 다중 Language Tag는 쉼표로 구분한다. 그리고 각 Language-tag는 -문자로 구분되는 한개 이상의 서브태그의 연속이다. Language-tag 내에서 공백은 허용되지 않는다. Content-Language: ko // 단일 Language Tag Content-Language: en-US // -로 구분되는 서브태그의 연속 Content-Language: en-US, ko // 다중 Language Tag 3.1.3.2. Content-Language Content-Language 헤더 필드는 Represtation이 어떤 언어로 나타내는지 설명한다. Content-Language가 지정되지 않은 경우에는 Represtation이 모든 언어의 대상이라는것을 나타내기도 하지만 어떤 언어를 의도하는지를 모른다는 의미도 가질 수 있다. 그리고 모든 내용이 Language-tag의 대상 언어로만 작성되어 있지 않다는것을 알아야 한다. 그렇기 때문에 Represtation내에 다국어가 존재한다고 해서 다국어 사용자들을 위한것이 아니다. 우리는 아래의 예제 Represtation을 한국인 대상으로 제공하는것으로 가정하자. 안녕하세요 (Hello) 위와 같은 Represtation이 있을때 한국어와 영어가 함께 있다고 해서 Content-Language : en, ko라고 작성하는 것이 아니다. 우리는 한국인을 대상으로 제공하는 Represtation이므로 Content-Language : ko라고 작성하는것이 옳은 방법이다. Content-Language는 모든 Media Type에 적용될 수 있다. 3.1.4. Identification 3.1.4.1 Identifying a Representation 완전한 또는 부분적인 Represtation을 메시지 페이로드(요청이나 응답의 바디)로 전송할 때, 발신자는 그 표현에 해당하는 리소스의 식별자를 제공하거나 또는 수신자가 결정하는것이 바람직하다. Request Message 요청에 Content-Location 헤더 필드가 있는 경우, Content-Location 헤더의 값에 의해 식별된 리소스라고 주장된다. 이러한 주장은 다른 방법으로 검증될 수 있는 경우가 아니면 신뢰할 수 없다. (당연히 요청하는 쪽에서 리소스가 식별되어있다고 주장하니깐 검증되지 않은 경우라면 신뢰할 수 없음) 이 정보는 수정된 내역 링크(리소스가 수정 되기 이전의 내용을 가진 link라고 생각하는데… 현재 내가 요청하는 URI가 이전에는 이러한 Link를 가졌었다고 보내면서 해당 리소스가 식별이 됐었다라는것을 표현하고 싶은건가??)를 나타낼때는 유용할 수 있다. 이외에는 Content-Location 헤더가 없다면 페이로드는 식별되지 않는다. Response Message 요청 메소드가 GET 또는 HEAD이고 응답 상태가 200(OK), 204(No Content), 206(Partial Content), 304(Not Modified)인 경우는 요청 URI는 식별된 유효한 리소스임을 나타낸다. 요청 메소드가 GET 또는 HEAD이고 응답 상태 코드가 203(Non-Authoriative Information)인 경우 서버와 클라이언트 사이에 있는 HTTP 프록시가 클라이언트에 도달하기 전에 응답을 변경하거나 추가 했다는것을 나타낸다. Response에서 Content-Location 헤더 필드가 있고 헤더 값이 유효한 요청 URI와 동일한 URI인 경우 페이로드는 유효한 요청 URI에 의해 식별된 리소스이다. Response에서 Content-Location 헤더 필드가 있고 헤더 값이 유효한 요청 URI와 다른 URI인 경우 발신자는 페이로드가 Content-Location 값으로 식별된 리소스의 표현이라고 단언한다. 이러한 주장은 다른 방법으로 검증될 수 있는 경우가 아니면 신뢰할 수 없다. 이외는 페이로드가 식별되지 않는다. 3.1.4.2. Content-Location Content-Location 헤더 필드는 메시지의 페이로드에 해당하는 특정 리소스의 식별자로 사용할 수 있는 URI를 참조한다. 메시지가 생성될때 이 URI에 대해 GET 요청을 수행한다면 200(OK) 응답은 메세지의 페이로드에 포함된 representation을 담고 있다. Content-Location = absolute-URI / partial-URI Content-Location 값은 유효한 Request URI의 대체 값이 아니라 메타데이터를 표현한다. Content-Location이 2xx(Successful) 응답 메시지에 포함되고 그 값이 유효한 요청 URI와 동일한 URI를 가리킨다면 수신자는 페이로드를 메시지 작성 날짜로 표시된 시점의 해당 리소스의 현재 representation으로 간주할 수 있다. (그냥 요청했을때의 representation으로 생각하면 됨). GET 또는 HEAD 요청의 경우, 이것은 서버가 Content-Location을 제공하지 않을 때의 기본 의미와 동일하다(제공하지 않다고 하더라도 URI를 GET 요청 후 2xx의 상태를 반환 한다는것은 리소스가 식별되었다는 뜻이니까?). PUT 또는 POST와 같은 상태 변화 요청의 경우, 서버의 응답에 해당 리소스의 새로운 representation이 포함됨을 의미하며, 따라서 Content-Location을 제공하지 않고 해당 동작이 수행됐다 라는 representation (body와 상태코드로만 200, “It worked!”라고 응답한것)과는 구별이 된다. 이를 통해 어플리케이션은 후속 GET 요청 없이 로컬에 저장된 내용으로 업데이트할 수 있다. 예를 들어 내가 아래와 같은 form으로 송금하도록 한다. &amp;lt;form action=&quot;/send-payment&quot; method=&quot;post&quot;&amp;gt; &amp;lt;p&amp;gt; &amp;lt;label&amp;gt;Who do you want to send the money to? &amp;lt;input type=&quot;text&quot; name=&quot;recipient&quot;&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;label&amp;gt;How much? &amp;lt;input type=&quot;number&quot; name=&quot;amount&quot;&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;Send Money&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 양식이 제출되면 사이트에서는 거래 영수증을 생성 후 서버는 향후 영수증 접근을 위해 Content-Location에 영수증 URL을 표시할 수 있다. HTTP/1.1 200 OK Content-Type: text/html; charset=utf-8 Content-Location: /my-receipts/38 &amp;lt;!doctype html&amp;gt; (Lots of HTML…) &amp;lt;p&amp;gt;You sent $38.00 to ExampleUser.&amp;lt;/p&amp;gt; (Lots more HTML…) 외외 메서드에서 Content-Location은 페이로드가 요청된 행동의 상태에 대한 표현을 보고하는 것을 나타내며, 주어진 URI에서 동일한 보고를 사용할 수 있음을 나타낸다 (GET을 사용한 향후 접근) 요청 메시지로 Content-Location을 전송하는 사용자는 헤더에 보낼 값인 URI는 사용자가 이전에 Representation의 내용을 획득한 곳을 의미한다. 즉 사용자는 원래 Representation의 리소스에 대한 이전 링크를 제공하는 것이다. 요청 메시지에서 Content-Location 필드를 수신하는 서버는 정보를 Representation의 일부로 저장하기 위한 메타 데이터가 아닌 임시 요청 컨텍스트로 취급해야한다. 서버는 요청 처리를 안내하거나 소스 링크 또는 버전 메타데이터 내의 다른 용도로 저장하기 위해 이 컨텍스트를 사용할 수 있다. 단 서버는 요청 의미를 변경하기 위해 이러한 컨텍스트 정보를 사용해서는 안된다. 예를 들어 클라이언트가 협상된 리소스에 대해 PUT (리디렉션 x) 요청을 하고 서버가 PUT 요청을 수락하는 경우, 해당 리소스의 새로운 상태는 해당 PUT에 제공된 하나의 Representation과 일치할 것으로 예상된다. Content-Location은 협상된 표현 중 하나만 업데이트할 수 있는 역방향 컨텐츠 선택 식별자의 형태로 사용될 수 없다. 사용자가 후자의 의미를 원했다면 PUT을 Content-Location URI에 직접 적용했을것이다. 솔직히 Content-Location 헤더의 역할과 의미가 잘 이해가 되지 않는다. 사용되는 예제도 잘 보이지 않을 뿐더러… 일단은 넘기는 걸로 (2021-02-06) 다시 생각해보니 PUT /URL 요청시 Content-Location은 변경되는 리소스를 가르키는 /URL이 되어야한다는 의미인거같다. 만약 PUT /URL 요청시 Content-Location을 /URLe 라는 하나의 표현에 대한 업데이트를 한다는것은 말이 안되기 때문이다. Representation이라는 것은 리소스를 여러 모습으로 표현한것이지 변경되는것은 해당하는 표현이 아니라 리소스이기 때문이다. (라고 이해 했지만 아직 잘 …) 3.2. Representation Data HTTP 메시지와 관련된 표현 데이터는 메시지의 페이로드 본문으로 제공되거나 메시지 의미 및 유효한 요청 URI에 의해 참조 된다. representation data는 representation metadata 헤더 필드에서 정의한 형식과 인코딩이다. representation data의 데이터 타입은 헤더필드 Content-Type 및 Content-Encoding을 통해 결정 된다. 순서가 지정된 2계층 인코딩 모델을 정의한다. representation-data := Content-Encoding( Content-Type( bits ) ) 컨텐츠 타입으로 지정된 데이터를 인코딩한것이 Representation Data가 되는것이다. 3.3. Payload Semantics 일부 HTTP 메시지는 payload 메시지로 전체 또는 부분 representation을 전송한다. 경우에 따라 페이로드에 관련 표현의 헤더필드(HEAD 메서드의 응답) 또는 representation data의 일부(206 (partial Content) 상태코드)만 포함될 수 있다. 요청에서 페이로드의 목적은 메서드 의미론에 의해 정의된다. 예를 들어 PUT 요청의 페이로드에 있는 representation은 요청이 성공적으로 적용될 경우 대상 리소스의 원하는 상태를 나타낸다. (예를 들어 서버에 저장된 1번 user의 name이 user1이고 우리는 그 유저의 이름을 user2로 변경하고 싶다. 이때 put 요청을 아래처럼 나타 낼 수 있다. PUT http://localhost/users/1 body : { 'name' : 'user2' } 성공적으로 응답 결과가 왔을 경우에는 1번 유저의 이름이 user2로 바뀌게 됨으로 요청에서 페이로드에 있는 representation은 리소스의 원하는 상태를 나타낸것임을 알수 있다.) POST 요청의 페이로드에 있는 representation은 대상 리소스가 처리할 정보를 나타낸다. (예를 들어 서버에 새로운 user를 만드는 요청을 보내 보자. POST http://localhost/users body : { 'name' : 'newUser' } 성공적으로 응답 결과가 왔을 경우 유저가 생성이 되었다는 의미이므로 요청에서 페이로드에 있는 representation은 리소스가 처리할 정보를 나타낸것임을 알 수 있다.) 이에 대해 페이로드의 목적은 요청 메소드와 응답 상태 코드에 의해 모두 정의된다. GET에 대한 200(OK) 응답의 페이로드는 메시지 시작일에 리소스의 현재 상태는 나타낸다. POST에 대한 응답에서 200(OK) 응답의 페이로드는 처리 결과 또는 처리 적용 후 대상 리소스의 새 상태를 나타낼 수 있다. 오류 상태로 반환되는 경우 응답 메시지에 오류 상태와 오류 해결을 위한 제안되는 다음 단계를 설명하는 것과 같은 오류 조건을 나타내는 페이로드가 포함되어 있다. 연관된 representation보다 페이로드를 구체적으로 기술하는 헤더 필드를 payload header fields라고 한다. 페이로드 헤더 필드는 메시지 구문 분석에 대한 영향 때문에 이 명세의 다른 부분에 정의되어 있다. Header Field Name Content-Length Content-Range Trailer Transfer-Encoding 3.4. Content Negotiation 응답이 성공이던 오류이던 페이로드 정보를 전달할 때, 서버는 다른 형식, 언어, 인코딩과 같은 정보를 표시하는 방법이 있다. 여러 사용자마다 어떤 representation을 가장 잘 전달하는지에 영향을 미칠 수 있는 능력, 특성, 선호도가 다를 수 있다. 이러한 이유로 HTTP는 콘텐츠 협상의 메커니즘을 제공한다. 이 명세는 프로토콜 내에서 가시화할 수 있는 콘텐츠 협상의 2가지 패턴을 정의한다. 서버가 사용자의 명시적 선호도에 따라 표현을 선택하는 proactive (사전)협상과, 서버가 사용자 에이전트가 선택할 수 있는 표현 목록을 제공하는 reactive(대응)협상이 있다. 그외 콘텐츠 협상 패턴으로는 사용자 매개변수에 따라 선택적으로 렌더링 되는 여러 부분으로 구성된 contitional contet, 사용자 특성에 따라 추가(더 구체적인) 요청을 하는 스크립트가 포함된 active content, Transparent Content Negotiation등이 있다. 여기서 콘텐츠 선택은 중개자가 수행한다. 이러한 패턴은 상호 배타적이지 않으며, 적용성과 실용성에서 각각 절충점을 가진다. 모든 경우에서 HTTP는 리소스 의미론을 인식하지 못한다. 시간이 지남에 따라, 그리고 시간에 따라, 그리고 콘텐츠 협상의 다양한 차원에 걸쳐, 그리고 시간에 따른 리소스의 관찰된 표현의 sameness에 대해 서버가 요청하는 응답하는 일관성은 전적으로 어떤 항목이나 알고리즘이 그러한 응답을 선택하거나 생성하는가에 의해 결정된다 HTTP는 커튼 위에 있는 사람에게 관심을 두지 않는다. 그냥 우리가 요청하는 헤더와 메서드와 리소스의 의미를 HTTP는 모른다는 말로, 개발자는 요청하는 의미대로 동작하게 만들어야한다는 뜻 두 콘텐츠 협상과 관련된 내용은 MDN에서 설명된 내용을 가져왔다. 가장 깔끔하게 쓰여졌다고 생각한다. 3.4.1. Proactive Negotiation (MDN 내용 참고) 서버 주도 컨텐츠 협상 혹은 주도적인 협상에 있어서, 브라우저(혹은 사용자 에이전트라면 어떤 다른 종류든지)는 URL을 이용해 몇 개의 HTTP 헤더를 전송합니다. 이런 헤더들은 사용자의 우선적인 선택을 나타냅니다. 서버는 그것들을 힌트로써 사용하며 내부 알고리즘은 클라이언트로 서브하기 위한 최선의 컨텐츠를 선택하게 됩니다. 이 알고리즘은 서버 특유의 것이며 표준으로 정의된 것은 아닙니다. HTTP/1.1 표준은 서버 주도 협상을 시작하는 표준 헤더 목록(Accept, Accept-Charset, Accept-Encoding, Accept-Language)을 정의하고 있습니다. 엄밀히 말하자면 User-Agent이 리스트 내에 없긴 하지만, 해당 헤더는, 좋은 관례가 아니라고 판단될지라도, 때때로 요청된 리소스의 특정 프레젠테이션을 전송하는데 사용되기도 합니다. 서버는 실제로 컨텐츠 협상에 있어 어떤 헤더가 사용될 지 (더 엄밀히 말하자면 연관된 응답 헤더) 가리키기 위해 Vary 헤더를 사용하므로 캐시는 최적으로 동작하게 됩니다. 이것과 더불어, 클라이언트 힌트라고 부르는 헤더들을 이용 가능한 헤더 목록에 추가하려는 실험적인 제안도 존재합니다. 클라이언트 힌트는 사용자 에이전트가 실행 중인 기기의 종류가 무엇인지를 알려줍니다(예를 들어, 데스크톱 컴퓨터인지 모바일 기기인지) 서버 주도 컨텐츠 협상이 리소스의 특정 프레젠테이션에 동의하기 위한 가장 일반적인 방법이긴 하지만, 몇 가지 결점을 가지고 있습니다: 서버는 브라우저에 대한 전체적인 지식을 가지고 있지 않습니다. 클라이언트 힌트 확장이 있더라도, 서버는 브라우저의 수용 능력에 대한 완벽한 정보를 가지고 있진 않습니다. 클라이언트가 선택하는 리액티브 컨텐츠 협상과는 다르게, 서버 선택은 항상 다소 임의적입니다. 클라이언트에 의한 정보는 상당히 장황하며(HTTP/2 헤더 압축은 이런 문제를 완화시킵니다) 사생활 침해에 대한 위협을 가지고 있습니다(HTTP 핑거프린팅). 주어진 리소스의 몇몇 프레젠테이션이 전송되므로, 샤드된 캐시들은 덜 효율적이며 서버 구현은 좀 더 복잡해집니다. 3.4.2. Reactive Negotiation (MDN 내용 참고) 서버 주도 협상은 몇 가지 불리한 점 때문에 고통을 줍니다: 그것은 확장하기가 용이하지 않습니다. 협상 내에서 사용하는 기능 당 한 가지 헤더가 존재해야 합니다. 만약 스크린 크기, 해상도 혹은 또 다른 치수를 사용하고자 한다면, 새로운 HTTP 헤더가 반드시 만들어져야 합니다. 헤더의 전송은 반드시 모든 요청 상에서 이루어져야 합니다. 이것은 몇몇 헤더들에 있어서는 그리 문제될 것은 아니지만, 그런 헤더들이 결국 증가하여, 메시지 사이즈가 성능에 악영향이 끼치는 상황이 올 수도 있습니다. 정확한 헤더가 전송되면 전송될수록, 불확실성도 더욱 더 전송되어, 좀 더 많은 HTTP 흔적과 그와 관련된 개인정보들이 남게 됩니다. HTTP의 초창기부터, 프로토콜은 또 다른 협상 유형을 허용했습니다: 에이전트 주도 협상 혹은 리액티브 협상. 이 협상에서, 애매모호한 요청과 맞닥뜨렸을 경우, 서버는 사용 가능한 대체 리소스들에 대한 링크를 포함하고 있는 페이지를 회신하게 됩니다. 사용자는 해당 리소스들을 표시하고 사용하려는 리소스를 선택하게 됩니다. 불행하게도, HTTP 표준은 그 과정을 쉽게 자동화하는 것을 지원하지 않고, 사용 가능한 리소스 중에서 선택하도록 허용하는 페이지의 형식을 명시하지 않고 있습니다. 게다가 서버 주도 협상으로의 회귀로, 이 방법은 스크립팅, 특히 자바스크립트 리다이렉션과 함께 거의 항상 사용됩니다: 협상 기준을 점검하고 난 뒤에, 스크립트는 리다이렉션을 실행합니다. 두번째 문제는 실제 리소스를 가져오는데 한 개 이상의 요청이 필요로 해서, 사용자에 대한 리소스 효용성이 떨어진다는 것입니다.</summary></entry><entry><title type="html">테스트 코드 수정 완료 및 변경점</title><link href="https://lcy960729.github.io/wordbook-project/2021/01/24/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%88%98%EC%A0%95-%EC%99%84%EB%A3%8C-%EB%B0%8F-%EB%B3%80%EA%B2%BD%EC%A0%90.html" rel="alternate" type="text/html" title="테스트 코드 수정 완료 및 변경점" /><published>2021-01-24T00:00:00+09:00</published><updated>2021-01-24T00:00:00+09:00</updated><id>https://lcy960729.github.io/wordbook-project/2021/01/24/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%88%98%EC%A0%95-%EC%99%84%EB%A3%8C-%EB%B0%8F-%EB%B3%80%EA%B2%BD%EC%A0%90</id><content type="html" xml:base="https://lcy960729.github.io/wordbook-project/2021/01/24/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%88%98%EC%A0%95-%EC%99%84%EB%A3%8C-%EB%B0%8F-%EB%B3%80%EA%B2%BD%EC%A0%90.html">&lt;h1 id=&quot;2021-01-24--테스트-코드-수정-완료-및-변경점&quot;&gt;2021-01-24 :: 테스트 코드 수정 완료 및 변경점&lt;/h1&gt;

&lt;h2 id=&quot;테스트-코드-작성시-불편했던-점&quot;&gt;테스트 코드 작성시 불편했던 점&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-01-24-테스트-코드-수정-완료-및-변경점/TestingResult.png&quot; alt=&quot;TestingResult.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;며칠 동안 많은 양의 테스트 코드들을 수정완료 했다.&lt;/p&gt;

&lt;p&gt;문제는 서비스레이어에서 테스트 작성시 아래 코드와 같은 관계를 가진 상태를 만들어 주어야했다. 처음 진행할때는 Entity 관계가 깊지 않아 테스트 코드 작성시 문제가 되지 않았는데 프로젝트를 진행함에 따라 깊어지는 도메인간의 관계를 작성하는것은 큰 불편함이 있었다. 이러한 상태를 매번 작성하는것이 무의미함과 동시에 중복된 코드가 대량 발생하고 테스트 코드 작성시 너무 많은 시간이 걸렸다. 이러한 문제를 해결하기위해 Factory패턴이라고 해야할까.. 상태를 미리 만들어놓고 필요한 도메인들을 골라서 사용하기로 하였다.&lt;/p&gt;

&lt;h3 id=&quot;변경-전-코드&quot;&gt;변경 전 코드&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@DisplayName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;일반 권한 사용자가 그룹 단어장의 DTO를 정상적으로 반환하는 테스트&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDetailDTOByUserIdAndStudyGroupIdAndWordBookId1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//given&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testName&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testEmail@test.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testPw&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;StudyGroup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StudyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isUsing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testStudyGroupName&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;Study&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Study&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isUsing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;studyGroupRole&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;StudyGroupRole&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;NORMAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;joinToStudy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addStudy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;StudyGroupWordBook&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroupWordBook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StudyGroupWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isUsing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testWordBookName&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;studyGroupWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getStudyService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getEntityByFindByUserIdAndStudyGroupsId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyLong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anyLong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;willReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroupId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getStudyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordBookId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroupWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//when&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;WordBookDetailDTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordBookDetailDTO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStudyGroupWordBookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDetailDTOByUserIdAndStudyGroupIdAndWordBookId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroupId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordBookId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordBookDetailDTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isNotNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordBookDetailDTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEqualTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordBookId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;수정-후&quot;&gt;수정 후&lt;/h2&gt;

&lt;p&gt;DomainFactory라는 클래스를 만든 후 모든 Domain간의 관계가 형성된 상태를 만든다( 상태라는 말이 맞나??)&lt;/p&gt;

&lt;p&gt;이후 테스트 코드에서 필요한 도메인을 받아서 쓰도록 만들었다. 이렇게 만들어보니 테스트 코드 작성시 계속 해서 만들어야하는 entity들을 바로 꺼내서 테스트 돌려볼 수 있어서 테스트 코드 양도 줄어들고 작성 시간도 줄어들게 됐다.&lt;/p&gt;

&lt;h3 id=&quot;domainfactory&quot;&gt;DomainFactory&lt;/h3&gt;

&lt;p&gt;아래 코드 처럼 생성시 모든 관계를 형성하는 상태를 만든 후 getter를 이용하여 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DomainFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userOfStudyGroupAdmin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Study&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyOfStudyGroupAdmin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Study&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StudyGroup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StudyGroupWordBook&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroupWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserWordBook&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userWordBookOfAdminUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserWordBook&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DomainFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userOfStudyGroupAdmin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userOfStudyGroupNormal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createStudyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;studyOfStudyGroupAdmin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createStudyOfNormalUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userOfStudyGroupAdmin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;joinToStudy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;studyOfStudyGroupAdmin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addStudy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;studyOfStudyGroupAdmin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;studyOfStudyGroupNormal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createStudyOfAdminUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;joinToStudy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;studyOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addStudy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;studyOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;studyGroupWordBook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createStudyGroupWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;studyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;studyGroupWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;userWordBookOfAdminUser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createUserWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userOfStudyGroupAdmin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userOfStudyGroupAdmin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userWordBookOfAdminUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;userWordBook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createUserWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;LongStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;studyGroupWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;userWordBookOfAdminUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;userWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createWord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//이후는 getter 코드...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;변경-후-코드&quot;&gt;변경 후 코드&lt;/h3&gt;

&lt;p&gt;DomainFactory를 이용하여 작성한 테스트 코드를 보면 아래와 같이 변경 됐다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@DisplayName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;일반 권한 사용자가 그룹 단어장의 DTO를 정상적으로 반환하는 테스트&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDetailDTOByUserIdAndStudyGroupIdAndWordBookId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//given&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Study&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;domainFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getStudyOfStudyGroupNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;StudyGroupWordBook&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroupWordBook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;domainFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getStudyGroupWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getStudyService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getEntityByFindByUserIdAndStudyGroupsId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyLong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anyLong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;willReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroupId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getStudyGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordBookId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroupWordBook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//when&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;WordBookDetailDTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordBookDetailDTO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStudyGroupWordBookService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDetailDTOByUserIdAndStudyGroupIdAndWordBookId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;studyGroupId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordBookId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordBookDetailDTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isNotNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordBookDetailDTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEqualTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordBookId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드가 훨씬 간결해지고 어떤 테스트 코드를 작성하던 원하는 도메인만 골라서 사용하면 된다. 훨씬 줄어든 코드량으로 빠르게 테스트 코드들을 수정할 수 있었다. 변경된 방식으로 테스트 코드를 작성하게 되면서 테스트 코드 수정에 부담감이 많이 사라지게 됐다.&lt;/p&gt;

&lt;p&gt;다음 진행은 spring security를 학습하여 로그인과 사용자 인증관련된 기능을 추가를 해보도록 하겠다.&lt;/p&gt;

&lt;p&gt;(이걸 해야 그룹에서 원하는 상대를 초대할때 내가 초대한 사용자가 맞는지 확인을 할 수 있을것 같다, 현재까지 구현한 유저 도메인이 통째로 변경될텐데… ㅜ)&lt;/p&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="wordbook-project" /><category term="WordBookProject" /><category term="TestCode" /><summary type="html">2021-01-24 :: 테스트 코드 수정 완료 및 변경점 테스트 코드 작성시 불편했던 점 며칠 동안 많은 양의 테스트 코드들을 수정완료 했다. 문제는 서비스레이어에서 테스트 작성시 아래 코드와 같은 관계를 가진 상태를 만들어 주어야했다. 처음 진행할때는 Entity 관계가 깊지 않아 테스트 코드 작성시 문제가 되지 않았는데 프로젝트를 진행함에 따라 깊어지는 도메인간의 관계를 작성하는것은 큰 불편함이 있었다. 이러한 상태를 매번 작성하는것이 무의미함과 동시에 중복된 코드가 대량 발생하고 테스트 코드 작성시 너무 많은 시간이 걸렸다. 이러한 문제를 해결하기위해 Factory패턴이라고 해야할까.. 상태를 미리 만들어놓고 필요한 도메인들을 골라서 사용하기로 하였다. 변경 전 코드 @Test @DisplayName(&quot;일반 권한 사용자가 그룹 단어장의 DTO를 정상적으로 반환하는 테스트&quot;) void getDetailDTOByUserIdAndStudyGroupIdAndWordBookId1() { //given User user = User.builder() .id(0L) .name(&quot;testName&quot;) .email(&quot;testEmail@test.com&quot;) .pw(&quot;testPw&quot;) .build(); StudyGroup studyGroup = StudyGroup.builder() .id(1L) .isUsing(true) .name(&quot;testStudyGroupName&quot;) .build(); Study study = Study.builder() .id(3L) .isUsing(true) .user(user) .studyGroup(studyGroup) .studyGroupRole(StudyGroupRole.NORMAL) .build(); user.joinToStudy(study); studyGroup.addStudy(study); StudyGroupWordBook studyGroupWordBook = StudyGroupWordBook.builder() .id(4L) .isUsing(true) .name(&quot;testWordBookName&quot;) .studyGroup(studyGroup) .build(); studyGroup.addWordBook(studyGroupWordBook); given(getStudyService.getEntityByFindByUserIdAndStudyGroupsId(anyLong(), anyLong())).willReturn(study); Long userId = study.getUser().getId(); Long studyGroupId = study.getStudyGroup().getId(); Long wordBookId = studyGroupWordBook.getId(); //when WordBookDetailDTO wordBookDetailDTO = getStudyGroupWordBookService.getDetailDTOByUserIdAndStudyGroupIdAndWordBookId(userId, studyGroupId, wordBookId); //then assertThat(wordBookDetailDTO).isNotNull(); assertThat(wordBookDetailDTO.getId()).isEqualTo(wordBookId); } 수정 후 DomainFactory라는 클래스를 만든 후 모든 Domain간의 관계가 형성된 상태를 만든다( 상태라는 말이 맞나??) 이후 테스트 코드에서 필요한 도메인을 받아서 쓰도록 만들었다. 이렇게 만들어보니 테스트 코드 작성시 계속 해서 만들어야하는 entity들을 바로 꺼내서 테스트 돌려볼 수 있어서 테스트 코드 양도 줄어들고 작성 시간도 줄어들게 됐다. DomainFactory 아래 코드 처럼 생성시 모든 관계를 형성하는 상태를 만든 후 getter를 이용하여 사용한다. @Component public class DomainFactory { private final User userOfStudyGroupAdmin; private final User userOfStudyGroupNormal; private final Study studyOfStudyGroupAdmin; private final Study studyOfStudyGroupNormal; private final StudyGroup studyGroup; private final StudyGroupWordBook studyGroupWordBook; private final UserWordBook userWordBookOfAdminUser; private final UserWordBook userWordBook; public DomainFactory() { userOfStudyGroupAdmin = createUser(0L); userOfStudyGroupNormal = createUser(1L); studyGroup = createStudyGroup(0L); studyOfStudyGroupAdmin = createStudyOfNormalUser(0L, studyGroup, userOfStudyGroupNormal); userOfStudyGroupAdmin.joinToStudy(studyOfStudyGroupAdmin); studyGroup.addStudy(studyOfStudyGroupAdmin); studyOfStudyGroupNormal = createStudyOfAdminUser(1L, studyGroup, userOfStudyGroupNormal); userOfStudyGroupNormal.joinToStudy(studyOfStudyGroupNormal); studyGroup.addStudy(studyOfStudyGroupNormal); studyGroupWordBook = createStudyGroupWordBook(0L, studyGroup); studyGroup.addWordBook(studyGroupWordBook); userWordBookOfAdminUser = createUserWordBook(0L, userOfStudyGroupAdmin); userOfStudyGroupAdmin.addWordBook(userWordBookOfAdminUser); userWordBook = createUserWordBook(1L, userOfStudyGroupNormal); userOfStudyGroupNormal.addWordBook(userWordBook); int length = 4; LongStream.range(0, length).forEach(i -&amp;gt; { studyGroupWordBook.addWord(createWord(i)); userWordBookOfAdminUser.addWord(createWord(i)); userWordBook.addWord(createWord(i)); }); } //이후는 getter 코드... 변경 후 코드 DomainFactory를 이용하여 작성한 테스트 코드를 보면 아래와 같이 변경 됐다. @Test @DisplayName(&quot;일반 권한 사용자가 그룹 단어장의 DTO를 정상적으로 반환하는 테스트&quot;) void getDetailDTOByUserIdAndStudyGroupIdAndWordBookId() { //given Study study = domainFactory.getStudyOfStudyGroupNormal(); StudyGroupWordBook studyGroupWordBook = domainFactory.getStudyGroupWordBook(); given(getStudyService.getEntityByFindByUserIdAndStudyGroupsId(anyLong(), anyLong())).willReturn(study); Long userId = study.getUser().getId(); Long studyGroupId = study.getStudyGroup().getId(); Long wordBookId = studyGroupWordBook.getId(); //when WordBookDetailDTO wordBookDetailDTO = getStudyGroupWordBookService.getDetailDTOByUserIdAndStudyGroupIdAndWordBookId(userId, studyGroupId, wordBookId); //then assertThat(wordBookDetailDTO).isNotNull(); assertThat(wordBookDetailDTO.getId()).isEqualTo(wordBookId); } 코드가 훨씬 간결해지고 어떤 테스트 코드를 작성하던 원하는 도메인만 골라서 사용하면 된다. 훨씬 줄어든 코드량으로 빠르게 테스트 코드들을 수정할 수 있었다. 변경된 방식으로 테스트 코드를 작성하게 되면서 테스트 코드 수정에 부담감이 많이 사라지게 됐다. 다음 진행은 spring security를 학습하여 로그인과 사용자 인증관련된 기능을 추가를 해보도록 하겠다. (이걸 해야 그룹에서 원하는 상대를 초대할때 내가 초대한 사용자가 맞는지 확인을 할 수 있을것 같다, 현재까지 구현한 유저 도메인이 통째로 변경될텐데… ㅜ)</summary></entry><entry><title type="html">의존하는 객체에 대한 테스트 코드 고찰</title><link href="https://lcy960729.github.io/wordbook-project/2021/01/18/%EC%9D%98%EC%A1%B4%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EC%97%90-%EB%8C%80%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EA%B3%A0%EC%B0%B0.html" rel="alternate" type="text/html" title="의존하는 객체에 대한 테스트 코드 고찰" /><published>2021-01-18T00:00:00+09:00</published><updated>2021-01-18T00:00:00+09:00</updated><id>https://lcy960729.github.io/wordbook-project/2021/01/18/%EC%9D%98%EC%A1%B4%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EC%97%90-%EB%8C%80%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EA%B3%A0%EC%B0%B0</id><content type="html" xml:base="https://lcy960729.github.io/wordbook-project/2021/01/18/%EC%9D%98%EC%A1%B4%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EC%97%90-%EB%8C%80%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EA%B3%A0%EC%B0%B0.html">&lt;h1 id=&quot;2021-01-18--의존하는-객체에-대한-테스트-코드-고찰&quot;&gt;2021-01-18 :: 의존하는 객체에 대한 테스트 코드 고찰&lt;/h1&gt;

&lt;p&gt;구현 코드들을 대량 수정하면서 테스트 코드들이 여러 깨지게 됐다. 해당 테스트 코드들을 고치면서 느낀점이 서비스 레이어 단에서 mapper 클래스가 계속 사용되게 되는데 이 모든걸을 mock 객체로 두면 매번 given으로 정의를 해줘야한다. 동작을 정의 해주면서 mapper가 들어가기 이전 값과 결과 값을 계속해서 생성하게 되는 코드가 반복되는데 해당 코드들을 줄이기로 했다.&lt;/p&gt;

&lt;p&gt;일단 모든 테스트 코드는 도메인 단위로 작성하도록 하고 있다. 이제 도메인 단위에서 Mapper의 테스트 코드를 작성하고 Mapper 테스트 코드가 정상적으로 동작하게 되면 서비스 레이어에서 테스트 코드를 작성할 때 사용되는 Mapper 객체를 목 객체가 아닌 구현 객체로 테스트 한다. 이렇게 변경하게되면서 테스트 코드에 중복되는 많은 코드들을  줄일 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;간단하게 예를 들면 아래가 mapper 클래스를 mock 객체로 둔 이전의 테스트 코드이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDetailDTOById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//given&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testName&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testPw&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0L&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;UserDetailDTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userDetailDTOTemp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserDetailDTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testName&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;willReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userToUserDetailDtoMapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;entityToUserDetailDTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;willReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userDetailDTOTemp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//when&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;UserDetailDTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userDetailDTO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getUserService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDetailDTOById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userDetailDTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isNotNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 코드가 mapper 테스트 코드를 먼저 작성하고 정상적으로 동작된다는 가정하에 mapper 클래스를 mock이 아닌 구현 객체를 사용한것이다. 많은 양의 코드가 줄어들게 되었으며  다른 테스트 코드에서 중복되는 코드들을 줄일 수 있었다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@DisplayName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;아이디로 UserDetailDTO를 반환하는 테스트&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDetailDTOById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//given&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;GetUserService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getUserService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GetUserService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userToUserDetailDtoMapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyLong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;willReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DomainFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)));&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//when&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;UserDetailDTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userDetailDTO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getUserService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDetailDTOById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userDetailDTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isNotNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;프로젝트를 진행을 하면서 많은 코드들을 수정하게 되고 프로그램의 사이즈가 커질 수록(그렇게 큰건 아니지만) 의존하는 객체들이 여럿 생겨나게 된다. 테스트 코드 작성시 의존하는 객체들은 모두 mocking을 하기에 테스트 코드를 작성할때마다 중복되는 코드가 많이 생기게 되고 테스트 코드를 작성하는 시간 때문에 개발 속도에도 큰 영향을 주게 되었다.&lt;/p&gt;

&lt;p&gt;해결책으로 선택한 나의 방법은 어느정도의 의존 객체를 모두 mocking 하지 않고 구현 객체로 사용하는것이다. 이 방법을 선택하고 난 후 테스트 코드의 중복 코드가 줄어들고 개발 속도가 높아지는 이점을 주었다.&lt;/p&gt;

&lt;p&gt;(만약 이 부분(서비스 레이어)에서 에러가 발생하더라도 실제로 의존하는 객체는 mapper객체들 뿐이고 나머지는 모두 mock 객체이기 때문에 mapper와 서비스 코드에서 에러를 확인하면 된다. 테스트 코드에 의존하는 부분들을 잘 정리해 두면 나중에 다른 팀원이 참가하게 됐을때나 코드를 변경하면서 발생하는 에러를 찾을때 실제 구현 객체에 의존하는 객체들만 확인 해보면 된다. )&lt;/p&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="wordbook-project" /><category term="WordBookProject" /><category term="TestCode" /><summary type="html">2021-01-18 :: 의존하는 객체에 대한 테스트 코드 고찰 구현 코드들을 대량 수정하면서 테스트 코드들이 여러 깨지게 됐다. 해당 테스트 코드들을 고치면서 느낀점이 서비스 레이어 단에서 mapper 클래스가 계속 사용되게 되는데 이 모든걸을 mock 객체로 두면 매번 given으로 정의를 해줘야한다. 동작을 정의 해주면서 mapper가 들어가기 이전 값과 결과 값을 계속해서 생성하게 되는 코드가 반복되는데 해당 코드들을 줄이기로 했다. 일단 모든 테스트 코드는 도메인 단위로 작성하도록 하고 있다. 이제 도메인 단위에서 Mapper의 테스트 코드를 작성하고 Mapper 테스트 코드가 정상적으로 동작하게 되면 서비스 레이어에서 테스트 코드를 작성할 때 사용되는 Mapper 객체를 목 객체가 아닌 구현 객체로 테스트 한다. 이렇게 변경하게되면서 테스트 코드에 중복되는 많은 코드들을 줄일 수 있게 되었다. 간단하게 예를 들면 아래가 mapper 클래스를 mock 객체로 둔 이전의 테스트 코드이다. @Test void getDetailDTOById() throws Exception { //given Long id = 0L; User user = User.builder() .id(id) .name(&quot;testName&quot;) .pw(&quot;testPw&quot;) .email(&quot;0L&quot;) .build(); UserDetailDTO userDetailDTOTemp = UserDetailDTO.builder() .id(id) .name(&quot;testName&quot;) .build(); given(userRepository.findById(id)).willReturn(Optional.of(user)); given(userToUserDetailDtoMapper.entityToUserDetailDTO(any(User.class))).willReturn(userDetailDTOTemp); //when UserDetailDTO userDetailDTO = getUserService.getDetailDTOById(id); //then assertThat(userDetailDTO).isNotNull(); } 아래 코드가 mapper 테스트 코드를 먼저 작성하고 정상적으로 동작된다는 가정하에 mapper 클래스를 mock이 아닌 구현 객체를 사용한것이다. 많은 양의 코드가 줄어들게 되었으며 다른 테스트 코드에서 중복되는 코드들을 줄일 수 있었다. @Test @DisplayName(&quot;아이디로 UserDetailDTO를 반환하는 테스트&quot;) void getDetailDTOById() { //given GetUserService getUserService = new GetUserService(userRepository, userToUserDetailDtoMapper); long userId = 0L; given(userRepository.findById(anyLong())).willReturn(Optional.of(DomainFactory.createUser(userId))); //when UserDetailDTO userDetailDTO = getUserService.getDetailDTOById(userId); //then assertThat(userDetailDTO).isNotNull(); } 프로젝트를 진행을 하면서 많은 코드들을 수정하게 되고 프로그램의 사이즈가 커질 수록(그렇게 큰건 아니지만) 의존하는 객체들이 여럿 생겨나게 된다. 테스트 코드 작성시 의존하는 객체들은 모두 mocking을 하기에 테스트 코드를 작성할때마다 중복되는 코드가 많이 생기게 되고 테스트 코드를 작성하는 시간 때문에 개발 속도에도 큰 영향을 주게 되었다. 해결책으로 선택한 나의 방법은 어느정도의 의존 객체를 모두 mocking 하지 않고 구현 객체로 사용하는것이다. 이 방법을 선택하고 난 후 테스트 코드의 중복 코드가 줄어들고 개발 속도가 높아지는 이점을 주었다. (만약 이 부분(서비스 레이어)에서 에러가 발생하더라도 실제로 의존하는 객체는 mapper객체들 뿐이고 나머지는 모두 mock 객체이기 때문에 mapper와 서비스 코드에서 에러를 확인하면 된다. 테스트 코드에 의존하는 부분들을 잘 정리해 두면 나중에 다른 팀원이 참가하게 됐을때나 코드를 변경하면서 발생하는 에러를 찾을때 실제 구현 객체에 의존하는 객체들만 확인 해보면 된다. )</summary></entry><entry><title type="html">도메인 기능들 구현 완료</title><link href="https://lcy960729.github.io/wordbook-project/2021/01/17/%EB%8F%84%EB%A9%94%EC%9D%B8-%EA%B8%B0%EB%8A%A5%EB%93%A4-%EA%B5%AC%ED%98%84-%EC%99%84%EB%A3%8C.html" rel="alternate" type="text/html" title="도메인 기능들 구현 완료" /><published>2021-01-17T00:00:00+09:00</published><updated>2021-01-17T00:00:00+09:00</updated><id>https://lcy960729.github.io/wordbook-project/2021/01/17/%EB%8F%84%EB%A9%94%EC%9D%B8-%EA%B8%B0%EB%8A%A5%EB%93%A4-%EA%B5%AC%ED%98%84-%EC%99%84%EB%A3%8C</id><content type="html" xml:base="https://lcy960729.github.io/wordbook-project/2021/01/17/%EB%8F%84%EB%A9%94%EC%9D%B8-%EA%B8%B0%EB%8A%A5%EB%93%A4-%EA%B5%AC%ED%98%84-%EC%99%84%EB%A3%8C.html">&lt;h1 id=&quot;2021-01-17--도메인-기능들-구현-완료&quot;&gt;2021-01-17 :: 도메인 기능들 구현 완료&lt;/h1&gt;

&lt;p&gt;모든 도메인에 대해서 Create, Update, Get 메소드의 반환 값이 동일 함으로 Create 메소드의 반환값으로만 설명을 하겠다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-user-도메인&quot;&gt;1. User 도메인&lt;/h2&gt;

&lt;p&gt;먼저 유저이다. 일단 아직 Spring security를 사용하지 않았기 때문에 세션이 존재하지는 않는다.&lt;/p&gt;

&lt;p&gt;추가, 수정, 조회가 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;1-create&quot;&gt;1. create&lt;/h3&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;http://localhost:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/api/v&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/users&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testEmail@test.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;pw&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testPw&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testName123&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Created(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;201&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testName123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testEmail@test.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;self&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;update_user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;delete_user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;create_studyGroup&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;create_userWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 결과 값이 나오며 다음 상태로 갈 수 있는 정보가 나오게 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-userwordbook-도메인&quot;&gt;2. UserWordBook 도메인&lt;/h2&gt;

&lt;p&gt;사용자 개인 단어장이다.&lt;/p&gt;

&lt;p&gt;추가, 수정, 삭제, 조회가 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;1-create-1&quot;&gt;1. Create&lt;/h3&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;http://localhost:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/api/v&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/users/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/wordbooks&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testWordBook&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Created(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;201&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;isUsing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;self&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;update_userWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;delete_userWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;add_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;get_user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 정상적으로 추가 됐다면 다음 상태에 있는 get_user를 요청 해보자.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testName123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testEmail@test.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;wordBookDTOList&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;get_userWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 생성한 유저를 요청한 결과이다 밑에 다음 상태를 설명해주는 부분은 생략을 하였다.&lt;/p&gt;

&lt;p&gt;달라진 점으론 wordBookDTOList가 생겼다. 그리고 해당 wordBookDTOList의 wordBook을 조회할 수 있는 상태를 나타냈다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-word-of-userwordbook-도메인&quot;&gt;3. Word Of UserWordBook 도메인&lt;/h2&gt;

&lt;p&gt;유저 개인 단어장의 단어들이다.&lt;/p&gt;

&lt;p&gt;추가, 수정, 조회, 삭제가 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;1-create-2&quot;&gt;1. Create&lt;/h3&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;http://localhost:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/api/v&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/users/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/wordbooks/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/words&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;voca&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;meaning&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;사과&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Created(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;201&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;voca&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;meaning&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;사과&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;update_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/3&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;delete_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/3&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;get_userWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;단어를 2개 정도 생성해보고 다시 get_userWordBook을 호출하게 되면 아래와 같이 단어가 추가되고 해당 단어에서 갈 수 있는 상태인 수정과 삭제 요청을 반환한다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;isUsing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;wordDTOList&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;voca&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;meaning&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;사과&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;update_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/3&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;delete_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/3&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;voca&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;banana&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;meaning&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;바나나&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;update_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/4&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;delete_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/4&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;self&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;update_userWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;delete_userWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;add_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;get_user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;그룹과 관련하여 그룹 관리자와 그룹 사용자로 나뉘게 된다. 그룹 관리자와 그룹 사용자의 기능은 나누어서 구현하였으며 그룹 참여 기능을 구현하게 되면 이후에 다른 권한에 대한 결과값 구현 내용을 추가 하겠다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-studygroup-도메인&quot;&gt;4. StudyGroup 도메인&lt;/h2&gt;

&lt;p&gt;개인 유저들이 모여서 그룹을 만드는 도메인이다.&lt;/p&gt;

&lt;p&gt;아직 그룹 참여 기능은 구현되지 않았다. 해당 기능을 구현하기 위해선 어떤 방식으로 그룹에 참여할지에 대한 설계가 필요할것 같다. 추후 회의를 통해서 정하도록 해야겠다.&lt;/p&gt;

&lt;p&gt;추가, 수정, 삭제, 조회가 가능하다&lt;/p&gt;

&lt;h3 id=&quot;1-create-3&quot;&gt;1. Create&lt;/h3&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;http://localhost:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/api/v&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/users/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/study-groups&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testStudyGroup&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Created(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;201&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testStudyGroup&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;userDTOList&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testName123&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;self&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;update_studyGroup&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;delete_studyGroup&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;create_studyGroupWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;get_user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그룹이 생성되며 그룹 사용자와 그룹 단어장이 반환된다. 그룹 단어장은 현재 없는 상태이므로 반환되지 않도록 하였다. 또한 그룹 생성자는 그룹 관리자 권한을 가지게 되며 해당 관리자가 아닌 유저가 그룹 단어장에 접근 하게 되면 update_studyGroup,  delete_studyGroup, create_studyGroupWordBook 해당 링크들을 반환하지 않도록 구현하였다.&lt;/p&gt;

&lt;p&gt;이후 다시 get_User를 요청해보겠다. 아래와 같은 결과값이 반환되며 이외 부분은 모두 생략하였다. 각 그룹을 조회 할 수 있는 링크 정보가 담겨 있다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testName123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testEmail@test.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;studyGroupDTOList&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testStudyGroup&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;get_studyGroup&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-studygroupwordbook-도메인&quot;&gt;5. StudyGroupWordBook 도메인&lt;/h2&gt;

&lt;p&gt;그룹에서 사용하는 단어장이다. 유저 단어장과 기능은 동일 하다.&lt;/p&gt;

&lt;p&gt;추가, 수정, 삭제, 조회가 가능하다&lt;/p&gt;

&lt;h3 id=&quot;1-create-4&quot;&gt;1. Create&lt;/h3&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;http://localhost:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/api/v&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/users/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/study-groups/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/wordbooks&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testWordBook&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Created(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;201&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;isUsing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;self&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;update_studyGroupWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;delete_StudyGroupWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;add_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;get_studyGroup&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그룹 단어장은 그룹 관리자만 생성할 수 있으며 관리자에게는  update_studyGroupWordBook, delete_StudyGroupWordBook 상태로 갈 수 있는 링크가 반환된다.  이외 add_word, get_studyGroup은 모든 그룹 참여자에게 반환 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;6-word-of-studygroupwordbook-도메인&quot;&gt;6. Word Of StudyGroupWordBook 도메인&lt;/h2&gt;

&lt;p&gt;그룹 단어장의 단어이다. 유저 단어장의 단어 기능과 동일 하다.&lt;/p&gt;

&lt;p&gt;추가, 수정, 삭제, 조회가 가능하다&lt;/p&gt;

&lt;h3 id=&quot;1-create-5&quot;&gt;1. Create&lt;/h3&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;http://localhost:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/api/v&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/users/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/study-groups/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/wordbooks/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;voca&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;meaning&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;사과&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Created(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;201&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;voca&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;apple&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;meaning&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;사과&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;_links&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;update_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10/words/11&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;delete_word&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10/words/11&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;get_studyGroupWordBook&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;href&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;유저 단어장의 단어와 유사하다 수정과 삭제를 할 수 있으며 이전 상태인 get_studyGroupWordBook 링크를 반환 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;
&lt;p&gt;현재까지 개발된 내용으로 대략적인 단어장의 기능은 모두 동작하게 됐다. 하지만 부족한 점과 생각해야할것들을 정리 해보겠다.&lt;/p&gt;

&lt;p&gt;첫번째는 먼저 개발만 달려오다보니 API 명세에 대한 내용을 잊고 있었다. 현재 API 반환값은 self -description 이 없기 때문에 완벽한 Rest Api라고 부를수 없다.&lt;/p&gt;

&lt;p&gt;두번째는 테스트 코드 수정 문제 이다. 테스트 코드를 먼저 작성하게 되면서 오류가 발생하는 부분이 줄어드는것은 좋은 점이라 생각하지만 서비스의 구조가 바뀌거나 했을때 수정해야하는 부분이 생각보다 많았다. 다음 부턴 테스트 코드를 작성할때도 조금 더 큰 그림을 보고 당장에 돌아가는 코드보단 잘 설계된 코드로 방향을 맞추어 최대한 수정하는 일이 적어지도록 노력 해봐야겠다.&lt;/p&gt;

&lt;p&gt;부족한 점 두가지 모두 그룹 참여 기능을 구현한 후 조금씩 수정해 나가도록 해보겠다.&lt;/p&gt;</content><author><name>CY</name><email>lcy960729@gmail.com</email></author><category term="wordbook-project" /><category term="WordBookProject" /><summary type="html">2021-01-17 :: 도메인 기능들 구현 완료 모든 도메인에 대해서 Create, Update, Get 메소드의 반환 값이 동일 함으로 Create 메소드의 반환값으로만 설명을 하겠다. 1. User 도메인 먼저 유저이다. 일단 아직 Spring security를 사용하지 않았기 때문에 세션이 존재하지는 않는다. 추가, 수정, 조회가 가능하다. 1. create Request POST http://localhost:8080/api/v1/users Body : { &quot;email&quot;: &quot;testEmail@test.com&quot;, &quot;pw&quot;: &quot;testPw&quot;, &quot;name&quot;: &quot;testName123&quot; } Response status : Created(201) Body : { &quot;id&quot;: 1, &quot;name&quot;: &quot;testName123&quot;, &quot;email&quot;: &quot;testEmail@test.com&quot;, &quot;_links&quot;: { &quot;self&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1&quot; }, &quot;update_user&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1&quot; }, &quot;delete_user&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users&quot; }, &quot;create_studyGroup&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups&quot; }, &quot;create_userWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks&quot; } } } 위와 같은 결과 값이 나오며 다음 상태로 갈 수 있는 정보가 나오게 된다. 2. UserWordBook 도메인 사용자 개인 단어장이다. 추가, 수정, 삭제, 조회가 가능하다. 1. Create Request POST http://localhost:8080/api/v1/users/1/wordbooks Body : { &quot;name&quot;: &quot;testWordBook&quot; } Response status : Created(201) Body : { &quot;id&quot;: 2, &quot;isUsing&quot;: true, &quot;name&quot;: &quot;testWordBook&quot;, &quot;_links&quot;: { &quot;self&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot; }, &quot;update_userWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot; }, &quot;delete_userWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot; }, &quot;add_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words&quot; }, &quot;get_user&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1&quot; } } } 아래와 같이 정상적으로 추가 됐다면 다음 상태에 있는 get_user를 요청 해보자. { &quot;id&quot;: 1, &quot;name&quot;: &quot;testName123&quot;, &quot;email&quot;: &quot;testEmail@test.com&quot;, &quot;wordBookDTOList&quot;: [ { &quot;id&quot;: 2, &quot;name&quot;: &quot;testWordBook&quot;, &quot;_links&quot;: { &quot;get_userWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot; } } } ], ... } 아래 생성한 유저를 요청한 결과이다 밑에 다음 상태를 설명해주는 부분은 생략을 하였다. 달라진 점으론 wordBookDTOList가 생겼다. 그리고 해당 wordBookDTOList의 wordBook을 조회할 수 있는 상태를 나타냈다. 3. Word Of UserWordBook 도메인 유저 개인 단어장의 단어들이다. 추가, 수정, 조회, 삭제가 가능하다. 1. Create Request POST http://localhost:8080/api/v1/users/1/wordbooks/2/words Body : { &quot;voca&quot;: &quot;apple&quot;, &quot;meaning&quot;: &quot;사과&quot; } Response status : Created(201) Body : { &quot;id&quot;: 3, &quot;voca&quot;: &quot;apple&quot;, &quot;meaning&quot;: &quot;사과&quot;, &quot;_links&quot;: { &quot;update_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/3&quot; }, &quot;delete_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/3&quot; }, &quot;get_userWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot; } } } 단어를 2개 정도 생성해보고 다시 get_userWordBook을 호출하게 되면 아래와 같이 단어가 추가되고 해당 단어에서 갈 수 있는 상태인 수정과 삭제 요청을 반환한다. { &quot;id&quot;: 2, &quot;isUsing&quot;: true, &quot;name&quot;: &quot;testWordBook&quot;, &quot;wordDTOList&quot;: [ { &quot;id&quot;: 3, &quot;voca&quot;: &quot;apple&quot;, &quot;meaning&quot;: &quot;사과&quot;, &quot;_links&quot;: { &quot;update_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/3&quot; }, &quot;delete_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/3&quot; } } }, { &quot;id&quot;: 4, &quot;voca&quot;: &quot;banana&quot;, &quot;meaning&quot;: &quot;바나나&quot;, &quot;_links&quot;: { &quot;update_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/4&quot; }, &quot;delete_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words/4&quot; } } } ], &quot;_links&quot;: { &quot;self&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot; }, &quot;update_userWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot; }, &quot;delete_userWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2&quot; }, &quot;add_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/wordbooks/2/words&quot; }, &quot;get_user&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1&quot; } } } 그룹과 관련하여 그룹 관리자와 그룹 사용자로 나뉘게 된다. 그룹 관리자와 그룹 사용자의 기능은 나누어서 구현하였으며 그룹 참여 기능을 구현하게 되면 이후에 다른 권한에 대한 결과값 구현 내용을 추가 하겠다. 4. StudyGroup 도메인 개인 유저들이 모여서 그룹을 만드는 도메인이다. 아직 그룹 참여 기능은 구현되지 않았다. 해당 기능을 구현하기 위해선 어떤 방식으로 그룹에 참여할지에 대한 설계가 필요할것 같다. 추후 회의를 통해서 정하도록 해야겠다. 추가, 수정, 삭제, 조회가 가능하다 1. Create Request POST http://localhost:8080/api/v1/users/1/study-groups Body : { &quot;name&quot;: &quot;testStudyGroup&quot; } Response status : Created(201) Body : { &quot;id&quot;: 6, &quot;name&quot;: &quot;testStudyGroup&quot;, &quot;userDTOList&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;testName123&quot; } ], &quot;_links&quot;: { &quot;self&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot; }, &quot;update_studyGroup&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot; }, &quot;delete_studyGroup&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot; }, &quot;create_studyGroupWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks&quot; }, &quot;get_user&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1&quot; } } } 그룹이 생성되며 그룹 사용자와 그룹 단어장이 반환된다. 그룹 단어장은 현재 없는 상태이므로 반환되지 않도록 하였다. 또한 그룹 생성자는 그룹 관리자 권한을 가지게 되며 해당 관리자가 아닌 유저가 그룹 단어장에 접근 하게 되면 update_studyGroup, delete_studyGroup, create_studyGroupWordBook 해당 링크들을 반환하지 않도록 구현하였다. 이후 다시 get_User를 요청해보겠다. 아래와 같은 결과값이 반환되며 이외 부분은 모두 생략하였다. 각 그룹을 조회 할 수 있는 링크 정보가 담겨 있다. { &quot;id&quot;: 1, &quot;name&quot;: &quot;testName123&quot;, &quot;email&quot;: &quot;testEmail@test.com&quot;, &quot;studyGroupDTOList&quot;: [ { &quot;id&quot;: 6, &quot;name&quot;: &quot;testStudyGroup&quot;, &quot;_links&quot;: { &quot;get_studyGroup&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot; } } } ], ... } 5. StudyGroupWordBook 도메인 그룹에서 사용하는 단어장이다. 유저 단어장과 기능은 동일 하다. 추가, 수정, 삭제, 조회가 가능하다 1. Create Request POST http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks Body : { &quot;name&quot;: &quot;testWordBook&quot; } Response status : Created(201) Body : { &quot;id&quot;: 10, &quot;isUsing&quot;: true, &quot;name&quot;: &quot;testWordBook&quot;, &quot;_links&quot;: { &quot;self&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot; }, &quot;update_studyGroupWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot; }, &quot;delete_StudyGroupWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot; }, &quot;add_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot; }, &quot;get_studyGroup&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6&quot; } } } 그룹 단어장은 그룹 관리자만 생성할 수 있으며 관리자에게는 update_studyGroupWordBook, delete_StudyGroupWordBook 상태로 갈 수 있는 링크가 반환된다. 이외 add_word, get_studyGroup은 모든 그룹 참여자에게 반환 한다. 6. Word Of StudyGroupWordBook 도메인 그룹 단어장의 단어이다. 유저 단어장의 단어 기능과 동일 하다. 추가, 수정, 삭제, 조회가 가능하다 1. Create Request POST http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10 Body : { &quot;voca&quot;: &quot;apple&quot;, &quot;meaning&quot;: &quot;사과&quot; } Response status : Created(201) Body : { &quot;id&quot;: 11, &quot;voca&quot;: &quot;apple&quot;, &quot;meaning&quot;: &quot;사과&quot;, &quot;_links&quot;: { &quot;update_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10/words/11&quot; }, &quot;delete_word&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10/words/11&quot; }, &quot;get_studyGroupWordBook&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/v1/users/1/study-groups/6/wordbooks/10&quot; } } } 유저 단어장의 단어와 유사하다 수정과 삭제를 할 수 있으며 이전 상태인 get_studyGroupWordBook 링크를 반환 한다. 정리 현재까지 개발된 내용으로 대략적인 단어장의 기능은 모두 동작하게 됐다. 하지만 부족한 점과 생각해야할것들을 정리 해보겠다. 첫번째는 먼저 개발만 달려오다보니 API 명세에 대한 내용을 잊고 있었다. 현재 API 반환값은 self -description 이 없기 때문에 완벽한 Rest Api라고 부를수 없다. 두번째는 테스트 코드 수정 문제 이다. 테스트 코드를 먼저 작성하게 되면서 오류가 발생하는 부분이 줄어드는것은 좋은 점이라 생각하지만 서비스의 구조가 바뀌거나 했을때 수정해야하는 부분이 생각보다 많았다. 다음 부턴 테스트 코드를 작성할때도 조금 더 큰 그림을 보고 당장에 돌아가는 코드보단 잘 설계된 코드로 방향을 맞추어 최대한 수정하는 일이 적어지도록 노력 해봐야겠다. 부족한 점 두가지 모두 그룹 참여 기능을 구현한 후 조금씩 수정해 나가도록 해보겠다.</summary></entry></feed>